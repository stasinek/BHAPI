# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/truetype.c"
# 1 "C:\\Documents and Settings\\stasiek.TC12\\My Documents\\prc++\\x86_libraries\\BHAPI\\src\\libs\\freetype\\objs//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/truetype.c"
# 21 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/truetype.c"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/ft2build.h" 1
# 33 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/ft2build.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftheader.h" 1
# 761 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftheader.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/internal.h" 1
# 762 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftheader.h" 2
# 34 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/ft2build.h" 2
# 22 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/truetype.c" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 1
# 20 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftdebug.h" 1
# 29 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftdebug.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftconfig.h" 1
# 43 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftconfig.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftoption.h" 1
# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftoption.h"

# 665 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftoption.h"

# 44 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftconfig.h" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h" 1
# 36 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h"
# 1 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include/stddef.h" 1 3 4
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stddef.h" 1 3 4






# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/crtdefs.h" 1 3 4
# 10 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/crtdefs.h" 3 4
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 1 3 4
# 12 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 3 4
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw_mac.h" 1 3 4
# 13 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 2 3 4
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw_secapi.h" 1 3 4
# 14 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 2 3 4
# 282 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 3 4
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/vadefs.h" 1 3 4
# 9 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/vadefs.h" 3 4
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 1 3 4
# 686 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 3 4
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/sdks/_mingw_directx.h" 1 3 4
# 687 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 2 3 4
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/sdks/_mingw_ddk.h" 1 3 4
# 688 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 2 3 4
# 10 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/vadefs.h" 2 3 4


#pragma pack(push,_CRT_PACKING)
# 22 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/vadefs.h" 3 4
  typedef __builtin_va_list __gnuc_va_list;






  typedef __gnuc_va_list va_list;
# 101 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/vadefs.h" 3 4
#pragma pack(pop)
# 283 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 2 3 4


#pragma pack(push,_CRT_PACKING)
# 379 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 3 4
typedef unsigned int size_t;
# 389 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 3 4
typedef int ssize_t;
# 401 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 3 4
typedef int intptr_t;
# 414 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 3 4
typedef unsigned int uintptr_t;
# 427 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 3 4
typedef int ptrdiff_t;







typedef unsigned short wchar_t;







typedef unsigned short wint_t;
typedef unsigned short wctype_t;
# 463 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 3 4
typedef int errno_t;




typedef long __time32_t;




__extension__ typedef long long __time64_t;





typedef __time32_t time_t;
# 656 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw.h" 3 4
void __attribute__((__cdecl__)) __debugbreak(void);
extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) void __attribute__((__cdecl__)) __debugbreak(void)
{
  __asm__ __volatile__("int {$}3":);
}




const char *__mingw_get_crt_info (void);






#pragma pack(pop)
# 11 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/crtdefs.h" 2 3 4
# 26 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/crtdefs.h" 3 4
typedef size_t rsize_t;
# 153 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/crtdefs.h" 3 4
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct {
  pthreadlocinfo locinfo;
  pthreadmbcinfo mbcinfo;
} _locale_tstruct,*_locale_t;



typedef struct tagLC_ID {
  unsigned short wLanguage;
  unsigned short wCountry;
  unsigned short wCodePage;
} LC_ID,*LPLC_ID;




typedef struct threadlocaleinfostruct {
  int refcount;
  unsigned int lc_codepage;
  unsigned int lc_collate_cp;
  unsigned long lc_handle[6];
  LC_ID lc_id[6];
  struct {
    char *locale;
    wchar_t *wlocale;
    int *refcount;
    int *wrefcount;
  } lc_category[6];
  int lc_clike;
  int mb_cur_max;
  int *lconv_intl_refcount;
  int *lconv_num_refcount;
  int *lconv_mon_refcount;
  struct lconv *lconv;
  int *ctype1_refcount;
  unsigned short *ctype1;
  const unsigned short *pctype;
  const unsigned char *pclmap;
  const unsigned char *pcumap;
  struct __lc_time_data *lc_time_curr;
} threadlocinfo;
# 8 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stddef.h" 2 3 4
# 18 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stddef.h" 3 4
  __attribute__ ((__dllimport__)) extern int *__attribute__((__cdecl__)) _errno(void);

  errno_t __attribute__((__cdecl__)) _set_errno(int _Value);
  errno_t __attribute__((__cdecl__)) _get_errno(int *_Value);


  __attribute__ ((__dllimport__)) extern unsigned long __attribute__((__cdecl__)) __threadid(void);

  __attribute__ ((__dllimport__)) extern uintptr_t __attribute__((__cdecl__)) __threadhandle(void);
# 2 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include/stddef.h" 2 3 4
# 37 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h" 2
# 66 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h"
# 1 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include-fixed/limits.h" 1 3 4
# 34 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include-fixed/limits.h" 3 4
# 1 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include-fixed/syslimits.h" 1 3 4






# 1 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include-fixed/limits.h" 1 3 4
# 168 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include-fixed/limits.h" 3 4
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/limits.h" 1 3 4
# 169 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include-fixed/limits.h" 2 3 4
# 8 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include-fixed/syslimits.h" 2 3 4
# 35 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include-fixed/limits.h" 2 3 4
# 67 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h" 2
# 81 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h"
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/string.h" 1 3
# 36 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/string.h" 3
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _memccpy(void *_Dst,const void *_Src,int _Val,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memchr(const void *_Buf ,int _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp_l(const void *_Buf1,const void *_Buf2,size_t _Size,_locale_t _Locale);
  int __attribute__((__cdecl__)) memcmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  void * __attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _Size) ;
  void * __attribute__((__cdecl__)) mempcpy (void *_Dst, const void *_Src, size_t _Size);
  void * __attribute__((__cdecl__)) memset(void *_Dst,int _Val,size_t _Size);

  void * __attribute__((__cdecl__)) memccpy(void *_Dst,const void *_Src,int _Val,size_t _Size) ;
  int __attribute__((__cdecl__)) memicmp(const void *_Buf1,const void *_Buf2,size_t _Size) ;


  char * __attribute__((__cdecl__)) _strset(char *_Str,int _Val) ;
  char * __attribute__((__cdecl__)) _strset_l(char *_Str,int _Val,_locale_t _Locale) ;
  char * __attribute__((__cdecl__)) strcpy(char * __restrict__ _Dest,const char * __restrict__ _Source);
  char * __attribute__((__cdecl__)) strcat(char * __restrict__ _Dest,const char * __restrict__ _Source);
  int __attribute__((__cdecl__)) strcmp(const char *_Str1,const char *_Str2);
  size_t __attribute__((__cdecl__)) strlen(const char *_Str);
  size_t __attribute__((__cdecl__)) strnlen(const char *_Str,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _Size) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strdup(const char *_Src);
  char *__attribute__((__cdecl__)) strchr(const char *_Str,int _Val);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcmpi(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  int __attribute__((__cdecl__)) strcoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) strcspn(const char *_Str,const char *_Control);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strerror(const char *_ErrMsg) ;
  char *__attribute__((__cdecl__)) strerror(int) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strlwr(char *_String) ;
  char *strlwr_l(char *_String,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strncat(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) strncmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  char *strncpy(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset(char *_Str,int _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset_l(char *str,int c,size_t count,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strpbrk(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strrchr(const char *_Str,int _Ch);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strrev(char *_Str);
  size_t __attribute__((__cdecl__)) strspn(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strstr(const char *_Str,const char *_SubStr);
  char *__attribute__((__cdecl__)) strtok(char * __restrict__ _Str,const char * __restrict__ _Delim) ;
       

  char *strtok_r(char * __restrict__ _Str, const char * __restrict__ _Delim, char ** __restrict__ __last);
       
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strupr(char *_String) ;
  __attribute__ ((__dllimport__)) char *_strupr_l(char *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) strxfrm(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _strxfrm_l(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);


  char *__attribute__((__cdecl__)) strdup(const char *_Src) ;
  int __attribute__((__cdecl__)) strcmpi(const char *_Str1,const char *_Str2) ;
  int __attribute__((__cdecl__)) stricmp(const char *_Str1,const char *_Str2) ;
  char *__attribute__((__cdecl__)) strlwr(char *_Str) ;
  int __attribute__((__cdecl__)) strnicmp(const char *_Str1,const char *_Str,size_t _MaxCount) ;
  int __attribute__((__cdecl__)) strncasecmp (const char *, const char *, size_t);
  int __attribute__((__cdecl__)) strcasecmp (const char *, const char *);

  extern __inline__ int __attribute__((__cdecl__)) strncasecmp (const char *__sz1, const char *__sz2, size_t __sizeMaxCompare) { return _strnicmp (__sz1, __sz2, __sizeMaxCompare); }
  extern __inline__ int __attribute__((__cdecl__)) strcasecmp (const char *__sz1, const char *__sz2) { return _stricmp (__sz1, __sz2); }




  char *__attribute__((__cdecl__)) strnset(char *_Str,int _Val,size_t _MaxCount) ;
  char *__attribute__((__cdecl__)) strrev(char *_Str) ;
  char *__attribute__((__cdecl__)) strset(char *_Str,int _Val) ;
  char *__attribute__((__cdecl__)) strupr(char *_Str) ;





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsdup(const wchar_t *_Str);
  wchar_t *__attribute__((__cdecl__)) wcscat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  wchar_t *__attribute__((__cdecl__)) wcschr(const wchar_t *_Str,wchar_t _Ch);
  int __attribute__((__cdecl__)) wcscmp(const wchar_t *_Str1,const wchar_t *_Str2);
  wchar_t *__attribute__((__cdecl__)) wcscpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  size_t __attribute__((__cdecl__)) wcscspn(const wchar_t *_Str,const wchar_t *_Control);
  size_t __attribute__((__cdecl__)) wcslen(const wchar_t *_Str);
  size_t __attribute__((__cdecl__)) wcsnlen(const wchar_t *_Src,size_t _MaxCount);
  wchar_t *wcsncat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) wcsncmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  wchar_t *wcsncpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  wchar_t *__attribute__((__cdecl__)) _wcsncpy_l(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count,_locale_t _Locale) ;
  wchar_t *__attribute__((__cdecl__)) wcspbrk(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsrchr(const wchar_t *_Str,wchar_t _Ch);
  size_t __attribute__((__cdecl__)) wcsspn(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsstr(const wchar_t *_Str,const wchar_t *_SubStr);
  wchar_t *__attribute__((__cdecl__)) wcstok(wchar_t * __restrict__ _Str,const wchar_t * __restrict__ _Delim) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcserror(int _ErrNum) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) __wcserror(const wchar_t *_Str) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsrev(wchar_t *_Str);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsset(wchar_t *_Str,wchar_t _Val) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcslwr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcslwr_l(wchar_t *_String,_locale_t _Locale) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsupr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcsupr_l(wchar_t *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcsxfrm(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsxfrm_l(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) wcscoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcscoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);


  wchar_t *__attribute__((__cdecl__)) wcsdup(const wchar_t *_Str) ;

  int __attribute__((__cdecl__)) wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2) ;
  int __attribute__((__cdecl__)) wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsrev(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsset(wchar_t *_Str,wchar_t _Val) ;
  wchar_t *__attribute__((__cdecl__)) wcslwr(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsupr(wchar_t *_Str) ;
  int __attribute__((__cdecl__)) wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2) ;







# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/sec_api/string_s.h" 1 3
# 9 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/sec_api/string_s.h" 3
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/string.h" 1 3
# 10 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/sec_api/string_s.h" 2 3







  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strset_s(char *_Dst,size_t _DstSize,int _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strerror_s(char *_Buf,size_t _SizeInBytes,const char *_ErrMsg);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strerror_s(char *_Buf,size_t _SizeInBytes,int _ErrNum);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s(char *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s_l(char *_Str,size_t _Size,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strnset_s(char *_Str,size_t _Size,int _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s(char *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s_l(char *_Str,size_t _Size,_locale_t _Locale);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncat_s(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncat_s_l(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcpy_s(char * _Dst, size_t _SizeInBytes, const char * _Src);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncpy_s(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncpy_s_l(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) strtok_s(char *_Str,const char *_Delim,char **_Context);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strtok_s_l(char *_Str,const char *_Delim,char **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcat_s(char * strDestination, size_t numberOfElements, const char * strSource);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) memmove_s(void *_dest,size_t _numberOfElements,const void *_src,size_t _count);


  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) wcstok_s(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcserror_s(wchar_t *_Buf,size_t _SizeInWords,int _ErrNum);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) __wcserror_s(wchar_t *_Buffer,size_t _SizeInWords,const wchar_t *_ErrMsg);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s(wchar_t *_Dst,size_t _DstSizeInWords,wchar_t _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s(wchar_t *_Str,size_t _SizeInWords,wchar_t _Val);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s(wchar_t *_Str,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s_l(wchar_t *_Str,size_t _SizeInWords,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s(wchar_t *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s_l(wchar_t *_Str,size_t _Size,_locale_t _Locale);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t * _Dst, size_t _nElem, const wchar_t * _Src);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t * _Dst, size_t _nElem, const wchar_t * _Src);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncat_s(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncat_s_l(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncpy_s(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncpy_s_l(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcstok_s_l(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s_l(wchar_t *_Str,size_t _SizeInChars,unsigned int _Val,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s_l(wchar_t *_Str,size_t _SizeInChars,unsigned int _Val, size_t _Count,_locale_t _Locale);





  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) memcpy_s (void *_dest,size_t _numberOfElements,const void *_src,size_t _count);
# 181 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/string.h" 2 3
# 82 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h" 2
# 105 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h"
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 1 3
# 11 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw_print_push.h" 1 3
# 12 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 2 3

#pragma pack(push,_CRT_PACKING)
# 26 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
  struct _iobuf {
    char *_ptr;
    int _cnt;
    char *_base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char *_tmpfname;
  };
  typedef struct _iobuf FILE;
# 80 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw_off_t.h" 1 3




  typedef long _off_t;

  typedef long off32_t;





  __extension__ typedef long long _off64_t;

  __extension__ typedef long long off64_t;
# 26 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw_off_t.h" 3
typedef off32_t off_t;
# 81 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 2 3
# 91 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
extern FILE (* _imp___iob)[];
# 103 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
  __extension__ typedef long long fpos_t;
# 139 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
extern
  __attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_sscanf(const char * __restrict__ _Src,const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vsscanf (const char * __restrict__ _Str,const char * __restrict__ Format,va_list argp);
extern
  __attribute__((__format__ (gnu_scanf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_scanf(const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vscanf(const char * __restrict__ Format, va_list argp);
extern
  __attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfscanf (FILE * __restrict__ fp, const char * __restrict__ Format,va_list argp);

extern
  __attribute__((__format__ (gnu_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnprintf(char * __restrict__ _DstBuf,size_t _MaxCount,const char * __restrict__ _Format,
                               va_list _ArgList);
extern
  __attribute__((__format__ (gnu_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snprintf(char * __restrict__ s, size_t n, const char * __restrict__ format, ...);
extern
  __attribute__((__format__ (gnu_printf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_printf(const char * __restrict__ , ... ) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vprintf (const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fprintf (FILE * __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfprintf (FILE * __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_sprintf (char * __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vsprintf (char * __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__((nonnull (1,2)))
  int __attribute__((__cdecl__)) __mingw_asprintf(char ** __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__((nonnull (1,2)))
  int __attribute__((__cdecl__)) __mingw_vasprintf(char ** __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
# 377 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
  int __attribute__((__cdecl__)) fprintf(FILE * __restrict__ _File,const char * __restrict__ _Format,...);
  int __attribute__((__cdecl__)) printf(const char * __restrict__ _Format,...);
  int __attribute__((__cdecl__)) sprintf(char * __restrict__ _Dest,const char * __restrict__ _Format,...) ;

  int __attribute__((__cdecl__)) vfprintf(FILE * __restrict__ _File,const char * __restrict__ _Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vprintf(const char * __restrict__ _Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vsprintf(char * __restrict__ _Dest,const char * __restrict__ _Format,va_list _Args) ;

  int __attribute__((__cdecl__)) fscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,...) ;
  int __attribute__((__cdecl__)) scanf(const char * __restrict__ _Format,...) ;
  int __attribute__((__cdecl__)) sscanf(const char * __restrict__ _Src,const char * __restrict__ _Format,...) ;





  int __attribute__((__cdecl__)) __ms_vscanf(const char * __restrict__ Format, va_list argp);
  int __attribute__((__cdecl__)) __ms_vfscanf (FILE * __restrict__ fp, const char * __restrict__ Format,va_list argp);
  int __attribute__((__cdecl__)) __ms_vsscanf (const char * __restrict__ _Str,const char * __restrict__ Format,va_list argp);

  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (2)))
  int vfscanf (FILE *__stream, const char *__format, __builtin_va_list __local_argv)
  {
    return __ms_vfscanf (__stream, __format, __local_argv);
  }

  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (2)))
  int vsscanf (const char * __restrict__ __source, const char * __restrict__ __format, __builtin_va_list __local_argv)
  {
    return __ms_vsscanf( __source, __format, __local_argv );
  }
  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (1)))
  int vscanf(const char *__format, __builtin_va_list __local_argv)
  {
    return __ms_vscanf (__format, __local_argv);
  }




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _filbuf(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _flsbuf(int _Ch,FILE *_File);



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _fsopen(const char *_Filename,const char *_Mode,int _ShFlag);

  void __attribute__((__cdecl__)) clearerr(FILE *_File);
  int __attribute__((__cdecl__)) fclose(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fcloseall(void);



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _fdopen(int _FileHandle,const char *_Mode);

  int __attribute__((__cdecl__)) feof(FILE *_File);
  int __attribute__((__cdecl__)) ferror(FILE *_File);
  int __attribute__((__cdecl__)) fflush(FILE *_File);
  int __attribute__((__cdecl__)) fgetc(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fgetchar(void);
  int __attribute__((__cdecl__)) fgetpos(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos);
  int __attribute__((__cdecl__)) fgetpos64(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos);
  char *__attribute__((__cdecl__)) fgets(char * __restrict__ _Buf,int _MaxCount,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fileno(FILE *_File);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _tempnam(const char *_DirName,const char *_FilePrefix);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _flushall(void);
  FILE *__attribute__((__cdecl__)) fopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode) ;
  FILE *fopen64(const char * __restrict__ filename,const char * __restrict__ mode);
  int __attribute__((__cdecl__)) fputc(int _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fputchar(int _Ch);
  int __attribute__((__cdecl__)) fputs(const char * __restrict__ _Str,FILE * __restrict__ _File);
  size_t __attribute__((__cdecl__)) fread(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  FILE *__attribute__((__cdecl__)) freopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode,FILE * __restrict__ _File) ;
  int __attribute__((__cdecl__)) fsetpos(FILE *_File,const fpos_t *_Pos);
  int __attribute__((__cdecl__)) fsetpos64(FILE *_File,const fpos_t *_Pos);
  int __attribute__((__cdecl__)) fseek(FILE *_File,long _Offset,int _Origin);



  int fseeko64(FILE* stream, _off64_t offset, int whence);
  int fseeko(FILE* stream, _off_t offset, int whence);
# 472 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
  long __attribute__((__cdecl__)) ftell(FILE *_File);

  _off_t ftello(FILE * stream);
  _off64_t ftello64(FILE * stream);
# 484 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
  __extension__ int __attribute__((__cdecl__)) _fseeki64(FILE *_File,long long _Offset,int _Origin);
  __extension__ long long __attribute__((__cdecl__)) _ftelli64(FILE *_File);
  size_t __attribute__((__cdecl__)) fwrite(const void * __restrict__ _Str,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) getc(FILE *_File);
  int __attribute__((__cdecl__)) getchar(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _getmaxstdio(void);
  char *__attribute__((__cdecl__)) gets(char *_Buffer) ;
  int __attribute__((__cdecl__)) _getw(FILE *_File);


  void __attribute__((__cdecl__)) perror(const char *_ErrMsg);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _pclose(FILE *_File);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _popen(const char *_Command,const char *_Mode);




  int __attribute__((__cdecl__)) putc(int _Ch,FILE *_File);
  int __attribute__((__cdecl__)) putchar(int _Ch);
  int __attribute__((__cdecl__)) puts(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putw(int _Word,FILE *_File);


  int __attribute__((__cdecl__)) remove(const char *_Filename);
  int __attribute__((__cdecl__)) rename(const char *_OldFilename,const char *_NewFilename);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _unlink(const char *_Filename);

  int __attribute__((__cdecl__)) unlink(const char *_Filename) ;


  void __attribute__((__cdecl__)) rewind(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _rmtmp(void);
  void __attribute__((__cdecl__)) setbuf(FILE * __restrict__ _File,char * __restrict__ _Buffer) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _setmaxstdio(int _Max);
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_output_format(unsigned int _Format);
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _get_output_format(void);
  int __attribute__((__cdecl__)) setvbuf(FILE * __restrict__ _File,char * __restrict__ _Buf,int _Mode,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf(const char * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf(const char * __restrict__ _Src,size_t _MaxCount,const char * __restrict__ _Format,...) ;
  FILE *__attribute__((__cdecl__)) tmpfile(void) ;
  char *__attribute__((__cdecl__)) tmpnam(char *_Buffer);
  int __attribute__((__cdecl__)) ungetc(int _Ch,FILE *_File);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,va_list _Args) ;




       
       


  int __attribute__((__cdecl__)) __ms_vsnprintf(char * __restrict__ d,size_t n,const char * __restrict__ format,va_list arg)
    ;

  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (3)))
  int vsnprintf (char * __restrict__ __stream, size_t __n, const char * __restrict__ __format, va_list __local_argv)
  {
    return __ms_vsnprintf (__stream, __n, __format, __local_argv);
  }

  int __attribute__((__cdecl__)) __ms_snprintf(char * __restrict__ s, size_t n, const char * __restrict__ format, ...);


static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__ ((__nonnull__ (3)))
int snprintf (char * __restrict__ __stream, size_t __n, const char * __restrict__ __format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __ms_vsnprintf (__stream, __n, __format, __local_argv);
  __builtin_va_end( __local_argv );
  return __retval;
}


       
       


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf(const char * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_printf_count_output(int _Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _get_printf_count_output(void);




                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswscanf (const wchar_t * __restrict__ _Str,const wchar_t * __restrict__ Format,va_list argp);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wscanf(const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwscanf(const wchar_t * __restrict__ Format, va_list argp);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwscanf (FILE * __restrict__ fp, const wchar_t * __restrict__ Format,va_list argp);

                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                      __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wprintf(const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnwprintf (wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , va_list);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ , ...);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ ,va_list);
# 725 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
  int __attribute__((__cdecl__)) fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...) ;
  int __attribute__((__cdecl__)) swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...) ;
  int __attribute__((__cdecl__)) wscanf(const wchar_t * __restrict__ _Format,...) ;

  int __attribute__((__cdecl__)) __ms_vwscanf (const wchar_t * __restrict__ , va_list);
  int __attribute__((__cdecl__)) __ms_vfwscanf (FILE * __restrict__ ,const wchar_t * __restrict__ ,va_list);
  int __attribute__((__cdecl__)) __ms_vswscanf (const wchar_t * __restrict__ ,const wchar_t * __restrict__ ,va_list);

  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (2)))
  int vfwscanf (FILE *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
  {
    return __ms_vfwscanf (__stream, __format, __local_argv);
  }

  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (2)))
  int vswscanf (const wchar_t * __restrict__ __source, const wchar_t * __restrict__ __format, __builtin_va_list __local_argv)
  {
    return __ms_vswscanf( __source, __format, __local_argv );
  }
  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (1)))
  int vwscanf(const wchar_t *__format, __builtin_va_list __local_argv)
  {
    return __ms_vwscanf (__format, __local_argv);
  }



  int __attribute__((__cdecl__)) fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
  int __attribute__((__cdecl__)) wprintf(const wchar_t * __restrict__ _Format,...);
  int __attribute__((__cdecl__)) vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
# 768 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfsopen(const wchar_t *_Filename,const wchar_t *_Mode,int _ShFlag);


  wint_t __attribute__((__cdecl__)) fgetwc(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwchar(void);
  wint_t __attribute__((__cdecl__)) fputwc(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) getwc(FILE *_File);
  wint_t __attribute__((__cdecl__)) getwchar(void);
  wint_t __attribute__((__cdecl__)) putwc(wchar_t _Ch,FILE *_File);
  wint_t __attribute__((__cdecl__)) putwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) ungetwc(wint_t _Ch,FILE *_File);
  wchar_t *__attribute__((__cdecl__)) fgetws(wchar_t * __restrict__ _Dst,int _SizeInWords,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) fputws(const wchar_t * __restrict__ _Str,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putws(const wchar_t *_Str);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_c(wchar_t * __restrict__ _DstBuf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_c(wchar_t * __restrict__ _DstBuf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,va_list _Args) ;




       
       


  int __attribute__((__cdecl__)) __ms_snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...);
  int __attribute__((__cdecl__)) __ms_vsnwprintf (wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , va_list);
  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  int snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...)
  {
    int r;
    va_list argp;
    __builtin_va_start (argp, format);
    r = _vsnwprintf (s, n, format, argp);
    __builtin_va_end (argp);
    return r;
  }
  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  int __attribute__((__cdecl__)) vsnwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, va_list arg)
  {
    return _vsnwprintf(s,n,format,arg);
  }
       
       



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,va_list _Args);


# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/swprintf.inl" 1 3
# 21 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/swprintf.inl" 3
static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int vswprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return vsnwprintf( __stream, __count, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int swprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __count, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}
# 825 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 2 3
# 834 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtempnam(const wchar_t *_Directory,const wchar_t *_FilePrefix);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf(const wchar_t * __restrict__ _Src,size_t _MaxCount,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfdopen(int _FileHandle ,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfopen(const wchar_t * __restrict__ _Filename,const wchar_t *__restrict__ _Mode) ;
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfreopen(const wchar_t * __restrict__ _Filename,const wchar_t * __restrict__ _Mode,FILE * __restrict__ _OldFile) ;



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wperror(const wchar_t *_ErrMsg);

  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wpopen(const wchar_t *_Command,const wchar_t *_Mode);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wremove(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtmpnam(wchar_t *_Buffer);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwc_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwc_nolock(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwc_nolock(wint_t _Ch,FILE *_File);
# 884 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _lock_file(FILE *_File);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _unlock_file(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fclose_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fflush_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fseek_nolock(FILE *_File,long _Offset,int _Origin);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _ftell_nolock(FILE *_File);
  __extension__ __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fseeki64_nolock(FILE *_File,long long _Offset,int _Origin);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _ftelli64_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fwrite_nolock(const void * __restrict__ _DstBuf,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _ungetc_nolock(int _Ch,FILE *_File);





  char *__attribute__((__cdecl__)) tempnam(const char *_Directory,const char *_FilePrefix) ;
  int __attribute__((__cdecl__)) fcloseall(void) ;
  FILE *__attribute__((__cdecl__)) fdopen(int _FileHandle,const char *_Format) ;
  int __attribute__((__cdecl__)) fgetchar(void) ;
  int __attribute__((__cdecl__)) fileno(FILE *_File) ;
  int __attribute__((__cdecl__)) flushall(void) ;
  int __attribute__((__cdecl__)) fputchar(int _Ch) ;
  int __attribute__((__cdecl__)) getw(FILE *_File) ;
  int __attribute__((__cdecl__)) putw(int _Ch,FILE *_File) ;
  int __attribute__((__cdecl__)) rmtmp(void) ;
# 926 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
int __attribute__((__cdecl__)) __mingw_str_wide_utf8 (const wchar_t * const wptr, char **mbptr, size_t * buflen);
# 940 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
int __attribute__((__cdecl__)) __mingw_str_utf8_wide (const char *const mbptr, wchar_t ** wptr, size_t * buflen);
# 949 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 3
void __attribute__((__cdecl__)) __mingw_str_free(void *ptr);







#pragma pack(pop)

# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/sec_api/stdio_s.h" 1 3
# 9 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/sec_api/stdio_s.h" 3
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 1 3
# 10 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/sec_api/stdio_s.h" 2 3
# 19 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/sec_api/stdio_s.h" 3
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) clearerr_s(FILE *_File);
  int __attribute__((__cdecl__)) fprintf_s(FILE *_File,const char *_Format,...);
  size_t __attribute__((__cdecl__)) fread_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fscanf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  int __attribute__((__cdecl__)) printf_s(const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scanf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scanf_s_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_c(char *_DstBuf,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_c(char *_DstBuf,size_t _MaxCount,const char *_Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fscanf_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sscanf_l(const char *_Src,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sscanf_s_l(const char *_Src,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_s(const char *_Src,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_l(const char *_Src,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_s_l(const char *_Src,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  int __attribute__((__cdecl__)) vfprintf_s(FILE *_File,const char *_Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vprintf_s(const char *_Format,va_list _ArgList);

  int __attribute__((__cdecl__)) vsnprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,va_list _ArgList);
 

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,va_list _ArgList);
 

  int __attribute__((__cdecl__)) vsprintf_s(char *_DstBuf,size_t _Size,const char *_Format,va_list _ArgList);
 

  int __attribute__((__cdecl__)) sprintf_s(char *_DstBuf,size_t _DstSize,const char *_Format,...);
 

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,...);
 

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_p(FILE *_File,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_p(const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_p(char *_Dst,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_p(FILE *_File,const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_p(const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_p(char *_Dst,size_t _MaxCount,const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_p(const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf_p(const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_p_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_p_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_p_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_p_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_l(char *_DstBuf,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_p_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_l(char *_DstBuf,const char *_Format,_locale_t,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_p_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_p_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf_p_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_s_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_s_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_s_l(char *_DstBuf,size_t _DstSize,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_s_l(char *_DstBuf,size_t _DstSize,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_s_l(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_s_l(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_c_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_c_l(char *_DstBuf,size_t _MaxCount,const char *,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) fopen_s(FILE **_File,const char *_Filename,const char *_Mode);

  __attribute__ ((__dllimport__)) char* __attribute__((__cdecl__)) gets_s(char*,rsize_t);
 

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) tmpnam_s(char*,rsize_t);
 




  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws_s(wchar_t *_Str,size_t _SizeInWords);
 

  int __attribute__((__cdecl__)) fwprintf_s(FILE *_File,const wchar_t *_Format,...);
  int __attribute__((__cdecl__)) wprintf_s(const wchar_t *_Format,...);
  int __attribute__((__cdecl__)) vfwprintf_s(FILE *_File,const wchar_t *_Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vwprintf_s(const wchar_t *_Format,va_list _ArgList);

  int __attribute__((__cdecl__)) vswprintf_s(wchar_t *_Dst,size_t _SizeInWords,const wchar_t *_Format,va_list _ArgList);
 

  int __attribute__((__cdecl__)) swprintf_s(wchar_t *_Dst,size_t _SizeInWords,const wchar_t *_Format,...);
 

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_s(wchar_t *_DstBuf,size_t _DstSizeInWords,size_t _MaxCount,const wchar_t *_Format,va_list _ArgList);
 

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_s(wchar_t *_DstBuf,size_t _DstSizeInWords,size_t _MaxCount,const wchar_t *_Format,...);
 


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_s_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwscanf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swscanf_s_l(const wchar_t *_Src,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_s(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_s_l(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfreopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode,FILE *_OldFile);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wtmpnam_s(wchar_t *_DstBuf,size_t _SizeInWords);
 

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_p(FILE *_File,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_p(const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_p(FILE *_File,const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_p(const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_p(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_p(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_p(const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_p(const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_p_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_p_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_p_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_p_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_c_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_p_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_c_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_p_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_p_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_p_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __swprintf_l(wchar_t *_Dest,const wchar_t *_Format,_locale_t _Plocinfo,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __vswprintf_l(wchar_t *_Dest,const wchar_t *_Format,_locale_t _Plocinfo,va_list _Args);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwscanf_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swscanf_l(const wchar_t *_Src,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_l(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfopen_s(FILE ** _File,const wchar_t *_Filename,const wchar_t *_Mode);



  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);
# 960 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 2 3

# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw_print_pop.h" 1 3
# 962 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdio.h" 2 3
# 106 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h" 2
# 123 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h"
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 1 3
# 10 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
# 1 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include-fixed/limits.h" 1 3 4
# 11 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 2 3





#pragma pack(push,_CRT_PACKING)
# 40 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  typedef int (__attribute__((__cdecl__)) *_onexit_t)(void);
# 50 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  typedef struct _div_t {
    int quot;
    int rem;
  } div_t;

  typedef struct _ldiv_t {
    long quot;
    long rem;
  } ldiv_t;





#pragma pack(4)
  typedef struct {
    unsigned char ld[10];
  } _LDOUBLE;
#pragma pack()



  typedef struct {
    double x;
  } _CRT_DOUBLE;

  typedef struct {
    float f;
  } _CRT_FLOAT;

       


  typedef struct {
    long double x;
  } _LONGDOUBLE;

       

#pragma pack(4)
  typedef struct {
    unsigned char ld12[12];
  } _LDBL12;
#pragma pack()
# 105 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  extern int * _imp____mb_cur_max;
# 131 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  typedef void (__attribute__((__cdecl__)) *_purecall_handler)(void);

  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _set_purecall_handler(_purecall_handler _Handler);
  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _get_purecall_handler(void);

  typedef void (__attribute__((__cdecl__)) *_invalid_parameter_handler)(const wchar_t *,const wchar_t *,const wchar_t *,unsigned int,uintptr_t);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _get_invalid_parameter_handler(void);
# 147 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) unsigned long *__attribute__((__cdecl__)) __doserrno(void);

  errno_t __attribute__((__cdecl__)) _set_doserrno(unsigned long _Value);
  errno_t __attribute__((__cdecl__)) _get_doserrno(unsigned long *_Value);




  extern __attribute__ ((__dllimport__)) char *_sys_errlist[1];
  extern __attribute__ ((__dllimport__)) int _sys_nerr;


  __attribute__ ((__dllimport__)) int *__attribute__((__cdecl__)) __p___argc(void);
  __attribute__ ((__dllimport__)) char ***__attribute__((__cdecl__)) __p___argv(void);
  __attribute__ ((__dllimport__)) wchar_t ***__attribute__((__cdecl__)) __p___wargv(void);
  __attribute__ ((__dllimport__)) char ***__attribute__((__cdecl__)) __p__environ(void);
  __attribute__ ((__dllimport__)) wchar_t ***__attribute__((__cdecl__)) __p__wenviron(void);
  __attribute__ ((__dllimport__)) char **__attribute__((__cdecl__)) __p__pgmptr(void);
  __attribute__ ((__dllimport__)) wchar_t **__attribute__((__cdecl__)) __p__wpgmptr(void);





  extern int * _imp____argc;







  extern char *** _imp____argv;







  extern wchar_t *** _imp____wargv;
# 199 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  extern char *** _imp___environ;
# 208 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  extern wchar_t *** _imp___wenviron;
# 217 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  extern char ** _imp___pgmptr;
# 226 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  extern wchar_t ** _imp___wpgmptr;



  errno_t __attribute__((__cdecl__)) _get_pgmptr(char **_Value);
  errno_t __attribute__((__cdecl__)) _get_wpgmptr(wchar_t **_Value);




  extern int * _imp___fmode;



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_fmode(int _Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_fmode(int *_PMode);





  extern unsigned int * _imp___osplatform;
# 256 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * _imp___osver;
# 265 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * _imp___winver;
# 274 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * _imp___winmajor;
# 283 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * _imp___winminor;




  errno_t __attribute__((__cdecl__)) _get_osplatform(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_osver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winmajor(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winminor(unsigned int *_Value);
# 306 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit(int _Code) __attribute__ ((__noreturn__));
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit(int _Code) __attribute__ ((__noreturn__));



  void __attribute__((__cdecl__)) _Exit(int) __attribute__ ((__noreturn__));

  extern __inline__ __attribute__ ((__noreturn__)) void __attribute__((__cdecl__)) _Exit(int status)
  { _exit(status); }



       

  void __attribute__((__cdecl__)) __attribute__((noreturn)) abort(void);
       



  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_abort_behavior(unsigned int _Flags,unsigned int _Mask);



  int __attribute__((__cdecl__)) abs(int _X);
  long __attribute__((__cdecl__)) labs(long _X);


  __extension__ long long __attribute__((__cdecl__)) _abs64(long long);

  extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) long long __attribute__((__cdecl__)) _abs64(long long x) {
    return __builtin_llabs(x);
  }


  int __attribute__((__cdecl__)) atexit(void (__attribute__((__cdecl__)) *)(void));


  double __attribute__((__cdecl__)) atof(const char *_String);
  double __attribute__((__cdecl__)) _atof_l(const char *_String,_locale_t _Locale);

  int __attribute__((__cdecl__)) atoi(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoi_l(const char *_Str,_locale_t _Locale);
  long __attribute__((__cdecl__)) atol(const char *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atol_l(const char *_Str,_locale_t _Locale);


  void *__attribute__((__cdecl__)) bsearch(const void *_Key,const void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));
  void __attribute__((__cdecl__)) qsort(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));

  unsigned short __attribute__((__cdecl__)) _byteswap_ushort(unsigned short _Short);
  unsigned long __attribute__((__cdecl__)) _byteswap_ulong (unsigned long _Long);
  __extension__ unsigned long long __attribute__((__cdecl__)) _byteswap_uint64(unsigned long long _Int64);
  div_t __attribute__((__cdecl__)) div(int _Numerator,int _Denominator);
  char *__attribute__((__cdecl__)) getenv(const char *_VarName) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _itoa(int _Value,char *_Dest,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _i64toa(long long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ui64toa(unsigned long long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _atoi64(const char *_String);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _atoi64_l(const char *_String,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _strtoi64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _strtoi64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _strtoui64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _strtoui64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  ldiv_t __attribute__((__cdecl__)) ldiv(long _Numerator,long _Denominator);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ltoa(long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) mblen(const char *_Ch,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mblen_l(const char *_Ch,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen(const char *_Str);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen_l(const char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen(const char *_Str,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen_l(const char *_Str,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mbtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mbtowc_l(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) mbstowcs(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstowcs_l(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) rand(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_error_mode(int _Mode);
  void __attribute__((__cdecl__)) srand(unsigned int _Seed);
# 404 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtod(const char * __restrict__ _Str,char ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof(const char * __restrict__ nptr, char ** __restrict__ endptr);

  long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold(const char * __restrict__ , char ** __restrict__ );


  extern double __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
  __strtod (const char * __restrict__ , char ** __restrict__);




  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  long double __attribute__((__cdecl__)) __mingw_strtold(const char * __restrict__, char ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _strtod_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) strtol(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtol_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) strtoul(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoul_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);


  int __attribute__((__cdecl__)) system(const char *_Command);

  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ultoa(unsigned long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) wctomb(char *_MbCh,wchar_t _WCh) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wctomb_l(char *_MbCh,wchar_t _WCh,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcstombs(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcstombs_l(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale) ;



  void *__attribute__((__cdecl__)) calloc(size_t _NumOfElements,size_t _SizeOfElements);
  void __attribute__((__cdecl__)) free(void *_Memory);
  void *__attribute__((__cdecl__)) malloc(size_t _Size);
  void *__attribute__((__cdecl__)) realloc(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _recalloc(void *_Memory,size_t _Count,size_t _Size);


       
       


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _aligned_free(void *_Memory);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_malloc(size_t _Size,size_t _Alignment);
       
       

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_malloc(size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_realloc(void *_Memory,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_realloc(void *_Memory,size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment,size_t _Offset);





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _itow(int _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ltow(long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ultow(unsigned long _Value,wchar_t *_Dest,int _Radix) ;

  double __attribute__((__cdecl__)) __mingw_wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) __mingw_wcstof(const wchar_t * __restrict__ nptr, wchar_t ** __restrict__ endptr);
  long double __attribute__((__cdecl__)) __mingw_wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);
# 482 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  double __attribute__((__cdecl__)) wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) wcstof(const wchar_t * __restrict__ nptr, wchar_t ** __restrict__ endptr);


  long double __attribute__((__cdecl__)) wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wcstod_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) wcstol(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstol_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) wcstoul(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoul_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetenv(const wchar_t *_VarName) ;


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsystem(const wchar_t *_Command);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol_l(const wchar_t *_Str,_locale_t _Locale);

  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _i64tow(long long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ui64tow(unsigned long long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64(const wchar_t *_Str);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64_l(const wchar_t *_Str,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64_l(const wchar_t *_Str ,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);




  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fullpath(char *_FullPath,const char *_Path,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl(_CRT_DOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl(_LDOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt(_CRT_FLOAT *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl_l(_CRT_DOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl_l(_LDOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale);
       
       






  unsigned long __attribute__((__cdecl__)) _lrotl(unsigned long _Val,int _Shift);
  unsigned long __attribute__((__cdecl__)) _lrotr(unsigned long _Val,int _Shift);

       
       

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _makepath(char *_Path,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  _onexit_t __attribute__((__cdecl__)) _onexit(_onexit_t _Func);





  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putenv(const char *_EnvString);
       
       


  __extension__ unsigned long long __attribute__((__cdecl__)) _rotl64(unsigned long long _Val,int _Shift);
  __extension__ unsigned long long __attribute__((__cdecl__)) _rotr64(unsigned long long Value,int Shift);
       
       
       
       


  unsigned int __attribute__((__cdecl__)) _rotr(unsigned int _Val,int _Shift);
  unsigned int __attribute__((__cdecl__)) _rotl(unsigned int _Val,int _Shift);
       
       
  __extension__ unsigned long long __attribute__((__cdecl__)) _rotr64(unsigned long long _Val,int _Shift);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _searchenv(const char *_Filename,const char *_EnvVar,char *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _splitpath(const char *_FullPath,char *_Drive,char *_Dir,char *_Filename,char *_Ext) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _swab(char *_Buf1,char *_Buf2,int _SizeInBytes);



  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wfullpath(wchar_t *_FullPath,const wchar_t *_Path,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wmakepath(wchar_t *_ResultPath,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsearchenv(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsplitpath(const wchar_t *_FullPath,wchar_t *_Drive,wchar_t *_Dir,wchar_t *_Filename,wchar_t *_Ext) ;


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _beep(unsigned _Frequency,unsigned _Duration) __attribute__ ((__deprecated__));

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _seterrormode(int _Mode) __attribute__ ((__deprecated__));
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _sleep(unsigned long _Duration) __attribute__ ((__deprecated__));
# 607 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
  char *__attribute__((__cdecl__)) ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  char *__attribute__((__cdecl__)) itoa(int _Val,char *_DstBuf,int _Radix) ;
  char *__attribute__((__cdecl__)) ltoa(long _Val,char *_DstBuf,int _Radix) ;
  int __attribute__((__cdecl__)) putenv(const char *_EnvString) ;



  void __attribute__((__cdecl__)) swab(char *_Buf1,char *_Buf2,int _SizeInBytes) ;


  char *__attribute__((__cdecl__)) ultoa(unsigned long _Val,char *_Dstbuf,int _Radix) ;
  _onexit_t __attribute__((__cdecl__)) onexit(_onexit_t _Func);





  typedef struct { __extension__ long long quot, rem; } lldiv_t;

  __extension__ lldiv_t __attribute__((__cdecl__)) lldiv(long long, long long);

  __extension__ long long __attribute__((__cdecl__)) llabs(long long);

  __extension__ extern __inline__ long long __attribute__((__cdecl__)) llabs(long long _j) { return (_j >= 0 ? _j : -_j); }


  __extension__ long long __attribute__((__cdecl__)) strtoll(const char * __restrict__, char ** __restrict, int);
  __extension__ unsigned long long __attribute__((__cdecl__)) strtoull(const char * __restrict__, char ** __restrict__, int);


  __extension__ long long __attribute__((__cdecl__)) atoll (const char *);


  __extension__ long long __attribute__((__cdecl__)) wtoll (const wchar_t *);
  __extension__ char *__attribute__((__cdecl__)) lltoa (long long, char *, int);
  __extension__ char *__attribute__((__cdecl__)) ulltoa (unsigned long long , char *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) lltow (long long, wchar_t *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) ulltow (unsigned long long, wchar_t *, int);



  __extension__ extern __inline__ long long __attribute__((__cdecl__)) atoll (const char * _c) { return _atoi64 (_c); }
  __extension__ extern __inline__ char *__attribute__((__cdecl__)) lltoa (long long _n, char * _c, int _i) { return _i64toa (_n, _c, _i); }
  __extension__ extern __inline__ char *__attribute__((__cdecl__)) ulltoa (unsigned long long _n, char * _c, int _i) { return _ui64toa (_n, _c, _i); }
  __extension__ extern __inline__ long long __attribute__((__cdecl__)) wtoll (const wchar_t * _w) { return _wtoi64 (_w); }
  __extension__ extern __inline__ wchar_t *__attribute__((__cdecl__)) lltow (long long _n, wchar_t * _w, int _i) { return _i64tow (_n, _w, _i); }
  __extension__ extern __inline__ wchar_t *__attribute__((__cdecl__)) ulltow (unsigned long long _n, wchar_t * _w, int _i) { return _ui64tow (_n, _w, _i); }
# 665 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 3
#pragma pack(pop)

# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/sec_api/stdlib_s.h" 1 3
# 9 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/sec_api/stdlib_s.h" 3
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 1 3
# 10 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/sec_api/stdlib_s.h" 2 3







  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _dupenv_s(char **_PBuffer,size_t *_PBufferSizeInBytes,const char *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itoa_s(int _Value,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64toa_s(long long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64toa_s(unsigned long long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltoa_s(long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) mbstowcs_s(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _mbstowcs_s_l(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultoa_s(unsigned long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wctomb_s_l(int *_SizeConverted,char *_MbCh,size_t _SizeInBytes,wchar_t _WCh,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcstombs_s(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcstombs_s_l(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes,_locale_t _Locale);



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itow_s (int _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltow_s (long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultow_s (unsigned long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t *_ReturnSize,wchar_t *_DstBuf,size_t _DstSizeInWords,const wchar_t *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wdupenv_s(wchar_t **_Buffer,size_t *_BufferSizeInWords,const wchar_t *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64tow_s(long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64tow_s(unsigned long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ecvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDights,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _fcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDec,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _gcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDigits);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _makepath_s(char *_PathResult,size_t _Size,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _putenv_s(const char *_Name,const char *_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _searchenv_s(const char *_Filename,const char *_EnvVar,char *_ResultPath,size_t _SizeInBytes);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_FullPath,char *_Drive,size_t _DriveSize,char *_Dir,size_t _DirSize,char *_Filename,size_t _FilenameSize,char *_Ext,size_t _ExtSize);
 



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t *_PathResult,size_t _SizeInWords,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wputenv_s(const wchar_t *_Name,const wchar_t *_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath,size_t _SizeInWords);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_FullPath,wchar_t *_Drive,size_t _DriveSizeInWords,wchar_t *_Dir,size_t _DirSizeInWords,wchar_t *_Filename,size_t _FilenameSizeInWords,wchar_t *_Ext,size_t _ExtSizeInWords);
 
# 668 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 2 3
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/malloc.h" 1 3
# 11 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/malloc.h" 3
#pragma pack(push,_CRT_PACKING)
# 46 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/malloc.h" 3
  typedef struct _heapinfo {
    int *_pentry;
    size_t _size;
    int _useflag;
  } _HEAPINFO;


  extern unsigned int _amblksiz;
# 65 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/malloc.h" 3
       
       
# 97 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/malloc.h" 3
       
       




void * __mingw_aligned_malloc (size_t _Size, size_t _Alignment);
void __mingw_aligned_free (void *_Memory);
void * __mingw_aligned_offset_realloc (void *_Memory, size_t _Size, size_t _Alignment, size_t _Offset);
void * __mingw_aligned_realloc (void *_Memory, size_t _Size, size_t _Offset);



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _resetstkoflw (void);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _set_malloc_crt_max_wait(unsigned long _NewValue);

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _expand(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _msize(void *_Memory);






  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _get_sbh_threshold(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_sbh_threshold(size_t _NewValue);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_amblksiz(size_t _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_amblksiz(size_t *_Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapadd(void *_Memory,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapchk(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapmin(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapset(unsigned int _Fill);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapwalk(_HEAPINFO *_EntryInfo);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _heapused(size_t *_Used,size_t *_Commit);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _get_heap_handle(void);
# 144 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/malloc.h" 3
  static __inline void *_MarkAllocaS(void *_Ptr,unsigned int _Marker) {
    if(_Ptr) {
      *((unsigned int*)_Ptr) = _Marker;
      _Ptr = (char*)_Ptr + 8;
    }
    return _Ptr;
  }
# 163 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/malloc.h" 3
  static __inline void __attribute__((__cdecl__)) _freea(void *_Memory) {
    unsigned int _Marker;
    if(_Memory) {
      _Memory = (char*)_Memory - 8;
      _Marker = *(unsigned int *)_Memory;
      if(_Marker==0xDDDD) {
 free(_Memory);
      }





    }
  }
# 209 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/malloc.h" 3
#pragma pack(pop)
# 669 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdlib.h" 2 3
# 124 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h" 2
# 161 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h"
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/setjmp.h" 1 3
# 11 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/setjmp.h" 3
#pragma pack(push,_CRT_PACKING)
# 34 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/setjmp.h" 3
  typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
  } _JUMP_BUFFER;
# 147 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/setjmp.h" 3
  typedef int jmp_buf[16];



void * __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mingw_getsp (void);
# 164 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/setjmp.h" 3
  int __attribute__((__cdecl__)) __attribute__ ((__nothrow__,__returns_twice__)) _setjmp(jmp_buf _Buf, void *_Ctx);
  int __attribute__((__cdecl__)) __attribute__ ((__nothrow__,__returns_twice__)) _setjmp3(jmp_buf _Buf, void *_Ctx);
# 192 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/setjmp.h" 3
  __attribute__((noreturn)) __attribute__ ((__nothrow__)) void __attribute__((__cdecl__)) ms_longjmp(jmp_buf _Buf,int _Value) ;
  __attribute__((noreturn)) __attribute__ ((__nothrow__)) void __attribute__((__cdecl__)) longjmp(jmp_buf _Buf,int _Value);





#pragma pack(pop)
# 162 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h" 2
# 174 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h"
# 1 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include/stdarg.h" 1 3 4
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdarg.h" 1 3 4
# 140 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdarg.h" 3 4
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/_mingw_stdarg.h" 1 3 4
# 141 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stdarg.h" 2 3 4
# 2 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include/stdarg.h" 2 3 4
# 175 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftstdlib.h" 2
# 45 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftconfig.h" 2


# 156 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftconfig.h"
  typedef signed short FT_Int16;
# 167 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftconfig.h"
  typedef unsigned short FT_UInt16;
# 203 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftconfig.h"
  typedef signed int FT_Int32;
  typedef unsigned int FT_UInt32;
# 218 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftconfig.h"
  typedef int FT_Fast;
  typedef unsigned int FT_UFast;
# 416 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/config/ftconfig.h"

# 30 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftdebug.h" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 42 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fterrors.h" 1
# 90 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fterrors.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmoderr.h" 1
# 101 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmoderr.h"
  enum {



  FT_Mod_Err_Base = 0,
  FT_Mod_Err_Autofit = 0,
  FT_Mod_Err_BDF = 0,
  FT_Mod_Err_Cache = 0,
  FT_Mod_Err_CFF = 0,
  FT_Mod_Err_CID = 0,
  FT_Mod_Err_Gzip = 0,
  FT_Mod_Err_LZW = 0,
  FT_Mod_Err_OTvalid = 0,
  FT_Mod_Err_PCF = 0,
  FT_Mod_Err_PFR = 0,
  FT_Mod_Err_PSaux = 0,
  FT_Mod_Err_PShinter = 0,
  FT_Mod_Err_PSnames = 0,
  FT_Mod_Err_Raster = 0,
  FT_Mod_Err_SFNT = 0,
  FT_Mod_Err_Smooth = 0,
  FT_Mod_Err_TrueType = 0,
  FT_Mod_Err_Type1 = 0,
  FT_Mod_Err_Type42 = 0,
  FT_Mod_Err_Winfonts = 0,



  FT_Mod_Err_Max };
# 91 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fterrors.h" 2
# 162 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fterrors.h"
  enum {




# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fterrdef.h" 1
# 34 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fterrdef.h"
  FT_Err_Ok = 0x00,


  FT_Err_Cannot_Open_Resource = 0x01 + 0,

  FT_Err_Unknown_File_Format = 0x02 + 0,

  FT_Err_Invalid_File_Format = 0x03 + 0,

  FT_Err_Invalid_Version = 0x04 + 0,

  FT_Err_Lower_Module_Version = 0x05 + 0,

  FT_Err_Invalid_Argument = 0x06 + 0,

  FT_Err_Unimplemented_Feature = 0x07 + 0,

  FT_Err_Invalid_Table = 0x08 + 0,

  FT_Err_Invalid_Offset = 0x09 + 0,

  FT_Err_Array_Too_Large = 0x0A + 0,




  FT_Err_Invalid_Glyph_Index = 0x10 + 0,

  FT_Err_Invalid_Character_Code = 0x11 + 0,

  FT_Err_Invalid_Glyph_Format = 0x12 + 0,

  FT_Err_Cannot_Render_Glyph = 0x13 + 0,

  FT_Err_Invalid_Outline = 0x14 + 0,

  FT_Err_Invalid_Composite = 0x15 + 0,

  FT_Err_Too_Many_Hints = 0x16 + 0,

  FT_Err_Invalid_Pixel_Size = 0x17 + 0,




  FT_Err_Invalid_Handle = 0x20 + 0,

  FT_Err_Invalid_Library_Handle = 0x21 + 0,

  FT_Err_Invalid_Driver_Handle = 0x22 + 0,

  FT_Err_Invalid_Face_Handle = 0x23 + 0,

  FT_Err_Invalid_Size_Handle = 0x24 + 0,

  FT_Err_Invalid_Slot_Handle = 0x25 + 0,

  FT_Err_Invalid_CharMap_Handle = 0x26 + 0,

  FT_Err_Invalid_Cache_Handle = 0x27 + 0,

  FT_Err_Invalid_Stream_Handle = 0x28 + 0,




  FT_Err_Too_Many_Drivers = 0x30 + 0,

  FT_Err_Too_Many_Extensions = 0x31 + 0,




  FT_Err_Out_Of_Memory = 0x40 + 0,

  FT_Err_Unlisted_Object = 0x41 + 0,




  FT_Err_Cannot_Open_Stream = 0x51 + 0,

  FT_Err_Invalid_Stream_Seek = 0x52 + 0,

  FT_Err_Invalid_Stream_Skip = 0x53 + 0,

  FT_Err_Invalid_Stream_Read = 0x54 + 0,

  FT_Err_Invalid_Stream_Operation = 0x55 + 0,

  FT_Err_Invalid_Frame_Operation = 0x56 + 0,

  FT_Err_Nested_Frame_Access = 0x57 + 0,

  FT_Err_Invalid_Frame_Read = 0x58 + 0,




  FT_Err_Raster_Uninitialized = 0x60 + 0,

  FT_Err_Raster_Corrupted = 0x61 + 0,

  FT_Err_Raster_Overflow = 0x62 + 0,

  FT_Err_Raster_Negative_Height = 0x63 + 0,




  FT_Err_Too_Many_Caches = 0x70 + 0,




  FT_Err_Invalid_Opcode = 0x80 + 0,

  FT_Err_Too_Few_Arguments = 0x81 + 0,

  FT_Err_Stack_Overflow = 0x82 + 0,

  FT_Err_Code_Overflow = 0x83 + 0,

  FT_Err_Bad_Argument = 0x84 + 0,

  FT_Err_Divide_By_Zero = 0x85 + 0,

  FT_Err_Invalid_Reference = 0x86 + 0,

  FT_Err_Debug_OpCode = 0x87 + 0,

  FT_Err_ENDF_In_Exec_Stream = 0x88 + 0,

  FT_Err_Nested_DEFS = 0x89 + 0,

  FT_Err_Invalid_CodeRange = 0x8A + 0,

  FT_Err_Execution_Too_Long = 0x8B + 0,

  FT_Err_Too_Many_Function_Defs = 0x8C + 0,

  FT_Err_Too_Many_Instruction_Defs = 0x8D + 0,

  FT_Err_Table_Missing = 0x8E + 0,

  FT_Err_Horiz_Header_Missing = 0x8F + 0,

  FT_Err_Locations_Missing = 0x90 + 0,

  FT_Err_Name_Table_Missing = 0x91 + 0,

  FT_Err_CMap_Table_Missing = 0x92 + 0,

  FT_Err_Hmtx_Table_Missing = 0x93 + 0,

  FT_Err_Post_Table_Missing = 0x94 + 0,

  FT_Err_Invalid_Horiz_Metrics = 0x95 + 0,

  FT_Err_Invalid_CharMap_Format = 0x96 + 0,

  FT_Err_Invalid_PPem = 0x97 + 0,

  FT_Err_Invalid_Vert_Metrics = 0x98 + 0,

  FT_Err_Could_Not_Find_Context = 0x99 + 0,

  FT_Err_Invalid_Post_Table_Format = 0x9A + 0,

  FT_Err_Invalid_Post_Table = 0x9B + 0,




  FT_Err_Syntax_Error = 0xA0 + 0,

  FT_Err_Stack_Underflow = 0xA1 + 0,

  FT_Err_Ignore = 0xA2 + 0,




  FT_Err_Missing_Startfont_Field = 0xB0 + 0,

  FT_Err_Missing_Font_Field = 0xB1 + 0,

  FT_Err_Missing_Size_Field = 0xB2 + 0,

  FT_Err_Missing_Chars_Field = 0xB3 + 0,

  FT_Err_Missing_Startchar_Field = 0xB4 + 0,

  FT_Err_Missing_Encoding_Field = 0xB5 + 0,

  FT_Err_Missing_Bbx_Field = 0xB6 + 0,

  FT_Err_Bbx_Too_Big = 0xB7 + 0,

  FT_Err_Corrupted_Font_Header = 0xB8 + 0,

  FT_Err_Corrupted_Font_Glyphs = 0xB9 + 0,
# 168 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fterrors.h" 2



  FT_Err_Max };
# 43 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsystem.h" 1
# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsystem.h"

# 66 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsystem.h"
  typedef struct FT_MemoryRec_* FT_Memory;
# 88 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsystem.h"
  typedef void* (*FT_Alloc_Func)( FT_Memory memory,
                    long size );
# 108 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsystem.h"
  typedef void (*FT_Free_Func)( FT_Memory memory,
                   void* block );
# 140 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsystem.h"
  typedef void* (*FT_Realloc_Func)( FT_Memory memory,
                      long cur_size,
                      long new_size,
                      void* block );
# 168 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsystem.h"
  struct FT_MemoryRec_
  {
    void* user;
    FT_Alloc_Func alloc;
    FT_Free_Func free;
    FT_Realloc_Func realloc;
  };
# 193 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsystem.h"
  typedef struct FT_StreamRec_* FT_Stream;
# 206 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsystem.h"
  typedef union FT_StreamDesc_
  {
    long value;
    void* pointer;

  } FT_StreamDesc;
# 243 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsystem.h"
  typedef unsigned long
  (*FT_Stream_IoFunc)( FT_Stream stream,
                       unsigned long offset,
                       unsigned char* buffer,
                       unsigned long count );
# 263 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsystem.h"
  typedef void (*FT_Stream_CloseFunc)( FT_Stream stream );
# 316 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsystem.h"
  typedef struct FT_StreamRec_
  {
    unsigned char* base;
    unsigned long size;
    unsigned long pos;

    FT_StreamDesc descriptor;
    FT_StreamDesc pathname;
    FT_Stream_IoFunc read;
    FT_Stream_CloseFunc close;

    FT_Memory memory;
    unsigned char* cursor;
    unsigned char* limit;

  } FT_StreamRec;






# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h" 1
# 37 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"

# 59 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef signed long FT_Pos;
# 75 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef struct FT_Vector_
  {
    FT_Pos x;
    FT_Pos y;

  } FT_Vector;
# 102 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef struct FT_BBox_
  {
    FT_Pos xMin, yMin;
    FT_Pos xMax, yMax;

  } FT_BBox;
# 157 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef enum FT_Pixel_Mode_
  {
    FT_PIXEL_MODE_NONE = 0,
    FT_PIXEL_MODE_MONO,
    FT_PIXEL_MODE_GRAY,
    FT_PIXEL_MODE_GRAY2,
    FT_PIXEL_MODE_GRAY4,
    FT_PIXEL_MODE_LCD,
    FT_PIXEL_MODE_LCD_V,

    FT_PIXEL_MODE_MAX

  } FT_Pixel_Mode;
# 280 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef struct FT_Bitmap_
  {
    int rows;
    int width;
    int pitch;
    unsigned char* buffer;
    short num_grays;
    char pixel_mode;
    char palette_mode;
    void* palette;

  } FT_Bitmap;
# 338 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef struct FT_Outline_
  {
    short n_contours;
    short n_points;

    FT_Vector* points;
    char* tags;
    short* contours;

    int flags;

  } FT_Outline;
# 494 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_MoveToFunc)( const FT_Vector* to,
                            void* user );
# 521 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_LineToFunc)( const FT_Vector* to,
                            void* user );
# 552 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_ConicToFunc)( const FT_Vector* control,
                             const FT_Vector* to,
                             void* user );
# 584 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_CubicToFunc)( const FT_Vector* control1,
                             const FT_Vector* control2,
                             const FT_Vector* to,
                             void* user );
# 631 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef struct FT_Outline_Funcs_
  {
    FT_Outline_MoveToFunc move_to;
    FT_Outline_LineToFunc line_to;
    FT_Outline_ConicToFunc conic_to;
    FT_Outline_CubicToFunc cubic_to;

    int shift;
    FT_Pos delta;

  } FT_Outline_Funcs;
# 718 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef enum FT_Glyph_Format_
  {
    FT_GLYPH_FORMAT_NONE = ( ( (unsigned long)0 << 24 ) | ( (unsigned long)0 << 16 ) | ( (unsigned long)0 << 8 ) | (unsigned long)0 ),

    FT_GLYPH_FORMAT_COMPOSITE = ( ( (unsigned long)'c' << 24 ) | ( (unsigned long)'o' << 16 ) | ( (unsigned long)'m' << 8 ) | (unsigned long)'p' ),
    FT_GLYPH_FORMAT_BITMAP = ( ( (unsigned long)'b' << 24 ) | ( (unsigned long)'i' << 16 ) | ( (unsigned long)'t' << 8 ) | (unsigned long)'s' ),
    FT_GLYPH_FORMAT_OUTLINE = ( ( (unsigned long)'o' << 24 ) | ( (unsigned long)'u' << 16 ) | ( (unsigned long)'t' << 8 ) | (unsigned long)'l' ),
    FT_GLYPH_FORMAT_PLOTTER = ( ( (unsigned long)'p' << 24 ) | ( (unsigned long)'l' << 16 ) | ( (unsigned long)'o' << 8 ) | (unsigned long)'t' )

  } FT_Glyph_Format;
# 802 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef struct FT_RasterRec_* FT_Raster;
# 831 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef struct FT_Span_
  {
    short x;
    unsigned short len;
    unsigned char coverage;

  } FT_Span;
# 876 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef void (*FT_SpanFunc)( int y,
                  int count,
                  const FT_Span* spans,
                  void* user );
# 907 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_BitTest_Func)( int y,
                             int x,
                             void* user );
# 935 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef void (*FT_Raster_BitSet_Func)( int y,
                            int x,
                            void* user );
# 1042 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef struct FT_Raster_Params_
  {
    const FT_Bitmap* target;
    const void* source;
    int flags;
    FT_SpanFunc gray_spans;
    FT_SpanFunc black_spans;
    FT_Raster_BitTest_Func bit_test;
    FT_Raster_BitSet_Func bit_set;
    void* user;
    FT_BBox clip_box;

  } FT_Raster_Params;
# 1081 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_NewFunc)( void* memory,
                        FT_Raster* raster );
# 1099 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef void (*FT_Raster_DoneFunc)( FT_Raster raster );
# 1131 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef void (*FT_Raster_ResetFunc)( FT_Raster raster,
                          unsigned char* pool_base,
                          unsigned long pool_size );
# 1156 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_SetModeFunc)( FT_Raster raster,
                            unsigned long mode,
                            void* args );
# 1198 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_RenderFunc)( FT_Raster raster,
                           const FT_Raster_Params* params );
# 1224 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftimage.h"
  typedef struct FT_Raster_Funcs_
  {
    FT_Glyph_Format glyph_format;
    FT_Raster_NewFunc raster_new;
    FT_Raster_ResetFunc raster_reset;
    FT_Raster_SetModeFunc raster_set_mode;
    FT_Raster_RenderFunc raster_render;
    FT_Raster_DoneFunc raster_done;

  } FT_Raster_Funcs;






# 27 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h" 2

# 1 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include/stddef.h" 1 3 4
# 1 "C:/Qt/Tools/mingw492_32/i686-w64-mingw32/include/stddef.h" 1 3 4
# 2 "C:/Qt/Tools/mingw492_32/lib/gcc/i686-w64-mingw32/4.9.2/include/stddef.h" 2 3 4
# 29 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h" 2



# 104 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef unsigned char FT_Bool;
# 116 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef signed short FT_FWord;
# 128 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef unsigned short FT_UFWord;
# 139 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef signed char FT_Char;
# 150 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef unsigned char FT_Byte;
# 161 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef const FT_Byte* FT_Bytes;
# 172 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef FT_UInt32 FT_Tag;
# 183 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef char FT_String;
# 194 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef signed short FT_Short;
# 205 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef unsigned short FT_UShort;
# 216 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef signed int FT_Int;
# 227 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef unsigned int FT_UInt;
# 238 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef signed long FT_Long;
# 249 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef unsigned long FT_ULong;
# 260 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef signed short FT_F2Dot14;
# 272 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef signed long FT_F26Dot6;
# 284 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef signed long FT_Fixed;
# 296 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef int FT_Error;
# 307 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef void* FT_Pointer;
# 320 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef size_t FT_Offset;
# 333 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef ptrdiff_t FT_PtrDist;
# 350 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef struct FT_UnitVector_
  {
    FT_F2Dot14 x;
    FT_F2Dot14 y;

  } FT_UnitVector;
# 381 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef struct FT_Matrix_
  {
    FT_Fixed xx, xy;
    FT_Fixed yx, yy;

  } FT_Matrix;
# 402 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef struct FT_Data_
  {
    const FT_Byte* pointer;
    FT_Int length;

  } FT_Data;
# 424 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef void (*FT_Generic_Finalizer)(void* object);
# 455 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef struct FT_Generic_
  {
    void* data;
    FT_Generic_Finalizer finalizer;

  } FT_Generic;
# 510 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListNodeRec_* FT_ListNode;
# 521 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListRec_* FT_List;
# 539 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListNodeRec_
  {
    FT_ListNode prev;
    FT_ListNode next;
    void* data;

  } FT_ListNodeRec;
# 562 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListRec_
  {
    FT_ListNode head;
    FT_ListNode tail;

  } FT_ListRec;
# 582 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttypes.h"

# 44 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 2


# 232 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_Glyph_Metrics_
  {
    FT_Pos width;
    FT_Pos height;

    FT_Pos horiBearingX;
    FT_Pos horiBearingY;
    FT_Pos horiAdvance;

    FT_Pos vertBearingX;
    FT_Pos vertBearingY;
    FT_Pos vertAdvance;

  } FT_Glyph_Metrics;
# 286 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_Bitmap_Size_
  {
    FT_Short height;
    FT_Short width;

    FT_Pos size;

    FT_Pos x_ppem;
    FT_Pos y_ppem;

  } FT_Bitmap_Size;
# 328 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
 typedef struct FT_LibraryRec_ *FT_Library;
# 341 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_ModuleRec_* FT_Module;
# 353 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_DriverRec_* FT_Driver;
# 367 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_RendererRec_* FT_Renderer;
# 392 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_FaceRec_* FT_Face;
# 422 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_SizeRec_* FT_Size;
# 443 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_GlyphSlotRec_* FT_GlyphSlot;
# 475 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_CharMapRec_* FT_CharMap;
# 647 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef enum FT_Encoding_
  {
    FT_ENCODING_NONE = ( ( (FT_UInt32)(0) << 24 ) | ( (FT_UInt32)(0) << 16 ) | ( (FT_UInt32)(0) << 8 ) | (FT_UInt32)(0) ),

    FT_ENCODING_MS_SYMBOL = ( ( (FT_UInt32)('s') << 24 ) | ( (FT_UInt32)('y') << 16 ) | ( (FT_UInt32)('m') << 8 ) | (FT_UInt32)('b') ),
    FT_ENCODING_UNICODE = ( ( (FT_UInt32)('u') << 24 ) | ( (FT_UInt32)('n') << 16 ) | ( (FT_UInt32)('i') << 8 ) | (FT_UInt32)('c') ),

    FT_ENCODING_SJIS = ( ( (FT_UInt32)('s') << 24 ) | ( (FT_UInt32)('j') << 16 ) | ( (FT_UInt32)('i') << 8 ) | (FT_UInt32)('s') ),
    FT_ENCODING_GB2312 = ( ( (FT_UInt32)('g') << 24 ) | ( (FT_UInt32)('b') << 16 ) | ( (FT_UInt32)(' ') << 8 ) | (FT_UInt32)(' ') ),
    FT_ENCODING_BIG5 = ( ( (FT_UInt32)('b') << 24 ) | ( (FT_UInt32)('i') << 16 ) | ( (FT_UInt32)('g') << 8 ) | (FT_UInt32)('5') ),
    FT_ENCODING_WANSUNG = ( ( (FT_UInt32)('w') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('n') << 8 ) | (FT_UInt32)('s') ),
    FT_ENCODING_JOHAB = ( ( (FT_UInt32)('j') << 24 ) | ( (FT_UInt32)('o') << 16 ) | ( (FT_UInt32)('h') << 8 ) | (FT_UInt32)('a') ),


    FT_ENCODING_MS_SJIS = FT_ENCODING_SJIS,
    FT_ENCODING_MS_GB2312 = FT_ENCODING_GB2312,
    FT_ENCODING_MS_BIG5 = FT_ENCODING_BIG5,
    FT_ENCODING_MS_WANSUNG = FT_ENCODING_WANSUNG,
    FT_ENCODING_MS_JOHAB = FT_ENCODING_JOHAB,

    FT_ENCODING_ADOBE_STANDARD = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('O') << 8 ) | (FT_UInt32)('B') ),
    FT_ENCODING_ADOBE_EXPERT = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('B') << 8 ) | (FT_UInt32)('E') ),
    FT_ENCODING_ADOBE_CUSTOM = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('B') << 8 ) | (FT_UInt32)('C') ),
    FT_ENCODING_ADOBE_LATIN_1 = ( ( (FT_UInt32)('l') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('t') << 8 ) | (FT_UInt32)('1') ),

    FT_ENCODING_OLD_LATIN_2 = ( ( (FT_UInt32)('l') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('t') << 8 ) | (FT_UInt32)('2') ),

    FT_ENCODING_APPLE_ROMAN = ( ( (FT_UInt32)('a') << 24 ) | ( (FT_UInt32)('r') << 16 ) | ( (FT_UInt32)('m') << 8 ) | (FT_UInt32)('n') )

  } FT_Encoding;
# 728 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_CharMapRec_
  {
    FT_Face face;
    FT_Encoding encoding;
    FT_UShort platform_id;
    FT_UShort encoding_id;

  } FT_CharMapRec;
# 759 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_Face_InternalRec_* FT_Face_Internal;
# 904 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_FaceRec_
  {
    FT_Long num_faces;
    FT_Long face_index;

    FT_Long face_flags;
    FT_Long style_flags;

    FT_Long num_glyphs;

    FT_String* family_name;
    FT_String* style_name;

    FT_Int num_fixed_sizes;
    FT_Bitmap_Size* available_sizes;

    FT_Int num_charmaps;
    FT_CharMap* charmaps;

    FT_Generic generic;




    FT_BBox bbox;

    FT_UShort units_per_EM;
    FT_Short ascender;
    FT_Short descender;
    FT_Short height;

    FT_Short max_advance_width;
    FT_Short max_advance_height;

    FT_Short underline_position;
    FT_Short underline_thickness;

    FT_GlyphSlot glyph;
    FT_Size size;
    FT_CharMap charmap;



    FT_Driver driver;
    FT_Memory memory;
    FT_Stream stream;

    FT_ListRec sizes_list;

    FT_Generic autohint;
    void* extensions;

    FT_Face_Internal internal;



  } FT_FaceRec;
# 1262 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_InternalRec_* FT_Size_Internal;
# 1320 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_Metrics_
  {
    FT_UShort x_ppem;
    FT_UShort y_ppem;

    FT_Fixed x_scale;
    FT_Fixed y_scale;

    FT_Pos ascender;
    FT_Pos descender;
    FT_Pos height;
    FT_Pos max_advance;

  } FT_Size_Metrics;
# 1355 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_SizeRec_
  {
    FT_Face face;
    FT_Generic generic;
    FT_Size_Metrics metrics;
    FT_Size_Internal internal;

  } FT_SizeRec;
# 1381 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_SubGlyphRec_* FT_SubGlyph;
# 1393 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_Slot_InternalRec_* FT_Slot_Internal;
# 1560 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_GlyphSlotRec_
  {
    FT_Library library;
    FT_Face face;
    FT_GlyphSlot next;
    FT_UInt reserved;
    FT_Generic generic;

    FT_Glyph_Metrics metrics;
    FT_Fixed linearHoriAdvance;
    FT_Fixed linearVertAdvance;
    FT_Vector advance;

    FT_Glyph_Format format;

    FT_Bitmap bitmap;
    FT_Int bitmap_left;
    FT_Int bitmap_top;

    FT_Outline outline;

    FT_UInt num_subglyphs;
    FT_SubGlyph subglyphs;

    void* control_data;
    long control_len;

    FT_Pos lsb_delta;
    FT_Pos rsb_delta;

    void* other;

    FT_Slot_Internal internal;

  } FT_GlyphSlotRec;
# 1621 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Init_FreeType( FT_Library *alibrary );
# 1640 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Done_FreeType( FT_Library library );
# 1709 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_Parameter_
  {
    FT_ULong tag;
    FT_Pointer data;

  } FT_Parameter;
# 1775 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_Open_Args_
  {
    FT_UInt flags;
    const FT_Byte* memory_base;
    FT_Long memory_size;
    FT_String* pathname;
    FT_Stream stream;
    FT_Module driver;
    FT_Int num_params;
    FT_Parameter* params;

  } FT_Open_Args;
# 1814 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_New_Face( FT_Library library,
               const char* filepathname,
               FT_Long face_index,
               FT_Face *aface );
# 1852 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_New_Memory_Face( FT_Library library,
                      const FT_Byte* file_base,
                      FT_Long file_size,
                      FT_Long face_index,
                      FT_Face *aface );
# 1905 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Open_Face( FT_Library library,
                const FT_Open_Args* args,
                FT_Long face_index,
                FT_Face *aface );
# 1929 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Attach_File( FT_Face face,
                  const char* filepathname );
# 1964 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Attach_Stream( FT_Face face,
                    FT_Open_Args* parameters );
# 1984 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Done_Face( FT_Face face );
# 2006 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Select_Size( FT_Face face,
                  FT_Int strike_index );
# 2053 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef enum FT_Size_Request_Type_
  {
    FT_SIZE_REQUEST_TYPE_NOMINAL,
    FT_SIZE_REQUEST_TYPE_REAL_DIM,
    FT_SIZE_REQUEST_TYPE_BBOX,
    FT_SIZE_REQUEST_TYPE_CELL,
    FT_SIZE_REQUEST_TYPE_SCALES,

    FT_SIZE_REQUEST_TYPE_MAX

  } FT_Size_Request_Type;
# 2093 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_RequestRec_
  {
    FT_Size_Request_Type type;
    FT_Long width;
    FT_Long height;
    FT_UInt horiResolution;
    FT_UInt vertResolution;

  } FT_Size_RequestRec;
# 2112 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_RequestRec_ *FT_Size_Request;
# 2138 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Request_Size( FT_Face face,
                   FT_Size_Request req );
# 2178 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Set_Char_Size( FT_Face face,
                    FT_F26Dot6 char_width,
                    FT_F26Dot6 char_height,
                    FT_UInt horz_resolution,
                    FT_UInt vert_resolution );
# 2206 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Set_Pixel_Sizes( FT_Face face,
                      FT_UInt pixel_width,
                      FT_UInt pixel_height );
# 2248 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Load_Glyph( FT_Face face,
                 FT_UInt glyph_index,
                 FT_Int32 load_flags );
# 2283 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Load_Char( FT_Face face,
                FT_ULong char_code,
                FT_Int32 load_flags );
# 2550 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) void
  FT_Set_Transform( FT_Face face,
                    FT_Matrix* matrix,
                    FT_Vector* delta );
# 2606 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef enum FT_Render_Mode_
  {
    FT_RENDER_MODE_NORMAL = 0,
    FT_RENDER_MODE_LIGHT,
    FT_RENDER_MODE_MONO,
    FT_RENDER_MODE_LCD,
    FT_RENDER_MODE_LCD_V,

    FT_RENDER_MODE_MAX

  } FT_Render_Mode;
# 2658 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Render_Glyph( FT_GlyphSlot slot,
                   FT_Render_Mode render_mode );
# 2682 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  typedef enum FT_Kerning_Mode_
  {
    FT_KERNING_DEFAULT = 0,
    FT_KERNING_UNFITTED,
    FT_KERNING_UNSCALED

  } FT_Kerning_Mode;
# 2760 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Get_Kerning( FT_Face face,
                  FT_UInt left_glyph,
                  FT_UInt right_glyph,
                  FT_UInt kern_mode,
                  FT_Vector *akerning );
# 2789 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Get_Track_Kerning( FT_Face face,
                        FT_Fixed point_size,
                        FT_Int degree,
                        FT_Fixed* akerning );
# 2832 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Get_Glyph_Name( FT_Face face,
                     FT_UInt glyph_index,
                     FT_Pointer buffer,
                     FT_UInt buffer_max );
# 2858 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) const char*
  FT_Get_Postscript_Name( FT_Face face );
# 2890 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Select_Charmap( FT_Face face,
                     FT_Encoding encoding );
# 2919 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Set_Charmap( FT_Face face,
                  FT_CharMap charmap );
# 2941 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Int
  FT_Get_Charmap_Index( FT_CharMap charmap );
# 2969 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_UInt
  FT_Get_Char_Index( FT_Face face,
                     FT_ULong charcode );
# 3017 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_ULong
  FT_Get_First_Char( FT_Face face,
                     FT_UInt *agindex );
# 3051 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_ULong
  FT_Get_Next_Char( FT_Face face,
                    FT_ULong char_code,
                    FT_UInt *agindex );
# 3074 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_UInt
  FT_Get_Name_Index( FT_Face face,
                     FT_String* glyph_name );
# 3149 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Get_SubGlyph_Info( FT_GlyphSlot glyph,
                        FT_UInt sub_index,
                        FT_Int *p_index,
                        FT_UInt *p_flags,
                        FT_Int *p_arg1,
                        FT_Int *p_arg2,
                        FT_Matrix *p_transform );
# 3237 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_UInt
  FT_Face_GetCharVariantIndex( FT_Face face,
                               FT_ULong charcode,
                               FT_ULong variantSelector );
# 3273 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Int
  FT_Face_GetCharVariantIsDefault( FT_Face face,
                                   FT_ULong charcode,
                                   FT_ULong variantSelector );
# 3304 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_UInt32*
  FT_Face_GetVariantSelectors( FT_Face face );
# 3337 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_UInt32*
  FT_Face_GetVariantsOfChar( FT_Face face,
                             FT_ULong charcode );
# 3371 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_UInt32*
  FT_Face_GetCharsOfVariant( FT_Face face,
                             FT_ULong variantSelector );
# 3428 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Long
  FT_MulDiv( FT_Long a,
             FT_Long b,
             FT_Long c );
# 3463 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Long
  FT_MulFix( FT_Long a,
             FT_Long b );
# 3491 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Long
  FT_DivFix( FT_Long a,
             FT_Long b );
# 3510 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Fixed
  FT_RoundFix( FT_Fixed a );
# 3529 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Fixed
  FT_CeilFix( FT_Fixed a );
# 3548 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Fixed
  FT_FloorFix( FT_Fixed a );
# 3569 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) void
  FT_Vector_Transform( FT_Vector* vec,
                       const FT_Matrix* matrix );
# 3646 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) void
  FT_Library_Version( FT_Library library,
                      FT_Int *amajor,
                      FT_Int *aminor,
                      FT_Int *apatch );
# 3677 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Bool
  FT_Face_CheckTrueTypePatents( FT_Face face );
# 3704 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h"
  extern __attribute__((dllexport)) FT_Bool
  FT_Face_SetUnpatentedHinting( FT_Face face,
                                FT_Bool value );





# 31 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftdebug.h" 2



# 116 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftdebug.h"
  extern FT_Int
  FT_Trace_Get_Count( void );
# 143 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftdebug.h"
  extern const char *
  FT_Trace_Get_Name( FT_Int idx );
# 232 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftdebug.h"
  extern void
  ft_debug_init( void );
# 245 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftdebug.h"

# 21 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftstream.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftstream.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h" 1
# 30 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftrender.h" 1
# 24 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftrender.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h" 1
# 24 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h" 2
# 33 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"

# 79 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  typedef FT_Pointer FT_Module_Interface;
# 93 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  typedef FT_Error
  (*FT_Module_Constructor)( FT_Module module );
# 108 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  typedef void (*FT_Module_Destructor)( FT_Module module );
# 124 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  typedef FT_Module_Interface
  (*FT_Module_Requester)( FT_Module module,
                          const char* name );
# 158 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  typedef struct FT_Module_Class_
  {
    FT_ULong module_flags;
    FT_Long module_size;
    const FT_String* module_name;
    FT_Fixed module_version;
    FT_Fixed module_requires;

    const void* module_interface;

    FT_Module_Constructor module_init;
    FT_Module_Destructor module_done;
    FT_Module_Requester get_interface;

  } FT_Module_Class;
# 196 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Add_Module( FT_Library library,
                 const FT_Module_Class* clazz );
# 221 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  extern __attribute__((dllexport)) FT_Module
  FT_Get_Module( FT_Library library,
                 const char* module_name );
# 246 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Remove_Module( FT_Library library,
                    FT_Module module );
# 270 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  extern __attribute__((dllexport)) FT_Error
  FT_New_Library( FT_Memory memory,
                  FT_Library *alibrary );
# 290 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Done_Library( FT_Library library );



  typedef void (*FT_DebugHook_Func)( void* arg );
# 325 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  extern __attribute__((dllexport)) void
  FT_Set_Debug_Hook( FT_Library library,
                     FT_UInt hook_index,
                     FT_DebugHook_Func debug_hook );
# 344 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  extern __attribute__((dllexport)) void
  FT_Add_Default_Modules( FT_Library library );
# 398 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  typedef enum FT_TrueTypeEngineType_
  {
    FT_TRUETYPE_ENGINE_TYPE_NONE = 0,
    FT_TRUETYPE_ENGINE_TYPE_UNPATENTED,
    FT_TRUETYPE_ENGINE_TYPE_PATENTED

  } FT_TrueTypeEngineType;
# 427 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmodapi.h"
  extern __attribute__((dllexport)) FT_TrueTypeEngineType
  FT_Get_TrueType_Engine_Type( FT_Library library );






# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftrender.h" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h" 1
# 37 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 38 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h" 2
# 46 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"

# 69 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  typedef struct FT_Glyph_Class_ FT_Glyph_Class;
# 87 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  typedef struct FT_GlyphRec_* FT_Glyph;
# 108 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  typedef struct FT_GlyphRec_
  {
    FT_Library library;
    const FT_Glyph_Class* clazz;
    FT_Glyph_Format format;
    FT_Vector advance;

  } FT_GlyphRec;
# 127 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  typedef struct FT_BitmapGlyphRec_* FT_BitmapGlyph;
# 160 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  typedef struct FT_BitmapGlyphRec_
  {
    FT_GlyphRec root;
    FT_Int left;
    FT_Int top;
    FT_Bitmap bitmap;

  } FT_BitmapGlyphRec;
# 179 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  typedef struct FT_OutlineGlyphRec_* FT_OutlineGlyph;
# 208 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  typedef struct FT_OutlineGlyphRec_
  {
    FT_GlyphRec root;
    FT_Outline outline;

  } FT_OutlineGlyphRec;
# 233 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Get_Glyph( FT_GlyphSlot slot,
                FT_Glyph *aglyph );
# 257 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Glyph_Copy( FT_Glyph source,
                 FT_Glyph *target );
# 286 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Glyph_Transform( FT_Glyph glyph,
                      FT_Matrix* matrix,
                      FT_Vector* delta );
# 316 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  typedef enum FT_Glyph_BBox_Mode_
  {
    FT_GLYPH_BBOX_UNSCALED = 0,
    FT_GLYPH_BBOX_SUBPIXELS = 0,
    FT_GLYPH_BBOX_GRIDFIT = 1,
    FT_GLYPH_BBOX_TRUNCATE = 2,
    FT_GLYPH_BBOX_PIXELS = 3

  } FT_Glyph_BBox_Mode;
# 412 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  extern __attribute__((dllexport)) void
  FT_Glyph_Get_CBox( FT_Glyph glyph,
                     FT_UInt bbox_mode,
                     FT_BBox *acbox );
# 487 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Glyph_To_Bitmap( FT_Glyph* the_glyph,
                      FT_Render_Mode render_mode,
                      FT_Vector* origin,
                      FT_Bool destroy );
# 505 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  extern __attribute__((dllexport)) void
  FT_Done_Glyph( FT_Glyph glyph );
# 538 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  extern __attribute__((dllexport)) void
  FT_Matrix_Multiply( const FT_Matrix* a,
                      FT_Matrix* b );
# 558 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftglyph.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Matrix_Invert( FT_Matrix* matrix );






# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftrender.h" 2



# 40 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftrender.h"
  typedef FT_Error
  (*FT_Glyph_InitFunc)( FT_Glyph glyph,
                        FT_GlyphSlot slot );


  typedef void (*FT_Glyph_DoneFunc)( FT_Glyph glyph );

  typedef void (*FT_Glyph_TransformFunc)( FT_Glyph glyph,
                             const FT_Matrix* matrix,
                             const FT_Vector* delta );

  typedef void (*FT_Glyph_GetBBoxFunc)( FT_Glyph glyph,
                           FT_BBox* abbox );

  typedef FT_Error
  (*FT_Glyph_CopyFunc)( FT_Glyph source,
                        FT_Glyph target );

  typedef FT_Error
  (*FT_Glyph_PrepareFunc)( FT_Glyph glyph,
                           FT_GlyphSlot slot );
# 71 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftrender.h"
  struct FT_Glyph_Class_
  {
    FT_Long glyph_size;
    FT_Glyph_Format glyph_format;
    FT_Glyph_InitFunc glyph_init;
    FT_Glyph_DoneFunc glyph_done;
    FT_Glyph_CopyFunc glyph_copy;
    FT_Glyph_TransformFunc glyph_transform;
    FT_Glyph_GetBBoxFunc glyph_bbox;
    FT_Glyph_PrepareFunc glyph_prepare;
  };


  typedef FT_Error
  (*FT_Renderer_RenderFunc)( FT_Renderer renderer,
                             FT_GlyphSlot slot,
                             FT_UInt mode,
                             const FT_Vector* origin );

  typedef FT_Error
  (*FT_Renderer_TransformFunc)( FT_Renderer renderer,
                                FT_GlyphSlot slot,
                                const FT_Matrix* matrix,
                                const FT_Vector* delta );


  typedef void (*FT_Renderer_GetCBoxFunc)( FT_Renderer renderer,
                              FT_GlyphSlot slot,
                              FT_BBox* cbox );


  typedef FT_Error
  (*FT_Renderer_SetModeFunc)( FT_Renderer renderer,
                              FT_ULong mode_tag,
                              FT_Pointer mode_ptr );
# 144 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftrender.h"
  typedef struct FT_Renderer_Class_
  {
    FT_Module_Class root;

    FT_Glyph_Format glyph_format;

    FT_Renderer_RenderFunc render_glyph;
    FT_Renderer_TransformFunc transform_glyph;
    FT_Renderer_GetCBoxFunc get_glyph_cbox;
    FT_Renderer_SetModeFunc set_mode;

    FT_Raster_Funcs* raster_class;

  } FT_Renderer_Class;
# 183 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftrender.h"
  extern __attribute__((dllexport)) FT_Renderer
  FT_Get_Renderer( FT_Library library,
                   FT_Glyph_Format format );
# 215 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftrender.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Set_Renderer( FT_Library library,
                   FT_Renderer renderer,
                   FT_UInt num_params,
                   FT_Parameter* parameters );






# 31 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsizes.h" 1
# 33 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsizes.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 34 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsizes.h" 2
# 42 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsizes.h"

# 99 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsizes.h"
  extern __attribute__((dllexport)) FT_Error
  FT_New_Size( FT_Face face,
               FT_Size* size );
# 120 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsizes.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Done_Size( FT_Size size );
# 148 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftsizes.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Activate_Size( FT_Size size );





# 32 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftlcdfil.h" 1
# 24 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftlcdfil.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftlcdfil.h" 2



# 88 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftlcdfil.h"
  typedef enum FT_LcdFilter_
  {
    FT_LCD_FILTER_NONE = 0,
    FT_LCD_FILTER_DEFAULT = 1,
    FT_LCD_FILTER_LIGHT = 2,
    FT_LCD_FILTER_LEGACY = 16,

    FT_LCD_FILTER_MAX

  } FT_LcdFilter;
# 154 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftlcdfil.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Library_SetLcdFilter( FT_Library library,
                           FT_LcdFilter filter );





# 33 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftmemory.h" 1
# 28 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftmemory.h"

# 101 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftmemory.h"
  extern FT_Pointer
  ft_mem_alloc( FT_Memory memory,
                FT_Long size,
                FT_Error *p_error );

  extern FT_Pointer
  ft_mem_qalloc( FT_Memory memory,
                 FT_Long size,
                 FT_Error *p_error );

  extern FT_Pointer
  ft_mem_realloc( FT_Memory memory,
                  FT_Long item_size,
                  FT_Long cur_count,
                  FT_Long new_count,
                  void* block,
                  FT_Error *p_error );

  extern FT_Pointer
  ft_mem_qrealloc( FT_Memory memory,
                   FT_Long item_size,
                   FT_Long cur_count,
                   FT_Long new_count,
                   void* block,
                   FT_Error *p_error );

  extern void
  ft_mem_free( FT_Memory memory,
               const void* P );
# 295 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftmemory.h"
  extern FT_Error
  FT_Alloc( FT_Memory memory,
            FT_Long size,
            void* *P );

  extern FT_Error
  FT_QAlloc( FT_Memory memory,
             FT_Long size,
             void* *p );

  extern FT_Error
  FT_Realloc( FT_Memory memory,
              FT_Long current,
              FT_Long size,
              void* *P );

  extern FT_Error
  FT_QRealloc( FT_Memory memory,
               FT_Long current,
               FT_Long size,
               void* *p );

  extern void
  FT_Free( FT_Memory memory,
           void* *P );




  extern FT_Pointer
  ft_mem_strdup( FT_Memory memory,
                 const char* str,
                 FT_Error *p_error );

  extern FT_Pointer
  ft_mem_dup( FT_Memory memory,
              const void* address,
              FT_ULong size,
              FT_Error *p_error );
# 351 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftmemory.h"
  extern FT_Int
  ft_mem_strcpyn( char* dst,
                  const char* src,
                  FT_ULong size );








# 34 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftgloadr.h" 1
# 24 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftgloadr.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftgloadr.h" 2



# 43 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftgloadr.h"
  typedef struct FT_GlyphLoaderRec_* FT_GlyphLoader ;
# 57 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftgloadr.h"
  typedef struct FT_SubGlyphRec_
  {
    FT_Int index;
    FT_UShort flags;
    FT_Int arg1;
    FT_Int arg2;
    FT_Matrix transform;

  } FT_SubGlyphRec;


  typedef struct FT_GlyphLoadRec_
  {
    FT_Outline outline;
    FT_Vector* extra_points;
    FT_Vector* extra_points2;
    FT_UInt num_subglyphs;
    FT_SubGlyph subglyphs;

  } FT_GlyphLoadRec, *FT_GlyphLoad;


  typedef struct FT_GlyphLoaderRec_
  {
    FT_Memory memory;
    FT_UInt max_points;
    FT_UInt max_contours;
    FT_UInt max_subglyphs;
    FT_Bool use_extra;

    FT_GlyphLoadRec base;
    FT_GlyphLoadRec current;

    void* other;

  } FT_GlyphLoaderRec;



  extern FT_Error
  FT_GlyphLoader_New( FT_Memory memory,
                      FT_GlyphLoader *aloader );


  extern FT_Error
  FT_GlyphLoader_CreateExtra( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Done( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Reset( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Rewind( FT_GlyphLoader loader );



  extern FT_Error
  FT_GlyphLoader_CheckPoints( FT_GlyphLoader loader,
                              FT_UInt n_points,
                              FT_UInt n_contours );
# 143 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftgloadr.h"
  extern FT_Error
  FT_GlyphLoader_CheckSubGlyphs( FT_GlyphLoader loader,
                                 FT_UInt n_subs );


  extern void
  FT_GlyphLoader_Prepare( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Add( FT_GlyphLoader loader );


  extern FT_Error
  FT_GlyphLoader_CopyPoints( FT_GlyphLoader target,
                             FT_GlyphLoader source );





# 35 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftdriver.h" 1
# 27 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftdriver.h"



  typedef FT_Error
  (*FT_Face_InitFunc)( FT_Stream stream,
                       FT_Face face,
                       FT_Int typeface_index,
                       FT_Int num_params,
                       FT_Parameter* parameters );

  typedef void (*FT_Face_DoneFunc)( FT_Face face );


  typedef FT_Error
  (*FT_Size_InitFunc)( FT_Size size );

  typedef void (*FT_Size_DoneFunc)( FT_Size size );


  typedef FT_Error
  (*FT_Slot_InitFunc)( FT_GlyphSlot slot );

  typedef void (*FT_Slot_DoneFunc)( FT_GlyphSlot slot );


  typedef FT_Error
  (*FT_Size_RequestFunc)( FT_Size size,
                          FT_Size_Request req );

  typedef FT_Error
  (*FT_Size_SelectFunc)( FT_Size size,
                         FT_ULong size_index );



  typedef FT_Error
  (*FT_Size_ResetPointsFunc)( FT_Size size,
                              FT_F26Dot6 char_width,
                              FT_F26Dot6 char_height,
                              FT_UInt horz_resolution,
                              FT_UInt vert_resolution );

  typedef FT_Error
  (*FT_Size_ResetPixelsFunc)( FT_Size size,
                              FT_UInt pixel_width,
                              FT_UInt pixel_height );



  typedef FT_Error
  (*FT_Slot_LoadFunc)( FT_GlyphSlot slot,
                       FT_Size size,
                       FT_UInt glyph_index,
                       FT_Int32 load_flags );


  typedef FT_UInt
  (*FT_CharMap_CharIndexFunc)( FT_CharMap charmap,
                               FT_Long charcode );

  typedef FT_Long
  (*FT_CharMap_CharNextFunc)( FT_CharMap charmap,
                              FT_Long charcode );

  typedef FT_Error
  (*FT_Face_GetKerningFunc)( FT_Face face,
                             FT_UInt left_glyph,
                             FT_UInt right_glyph,
                             FT_Vector* kerning );


  typedef FT_Error
  (*FT_Face_AttachFunc)( FT_Face face,
                         FT_Stream stream );


  typedef FT_Error
  (*FT_Face_GetAdvancesFunc)( FT_Face face,
                              FT_UInt first,
                              FT_UInt count,
                              FT_Bool vertical,
                              FT_UShort* advances );
# 179 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftdriver.h"
  typedef struct FT_Driver_ClassRec_
  {
    FT_Module_Class root;

    FT_Long face_object_size;
    FT_Long size_object_size;
    FT_Long slot_object_size;

    FT_Face_InitFunc init_face;
    FT_Face_DoneFunc done_face;

    FT_Size_InitFunc init_size;
    FT_Size_DoneFunc done_size;

    FT_Slot_InitFunc init_slot;
    FT_Slot_DoneFunc done_slot;



    FT_Size_ResetPointsFunc set_char_sizes;
    FT_Size_ResetPixelsFunc set_pixel_sizes;



    FT_Slot_LoadFunc load_glyph;

    FT_Face_GetKerningFunc get_kerning;
    FT_Face_AttachFunc attach_file;
    FT_Face_GetAdvancesFunc get_advances;


    FT_Size_RequestFunc request_size;
    FT_Size_SelectFunc select_size;

  } FT_Driver_ClassRec, *FT_Driver_Class;
# 225 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftdriver.h"
  extern FT_Error
  ft_stub_set_char_sizes( FT_Size size,
                          FT_F26Dot6 width,
                          FT_F26Dot6 height,
                          FT_UInt horz_res,
                          FT_UInt vert_res );

  extern FT_Error
  ft_stub_set_pixel_sizes( FT_Size size,
                           FT_UInt width,
                           FT_UInt height );





# 36 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/autohint.h" 1
# 74 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/autohint.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 75 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/autohint.h" 2





  typedef struct FT_AutoHinterRec_ *FT_AutoHinter;
# 104 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/autohint.h"
  typedef void (*FT_AutoHinter_GlobalGetFunc)( FT_AutoHinter hinter,
                                  FT_Face face,
                                  void** global_hints,
                                  long* global_len );
# 125 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/autohint.h"
  typedef void (*FT_AutoHinter_GlobalDoneFunc)( FT_AutoHinter hinter,
                                   void* global );
# 144 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/autohint.h"
  typedef void (*FT_AutoHinter_GlobalResetFunc)( FT_AutoHinter hinter,
                                    FT_Face face );
# 171 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/autohint.h"
  typedef FT_Error
  (*FT_AutoHinter_GlyphLoadFunc)( FT_AutoHinter hinter,
                                  FT_GlyphSlot slot,
                                  FT_Size size,
                                  FT_UInt glyph_index,
                                  FT_Int32 load_flags );
# 187 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/autohint.h"
  typedef struct FT_AutoHinter_ServiceRec_
  {
    FT_AutoHinter_GlobalResetFunc reset_face;
    FT_AutoHinter_GlobalGetFunc get_global_hints;
    FT_AutoHinter_GlobalDoneFunc done_global_hints;
    FT_AutoHinter_GlyphLoadFunc load_glyph;

  } FT_AutoHinter_ServiceRec, *FT_AutoHinter_Service;



# 37 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftserv.h" 1
# 35 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftserv.h"

# 157 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftserv.h"
  typedef struct FT_ServiceDescRec_
  {
    const char* serv_id;
    const void* serv_data;

  } FT_ServiceDescRec;

  typedef const FT_ServiceDescRec* FT_ServiceDesc;
# 176 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftserv.h"
  extern FT_Pointer
  ft_service_list_lookup( FT_ServiceDesc service_descriptors,
                          const char* service_id );
# 202 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftserv.h"
  typedef struct FT_ServiceCacheRec_
  {
    FT_Pointer service_POSTSCRIPT_FONT_NAME;
    FT_Pointer service_MULTI_MASTERS;
    FT_Pointer service_GLYPH_DICT;
    FT_Pointer service_PFR_METRICS;
    FT_Pointer service_WINFNT;

  } FT_ServiceCacheRec, *FT_ServiceCache;
# 323 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftserv.h"

# 38 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h" 2







# 88 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  extern FT_UInt32
  ft_highpow2( FT_UInt32 value );
# 124 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_CMapRec_* FT_CMap;


  typedef const struct FT_CMap_ClassRec_* FT_CMap_Class;


  typedef struct FT_CMapRec_
  {
    FT_CharMapRec charmap;
    FT_CMap_Class clazz;

  } FT_CMapRec;
# 148 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  typedef FT_Error
  (*FT_CMap_InitFunc)( FT_CMap cmap,
                       FT_Pointer init_data );

  typedef void (*FT_CMap_DoneFunc)( FT_CMap cmap );

  typedef FT_UInt
  (*FT_CMap_CharIndexFunc)( FT_CMap cmap,
                            FT_UInt32 char_code );

  typedef FT_UInt
  (*FT_CMap_CharNextFunc)( FT_CMap cmap,
                           FT_UInt32 *achar_code );

  typedef FT_UInt
  (*FT_CMap_CharVarIndexFunc)( FT_CMap cmap,
                               FT_CMap unicode_cmap,
                               FT_UInt32 char_code,
                               FT_UInt32 variant_selector );

  typedef FT_Bool
  (*FT_CMap_CharVarIsDefaultFunc)( FT_CMap cmap,
                                   FT_UInt32 char_code,
                                   FT_UInt32 variant_selector );

  typedef FT_UInt32 *
  (*FT_CMap_VariantListFunc)( FT_CMap cmap,
                              FT_Memory mem );

  typedef FT_UInt32 *
  (*FT_CMap_CharVariantListFunc)( FT_CMap cmap,
                                  FT_Memory mem,
                                  FT_UInt32 char_code );

  typedef FT_UInt32 *
  (*FT_CMap_VariantCharListFunc)( FT_CMap cmap,
                                  FT_Memory mem,
                                  FT_UInt32 variant_selector );


  typedef struct FT_CMap_ClassRec_
  {
    FT_ULong size;
    FT_CMap_InitFunc init;
    FT_CMap_DoneFunc done;
    FT_CMap_CharIndexFunc char_index;
    FT_CMap_CharNextFunc char_next;




    FT_CMap_CharVarIndexFunc char_var_index;
    FT_CMap_CharVarIsDefaultFunc char_var_default;
    FT_CMap_VariantListFunc variant_list;
    FT_CMap_CharVariantListFunc charvariant_list;
    FT_CMap_VariantCharListFunc variantchar_list;

  } FT_CMap_ClassRec;



  extern FT_Error
  FT_CMap_New( FT_CMap_Class clazz,
               FT_Pointer init_data,
               FT_CharMap charmap,
               FT_CMap *acmap );


  extern void
  FT_CMap_Done( FT_CMap cmap );
# 273 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_Face_InternalRec_
  {

    FT_UShort reserved1;
    FT_Short reserved2;

    FT_Matrix transform_matrix;
    FT_Vector transform_delta;
    FT_Int transform_flags;

    FT_ServiceCacheRec services;





    FT_Bool ignore_unpatented_hinter;

  } FT_Face_InternalRec;
# 330 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_Slot_InternalRec_
  {
    FT_GlyphLoader loader;
    FT_UInt flags;
    FT_Bool glyph_transformed;
    FT_Matrix glyph_matrix;
    FT_Vector glyph_delta;
    void* glyph_hints;

  } FT_GlyphSlot_InternalRec;
# 393 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_ModuleRec_
  {
    FT_Module_Class* clazz;
    FT_Library library;
    FT_Memory memory;
    FT_Generic generic;

  } FT_ModuleRec;
# 453 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  extern const void*
  FT_Get_Module_Interface( FT_Library library,
                           const char* mod_name );

  extern FT_Pointer
  ft_module_get_service( FT_Module module,
                         const char* service_id );
# 514 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Error
  FT_New_GlyphSlot( FT_Face face,
                    FT_GlyphSlot *aslot );
# 532 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  extern void
  FT_Done_GlyphSlot( FT_GlyphSlot slot );
# 549 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  extern void
  FT_Select_Metrics( FT_Face face,
                     FT_ULong strike_index );



  extern void
  FT_Request_Metrics( FT_Face face,
                      FT_Size_Request req );



  extern FT_Error
  FT_Match_Size( FT_Face face,
                 FT_Size_Request req,
                 FT_Bool ignore_width,
                 FT_ULong* size_index );




  extern void
  ft_synthesize_vertical_metrics( FT_Glyph_Metrics* metrics,
                                  FT_Pos advance );




  extern void
  ft_glyphslot_free_bitmap( FT_GlyphSlot slot );



  extern FT_Error
  ft_glyphslot_alloc_bitmap( FT_GlyphSlot slot,
                             FT_ULong size );




  extern void
  ft_glyphslot_set_bitmap( FT_GlyphSlot slot,
                           FT_Byte* buffer );
# 613 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_RendererRec_
  {
    FT_ModuleRec root;
    FT_Renderer_Class* clazz;
    FT_Glyph_Format glyph_format;
    FT_Glyph_Class glyph_class;

    FT_Raster raster;
    FT_Raster_RenderFunc raster_render;
    FT_Renderer_RenderFunc render;

  } FT_RendererRec;
# 674 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_DriverRec_
  {
    FT_ModuleRec root;
    FT_Driver_Class clazz;

    FT_ListRec faces_list;
    void* extensions;

    FT_GlyphLoader glyph_loader;

  } FT_DriverRec;
# 712 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  typedef void (*FT_Bitmap_LcdFilterFunc)( FT_Bitmap* bitmap,
                                            FT_Render_Mode render_mode,
                                            FT_Library library );
# 767 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_LibraryRec_
  {
    FT_Memory memory;

    FT_Generic generic;

    FT_Int version_major;
    FT_Int version_minor;
    FT_Int version_patch;

    FT_UInt num_modules;
    FT_Module modules[32];

    FT_ListRec renderers;
    FT_Renderer cur_renderer;
    FT_Module auto_hinter;

    FT_Byte* raster_pool;

    FT_ULong raster_pool_size;

    FT_DebugHook_Func debug_hooks[4];
# 797 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  } FT_LibraryRec;


  extern FT_Renderer
  FT_Lookup_Renderer( FT_Library library,
                      FT_Glyph_Format format,
                      FT_ListNode* node );

  extern FT_Error
  FT_Render_Glyph_Internal( FT_Library library,
                            FT_GlyphSlot slot,
                            FT_Render_Mode render_mode );

  typedef const char* (*FT_Face_GetPostscriptNameFunc)( FT_Face face );

  typedef FT_Error
  (*FT_Face_GetGlyphNameFunc)( FT_Face face,
                               FT_UInt glyph_index,
                               FT_Pointer buffer,
                               FT_UInt buffer_max );

  typedef FT_UInt
  (*FT_Face_GetGlyphNameIndexFunc)( FT_Face face,
                                    FT_String* glyph_name );
# 836 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Memory
  FT_New_Memory( void );
# 851 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  extern void
  FT_Done_Memory( FT_Memory memory );
# 864 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftobjs.h"
  extern __attribute__((dllexport)) FT_Raster_Funcs ft_default_raster;




# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftstream.h" 2



# 57 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftstream.h"
  typedef enum FT_Frame_Op_
  {
    ft_frame_end = 0,
    ft_frame_start = ( ( 1 << 2 ) | ( 0 << 1 ) | 0 ),

    ft_frame_byte = ( ( 2 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_schar = ( ( 2 << 2 ) | ( 0 << 1 ) | 1 ),

    ft_frame_ushort_be = ( ( 3 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_short_be = ( ( 3 << 2 ) | ( 0 << 1 ) | 1 ),
    ft_frame_ushort_le = ( ( 3 << 2 ) | ( 1 << 1 ) | 0 ),
    ft_frame_short_le = ( ( 3 << 2 ) | ( 1 << 1 ) | 1 ),

    ft_frame_ulong_be = ( ( 4 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_long_be = ( ( 4 << 2 ) | ( 0 << 1 ) | 1 ),
    ft_frame_ulong_le = ( ( 4 << 2 ) | ( 1 << 1 ) | 0 ),
    ft_frame_long_le = ( ( 4 << 2 ) | ( 1 << 1 ) | 1 ),

    ft_frame_uoff3_be = ( ( 5 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_off3_be = ( ( 5 << 2 ) | ( 0 << 1 ) | 1 ),
    ft_frame_uoff3_le = ( ( 5 << 2 ) | ( 1 << 1 ) | 0 ),
    ft_frame_off3_le = ( ( 5 << 2 ) | ( 1 << 1 ) | 1 ),

    ft_frame_bytes = ( ( 6 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_skip = ( ( 6 << 2 ) | ( 0 << 1 ) | 1 )

  } FT_Frame_Op;


  typedef struct FT_Frame_Field_
  {
    FT_Byte value;
    FT_Byte size;
    FT_UShort offset;

  } FT_Frame_Field;
# 331 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftstream.h"
  extern FT_Error
  FT_Stream_Open( FT_Stream stream,
                  const char* filepathname );





  extern FT_Error
  FT_Stream_New( FT_Library library,
                 const FT_Open_Args* args,
                 FT_Stream *astream );


  extern void
  FT_Stream_Free( FT_Stream stream,
                  FT_Int external );


  extern void
  FT_Stream_OpenMemory( FT_Stream stream,
                        const FT_Byte* base,
                        FT_ULong size );


  extern void
  FT_Stream_Close( FT_Stream stream );



  extern FT_Error
  FT_Stream_Seek( FT_Stream stream,
                  FT_ULong pos );


  extern FT_Error
  FT_Stream_Skip( FT_Stream stream,
                  FT_Long distance );


  extern FT_Long
  FT_Stream_Pos( FT_Stream stream );



  extern FT_Error
  FT_Stream_Read( FT_Stream stream,
                  FT_Byte* buffer,
                  FT_ULong count );


  extern FT_Error
  FT_Stream_ReadAt( FT_Stream stream,
                    FT_ULong pos,
                    FT_Byte* buffer,
                    FT_ULong count );



  extern FT_ULong
  FT_Stream_TryRead( FT_Stream stream,
                     FT_Byte* buffer,
                     FT_ULong count );
# 403 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftstream.h"
  extern FT_Error
  FT_Stream_EnterFrame( FT_Stream stream,
                        FT_ULong count );


  extern void
  FT_Stream_ExitFrame( FT_Stream stream );
# 420 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftstream.h"
  extern FT_Error
  FT_Stream_ExtractFrame( FT_Stream stream,
                          FT_ULong count,
                          FT_Byte** pbytes );


  extern void
  FT_Stream_ReleaseFrame( FT_Stream stream,
                          FT_Byte** pbytes );


  extern FT_Char
  FT_Stream_GetChar( FT_Stream stream );


  extern FT_Short
  FT_Stream_GetShort( FT_Stream stream );


  extern FT_Long
  FT_Stream_GetOffset( FT_Stream stream );


  extern FT_Long
  FT_Stream_GetLong( FT_Stream stream );


  extern FT_Short
  FT_Stream_GetShortLE( FT_Stream stream );


  extern FT_Long
  FT_Stream_GetLongLE( FT_Stream stream );



  extern FT_Char
  FT_Stream_ReadChar( FT_Stream stream,
                      FT_Error* error );


  extern FT_Short
  FT_Stream_ReadShort( FT_Stream stream,
                       FT_Error* error );


  extern FT_Long
  FT_Stream_ReadOffset( FT_Stream stream,
                        FT_Error* error );


  extern FT_Long
  FT_Stream_ReadLong( FT_Stream stream,
                      FT_Error* error );


  extern FT_Short
  FT_Stream_ReadShortLE( FT_Stream stream,
                         FT_Error* error );


  extern FT_Long
  FT_Stream_ReadLongLE( FT_Stream stream,
                        FT_Error* error );



  extern FT_Error
  FT_Stream_ReadFields( FT_Stream stream,
                        const FT_Frame_Field* fields,
                        void* structure );
# 534 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftstream.h"

# 22 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h" 2
# 34 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"

# 63 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  typedef struct TT_Header_
  {
    FT_Fixed Table_Version;
    FT_Fixed Font_Revision;

    FT_Long CheckSum_Adjust;
    FT_Long Magic_Number;

    FT_UShort Flags;
    FT_UShort Units_Per_EM;

    FT_Long Created [2];
    FT_Long Modified[2];

    FT_Short xMin;
    FT_Short yMin;
    FT_Short xMax;
    FT_Short yMax;

    FT_UShort Mac_Style;
    FT_UShort Lowest_Rec_PPEM;

    FT_Short Font_Direction;
    FT_Short Index_To_Loc_Format;
    FT_Short Glyph_Data_Format;

  } TT_Header;
# 180 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  typedef struct TT_HoriHeader_
  {
    FT_Fixed Version;
    FT_Short Ascender;
    FT_Short Descender;
    FT_Short Line_Gap;

    FT_UShort advance_Width_Max;

    FT_Short min_Left_Side_Bearing;
    FT_Short min_Right_Side_Bearing;
    FT_Short xMax_Extent;
    FT_Short caret_Slope_Rise;
    FT_Short caret_Slope_Run;
    FT_Short caret_Offset;

    FT_Short Reserved[4];

    FT_Short metric_Data_Format;
    FT_UShort number_Of_HMetrics;





    void* long_metrics;
    void* short_metrics;

  } TT_HoriHeader;
# 306 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  typedef struct TT_VertHeader_
  {
    FT_Fixed Version;
    FT_Short Ascender;
    FT_Short Descender;
    FT_Short Line_Gap;

    FT_UShort advance_Height_Max;

    FT_Short min_Top_Side_Bearing;
    FT_Short min_Bottom_Side_Bearing;
    FT_Short yMax_Extent;
    FT_Short caret_Slope_Rise;
    FT_Short caret_Slope_Run;
    FT_Short caret_Offset;

    FT_Short Reserved[4];

    FT_Short metric_Data_Format;
    FT_UShort number_Of_VMetrics;





    void* long_metrics;
    void* short_metrics;

  } TT_VertHeader;
# 350 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  typedef struct TT_OS2_
  {
    FT_UShort version;
    FT_Short xAvgCharWidth;
    FT_UShort usWeightClass;
    FT_UShort usWidthClass;
    FT_Short fsType;
    FT_Short ySubscriptXSize;
    FT_Short ySubscriptYSize;
    FT_Short ySubscriptXOffset;
    FT_Short ySubscriptYOffset;
    FT_Short ySuperscriptXSize;
    FT_Short ySuperscriptYSize;
    FT_Short ySuperscriptXOffset;
    FT_Short ySuperscriptYOffset;
    FT_Short yStrikeoutSize;
    FT_Short yStrikeoutPosition;
    FT_Short sFamilyClass;

    FT_Byte panose[10];

    FT_ULong ulUnicodeRange1;
    FT_ULong ulUnicodeRange2;
    FT_ULong ulUnicodeRange3;
    FT_ULong ulUnicodeRange4;

    FT_Char achVendID[4];

    FT_UShort fsSelection;
    FT_UShort usFirstCharIndex;
    FT_UShort usLastCharIndex;
    FT_Short sTypoAscender;
    FT_Short sTypoDescender;
    FT_Short sTypoLineGap;
    FT_UShort usWinAscent;
    FT_UShort usWinDescent;



    FT_ULong ulCodePageRange1;
    FT_ULong ulCodePageRange2;



    FT_Short sxHeight;
    FT_Short sCapHeight;
    FT_UShort usDefaultChar;
    FT_UShort usBreakChar;
    FT_UShort usMaxContext;

  } TT_OS2;
# 414 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  typedef struct TT_Postscript_
  {
    FT_Fixed FormatType;
    FT_Fixed italicAngle;
    FT_Short underlinePosition;
    FT_Short underlineThickness;
    FT_ULong isFixedPitch;
    FT_ULong minMemType42;
    FT_ULong maxMemType42;
    FT_ULong minMemType1;
    FT_ULong maxMemType1;




  } TT_Postscript;
# 441 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  typedef struct TT_PCLT_
  {
    FT_Fixed Version;
    FT_ULong FontNumber;
    FT_UShort Pitch;
    FT_UShort xHeight;
    FT_UShort Style;
    FT_UShort TypeFamily;
    FT_UShort CapHeight;
    FT_UShort SymbolSet;
    FT_Char TypeFace[16];
    FT_Char CharacterComplement[8];
    FT_Char FileName[6];
    FT_Char StrokeWeight;
    FT_Char WidthType;
    FT_Byte SerifStyle;
    FT_Byte Reserved;

  } TT_PCLT;
# 528 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  typedef struct TT_MaxProfile_
  {
    FT_Fixed version;
    FT_UShort numGlyphs;
    FT_UShort maxPoints;
    FT_UShort maxContours;
    FT_UShort maxCompositePoints;
    FT_UShort maxCompositeContours;
    FT_UShort maxZones;
    FT_UShort maxTwilightPoints;
    FT_UShort maxStorage;
    FT_UShort maxFunctionDefs;
    FT_UShort maxInstructionDefs;
    FT_UShort maxStackElements;
    FT_UShort maxSizeOfInstructions;
    FT_UShort maxComponentElements;
    FT_UShort maxComponentDepth;

  } TT_MaxProfile;
# 558 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  typedef enum FT_Sfnt_Tag_
  {
    ft_sfnt_head = 0,
    ft_sfnt_maxp = 1,
    ft_sfnt_os2 = 2,
    ft_sfnt_hhea = 3,
    ft_sfnt_vhea = 4,
    ft_sfnt_post = 5,
    ft_sfnt_pclt = 6,

    sfnt_max

  } FT_Sfnt_Tag;
# 600 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  extern __attribute__((dllexport)) void*
  FT_Get_Sfnt_Table( FT_Face face,
                     FT_Sfnt_Tag tag );
# 663 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Load_Sfnt_Table( FT_Face face,
                      FT_ULong tag,
                      FT_Long offset,
                      FT_Byte* buffer,
                      FT_ULong* length );
# 701 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Sfnt_Table_Info( FT_Face face,
                      FT_UInt table_index,
                      FT_ULong *tag,
                      FT_ULong *length );
# 725 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  extern __attribute__((dllexport)) FT_ULong
  FT_Get_CMap_Language_ID( FT_CharMap charmap );
# 745 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttables.h"
  extern __attribute__((dllexport)) FT_Long
  FT_Get_CMap_Format( FT_CharMap charmap );





# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h" 2



# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h" 1
# 24 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h" 2
# 34 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"

# 69 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef struct PS_FontInfoRec_
  {
    FT_String* version;
    FT_String* notice;
    FT_String* full_name;
    FT_String* family_name;
    FT_String* weight;
    FT_Long italic_angle;
    FT_Bool is_fixed_pitch;
    FT_Short underline_position;
    FT_UShort underline_thickness;

  } PS_FontInfoRec;
# 92 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef struct PS_FontInfoRec_* PS_FontInfo;
# 105 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef PS_FontInfoRec T1_FontInfo;
# 118 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef struct PS_PrivateRec_
  {
    FT_Int unique_id;
    FT_Int lenIV;

    FT_Byte num_blue_values;
    FT_Byte num_other_blues;
    FT_Byte num_family_blues;
    FT_Byte num_family_other_blues;

    FT_Short blue_values[14];
    FT_Short other_blues[10];

    FT_Short family_blues [14];
    FT_Short family_other_blues[10];

    FT_Fixed blue_scale;
    FT_Int blue_shift;
    FT_Int blue_fuzz;

    FT_UShort standard_width[1];
    FT_UShort standard_height[1];

    FT_Byte num_snap_widths;
    FT_Byte num_snap_heights;
    FT_Bool force_bold;
    FT_Bool round_stem_up;

    FT_Short snap_widths [13];
    FT_Short snap_heights[13];

    FT_Fixed expansion_factor;

    FT_Long language_group;
    FT_Long password;

    FT_Short min_feature[2];

  } PS_PrivateRec;
# 167 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef struct PS_PrivateRec_* PS_Private;
# 180 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef PS_PrivateRec T1_Private;
# 193 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef enum T1_Blend_Flags_
  {

    T1_BLEND_UNDERLINE_POSITION = 0,
    T1_BLEND_UNDERLINE_THICKNESS,
    T1_BLEND_ITALIC_ANGLE,


    T1_BLEND_BLUE_VALUES,
    T1_BLEND_OTHER_BLUES,
    T1_BLEND_STANDARD_WIDTH,
    T1_BLEND_STANDARD_HEIGHT,
    T1_BLEND_STEM_SNAP_WIDTHS,
    T1_BLEND_STEM_SNAP_HEIGHTS,
    T1_BLEND_BLUE_SCALE,
    T1_BLEND_BLUE_SHIFT,
    T1_BLEND_FAMILY_BLUES,
    T1_BLEND_FAMILY_OTHER_BLUES,
    T1_BLEND_FORCE_BOLD,


    T1_BLEND_MAX

  } T1_Blend_Flags;
# 250 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef struct PS_DesignMap_
  {
    FT_Byte num_points;
    FT_Long* design_points;
    FT_Fixed* blend_points;

  } PS_DesignMapRec, *PS_DesignMap;


  typedef PS_DesignMapRec T1_DesignMap;


  typedef struct PS_BlendRec_
  {
    FT_UInt num_designs;
    FT_UInt num_axis;

    FT_String* axis_names[4];
    FT_Fixed* design_pos[16];
    PS_DesignMapRec design_map[4];

    FT_Fixed* weight_vector;
    FT_Fixed* default_weight_vector;

    PS_FontInfo font_infos[16 + 1];
    PS_Private privates [16 + 1];

    FT_ULong blend_bitflags;

    FT_BBox* bboxes [16 + 1];







    FT_UInt default_design_vector[16];
    FT_UInt num_default_design_vector;

  } PS_BlendRec, *PS_Blend;



  typedef PS_BlendRec T1_Blend;
# 305 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef struct CID_FaceDictRec_
  {
    PS_PrivateRec private_dict;

    FT_UInt len_buildchar;
    FT_Fixed forcebold_threshold;
    FT_Pos stroke_width;
    FT_Fixed expansion_factor;

    FT_Byte paint_type;
    FT_Byte font_type;
    FT_Matrix font_matrix;
    FT_Vector font_offset;

    FT_UInt num_subrs;
    FT_ULong subrmap_offset;
    FT_Int sd_bytes;

  } CID_FaceDictRec;
# 334 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef struct CID_FaceDictRec_* CID_FaceDict;





  typedef CID_FaceDictRec CID_FontDict;
# 351 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef struct CID_FaceInfoRec_
  {
    FT_String* cid_font_name;
    FT_Fixed cid_version;
    FT_Int cid_font_type;

    FT_String* registry;
    FT_String* ordering;
    FT_Int supplement;

    PS_FontInfoRec font_info;
    FT_BBox font_bbox;
    FT_ULong uid_base;

    FT_Int num_xuid;
    FT_ULong xuid[16];

    FT_ULong cidmap_offset;
    FT_Int fd_bytes;
    FT_Int gd_bytes;
    FT_ULong cid_count;

    FT_Int num_dicts;
    CID_FaceDict font_dicts;

    FT_ULong data_offset;

  } CID_FaceInfoRec;
# 389 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef struct CID_FaceInfoRec_* CID_FaceInfo;
# 402 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  typedef CID_FaceInfoRec CID_Info;
# 427 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  extern __attribute__((dllexport)) FT_Int
  FT_Has_PS_Glyph_Names( FT_Face face );
# 459 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Get_PS_Font_Info( FT_Face face,
                       PS_FontInfo afont_info );
# 492 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/t1tables.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Get_PS_Font_Private( FT_Face face,
                          PS_Private afont_private );





# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h" 2



# 73 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h"
  typedef struct FT_MM_Axis_
  {
    FT_String* name;
    FT_Long minimum;
    FT_Long maximum;

  } FT_MM_Axis;
# 103 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h"
  typedef struct FT_Multi_Master_
  {
    FT_UInt num_axis;
    FT_UInt num_designs;
    FT_MM_Axis axis[4];

  } FT_Multi_Master;
# 140 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h"
  typedef struct FT_Var_Axis_
  {
    FT_String* name;

    FT_Fixed minimum;
    FT_Fixed def;
    FT_Fixed maximum;

    FT_ULong tag;
    FT_UInt strid;

  } FT_Var_Axis;
# 170 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h"
  typedef struct FT_Var_Named_Style_
  {
    FT_Fixed* coords;
    FT_UInt strid;

  } FT_Var_Named_Style;
# 210 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h"
  typedef struct FT_MM_Var_
  {
    FT_UInt num_axis;
    FT_UInt num_designs;
    FT_UInt num_namedstyles;
    FT_Var_Axis* axis;
    FT_Var_Named_Style* namedstyle;

  } FT_MM_Var;
# 243 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Get_Multi_Master( FT_Face face,
                       FT_Multi_Master *amaster );
# 267 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Get_MM_Var( FT_Face face,
                 FT_MM_Var* *amaster );
# 295 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Set_MM_Design_Coordinates( FT_Face face,
                                FT_UInt num_coords,
                                FT_Long* coords );
# 322 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Set_Var_Design_Coordinates( FT_Face face,
                                 FT_UInt num_coords,
                                 FT_Fixed* coords );
# 350 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Set_MM_Blend_Coordinates( FT_Face face,
                               FT_UInt num_coords,
                               FT_Fixed* coords );
# 364 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftmm.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Set_Var_Blend_Coordinates( FT_Face face,
                                FT_UInt num_coords,
                                FT_Fixed* coords );






# 30 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h" 2




# 70 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TTC_HeaderRec_
  {
    FT_ULong tag;
    FT_Fixed version;
    FT_Long count;
    FT_ULong* offsets;

  } TTC_HeaderRec;
# 99 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct SFNT_HeaderRec_
  {
    FT_ULong format_tag;
    FT_UShort num_tables;
    FT_UShort search_range;
    FT_UShort entry_selector;
    FT_UShort range_shift;

    FT_ULong offset;

  } SFNT_HeaderRec, *SFNT_Header;
# 130 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_TableRec_
  {
    FT_ULong Tag;
    FT_ULong CheckSum;
    FT_ULong Offset;
    FT_ULong Length;

  } TT_TableRec, *TT_Table;
# 154 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_LongMetricsRec_
  {
    FT_UShort advance;
    FT_Short bearing;

  } TT_LongMetricsRec, *TT_LongMetrics;
# 171 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef FT_Short TT_ShortMetrics;
# 201 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_NameEntryRec_
  {
    FT_UShort platformID;
    FT_UShort encodingID;
    FT_UShort languageID;
    FT_UShort nameID;
    FT_UShort stringLength;
    FT_ULong stringOffset;




    FT_Byte* string;

  } TT_NameEntryRec, *TT_NameEntry;
# 238 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_NameTableRec_
  {
    FT_UShort format;
    FT_UInt numNameRecords;
    FT_UInt storageOffset;
    TT_NameEntryRec* names;
    FT_Stream stream;

  } TT_NameTableRec, *TT_NameTable;
# 277 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_GaspRangeRec_
  {
    FT_UShort maxPPEM;
    FT_UShort gaspFlag;

  } TT_GaspRangeRec, *TT_GaspRange;
# 305 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Gasp_
  {
    FT_UShort version;
    FT_UShort numRanges;
    TT_GaspRange gaspRanges;

  } TT_GaspRec;
# 332 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_HdmxEntryRec_
  {
    FT_Byte ppem;
    FT_Byte max_width;
    FT_Byte* widths;

  } TT_HdmxEntryRec, *TT_HdmxEntry;
# 357 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_HdmxRec_
  {
    FT_UShort version;
    FT_Short num_records;
    TT_HdmxEntry records;

  } TT_HdmxRec, *TT_Hdmx;
# 384 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Kern0_PairRec_
  {
    FT_UShort left;
    FT_UShort right;
    FT_FWord value;

  } TT_Kern0_PairRec, *TT_Kern0_Pair;
# 435 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_MetricsRec_
  {
    FT_Byte height;
    FT_Byte width;

    FT_Char horiBearingX;
    FT_Char horiBearingY;
    FT_Byte horiAdvance;

    FT_Char vertBearingX;
    FT_Char vertBearingY;
    FT_Byte vertAdvance;

  } TT_SBit_MetricsRec, *TT_SBit_Metrics;
# 472 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_Small_Metrics_
  {
    FT_Byte height;
    FT_Byte width;

    FT_Char bearingX;
    FT_Char bearingY;
    FT_Byte advance;

  } TT_SBit_SmallMetricsRec, *TT_SBit_SmallMetrics;
# 535 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_LineMetricsRec_
  {
    FT_Char ascender;
    FT_Char descender;
    FT_Byte max_width;
    FT_Char caret_slope_numerator;
    FT_Char caret_slope_denominator;
    FT_Char caret_offset;
    FT_Char min_origin_SB;
    FT_Char min_advance_SB;
    FT_Char max_before_BL;
    FT_Char min_after_BL;
    FT_Char pads[2];

  } TT_SBit_LineMetricsRec, *TT_SBit_LineMetrics;
# 589 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_RangeRec_
  {
    FT_UShort first_glyph;
    FT_UShort last_glyph;

    FT_UShort index_format;
    FT_UShort image_format;
    FT_ULong image_offset;

    FT_ULong image_size;
    TT_SBit_MetricsRec metrics;
    FT_ULong num_glyphs;

    FT_ULong* glyph_offsets;
    FT_UShort* glyph_codes;

    FT_ULong table_offset;

  } TT_SBit_RangeRec, *TT_SBit_Range;
# 653 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_StrikeRec_
  {
    FT_Int num_ranges;
    TT_SBit_Range sbit_ranges;
    FT_ULong ranges_offset;

    FT_ULong color_ref;

    TT_SBit_LineMetricsRec hori;
    TT_SBit_LineMetricsRec vert;

    FT_UShort start_glyph;
    FT_UShort end_glyph;

    FT_Byte x_ppem;
    FT_Byte y_ppem;

    FT_Byte bit_depth;
    FT_Char flags;

  } TT_SBit_StrikeRec, *TT_SBit_Strike;
# 691 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_ComponentRec_
  {
    FT_UShort glyph_code;
    FT_Char x_offset;
    FT_Char y_offset;

  } TT_SBit_ComponentRec, *TT_SBit_Component;
# 722 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_ScaleRec_
  {
    TT_SBit_LineMetricsRec hori;
    TT_SBit_LineMetricsRec vert;

    FT_Byte x_ppem;
    FT_Byte y_ppem;

    FT_Byte x_ppem_substitute;
    FT_Byte y_ppem_substitute;

  } TT_SBit_ScaleRec, *TT_SBit_Scale;
# 767 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Post_20Rec_
  {
    FT_UShort num_glyphs;
    FT_UShort num_names;
    FT_UShort* glyph_indices;
    FT_Char** glyph_names;

  } TT_Post_20Rec, *TT_Post_20;
# 792 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Post_25_
  {
    FT_UShort num_glyphs;
    FT_Char* offsets;

  } TT_Post_25Rec, *TT_Post_25;
# 815 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Post_NamesRec_
  {
    FT_Bool loaded;

    union
    {
      TT_Post_20Rec format_20;
      TT_Post_25Rec format_25;

    } names;

  } TT_Post_NamesRec, *TT_Post_Names;
# 843 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct GX_BlendRec_ *GX_Blend;
# 898 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_BDFRec_
  {
    FT_Byte* table;
    FT_Byte* table_end;
    FT_Byte* strings;
    FT_UInt32 strings_size;
    FT_UInt num_strikes;
    FT_Bool loaded;

  } TT_BDFRec, *TT_BDF;
# 949 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_FaceRec_* TT_Face;



  typedef FT_Error
  (*TT_Interpreter)( void* exec_context );


  typedef struct TT_LoaderRec_* TT_Loader;
# 985 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef FT_Error
  (*TT_Loader_GotoTableFunc)( TT_Face face,
                              FT_ULong tag,
                              FT_Stream stream,
                              FT_ULong* length );
# 1020 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef FT_Error
  (*TT_Loader_StartGlyphFunc)( TT_Loader loader,
                               FT_UInt glyph_index,
                               FT_ULong offset,
                               FT_UInt byte_count );
# 1042 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef FT_Error
  (*TT_Loader_ReadGlyphFunc)( TT_Loader loader );
# 1057 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef void (*TT_Loader_EndGlyphFunc)( TT_Loader loader );
# 1255 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_FaceRec_
  {
    FT_FaceRec root;

    TTC_HeaderRec ttc_header;

    FT_ULong format_tag;
    FT_UShort num_tables;
    TT_Table dir_tables;

    TT_Header header;
    TT_HoriHeader horizontal;

    TT_MaxProfile max_profile;

    FT_ULong max_components;


    FT_Bool vertical_info;
    TT_VertHeader vertical;

    FT_UShort num_names;
    TT_NameTableRec name_table;

    TT_OS2 os2;
    TT_Postscript postscript;

    FT_Byte* cmap_table;
    FT_ULong cmap_size;

    TT_Loader_GotoTableFunc goto_table;

    TT_Loader_StartGlyphFunc access_glyph_frame;
    TT_Loader_EndGlyphFunc forget_glyph_frame;
    TT_Loader_ReadGlyphFunc read_glyph_header;
    TT_Loader_ReadGlyphFunc read_simple_glyph;
    TT_Loader_ReadGlyphFunc read_composite_glyph;



    void* sfnt;



    void* psnames;
# 1310 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
    TT_HdmxRec hdmx;



    TT_GaspRec gasp;


    TT_PCLT pclt;



    FT_ULong num_sbit_strikes;
    TT_SBit_Strike sbit_strikes;


    FT_ULong num_sbit_scales;
    TT_SBit_Scale sbit_scales;


    TT_Post_NamesRec postscript_names;
# 1340 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
    FT_UShort num_locations_stub;
    FT_Long* glyph_locations_stub;



    FT_ULong font_program_size;
    FT_Byte* font_program;


    FT_ULong cvt_program_size;
    FT_Byte* cvt_program;


    FT_ULong cvt_size;
    FT_Short* cvt;



    FT_Int num_kern_pairs;
    FT_Int kern_table_index;
    TT_Kern0_Pair kern_pairs;




    TT_Interpreter interpreter;



    FT_Bool unpatented_hinting;
# 1379 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
    FT_Generic extra;

    const char* postscript_name;



    FT_ULong glyf_len;



    FT_Bool doblend;
    GX_Blend blend;




    FT_Byte* horz_metrics;
    FT_ULong horz_metrics_size;

    FT_Byte* vert_metrics;
    FT_ULong vert_metrics_size;

    FT_UInt num_locations;
    FT_Byte* glyph_locations;

    FT_Byte* hdmx_table;
    FT_ULong hdmx_table_size;
    FT_UInt hdmx_record_count;
    FT_ULong hdmx_record_size;
    FT_Byte* hdmx_record_sizes;

    FT_Byte* sbit_table;
    FT_ULong sbit_table_size;
    FT_UInt sbit_num_strikes;

    FT_Byte* kern_table;
    FT_ULong kern_table_size;
    FT_UInt num_kern_tables;
    FT_UInt32 kern_avail_bits;
    FT_UInt32 kern_order_bits;


    TT_BDFRec bdf;



    FT_ULong horz_metrics_offset;
    FT_ULong vert_metrics_offset;

  } TT_FaceRec;
# 1462 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_GlyphZoneRec_
  {
    FT_Memory memory;
    FT_UShort max_points;
    FT_UShort max_contours;
    FT_UShort n_points;
    FT_Short n_contours;

    FT_Vector* org;
    FT_Vector* cur;
    FT_Vector* orus;

    FT_Byte* tags;
    FT_UShort* contours;

    FT_UShort first_point;

  } TT_GlyphZoneRec, *TT_GlyphZone;



  typedef struct TT_ExecContextRec_* TT_ExecContext;


  typedef struct TT_LoaderRec_
  {
    FT_Face face;
    FT_Size size;
    FT_GlyphSlot glyph;
    FT_GlyphLoader gloader;

    FT_ULong load_flags;
    FT_UInt glyph_index;

    FT_Stream stream;
    FT_Int byte_len;

    FT_Short n_contours;
    FT_BBox bbox;
    FT_Int left_bearing;
    FT_Int advance;
    FT_Int linear;
    FT_Bool linear_def;
    FT_Bool preserve_pps;
    FT_Vector pp1;
    FT_Vector pp2;

    FT_ULong glyf_offset;


    TT_GlyphZoneRec base;
    TT_GlyphZoneRec zone;

    TT_ExecContext exec;
    FT_Byte* instructions;
    FT_ULong ins_pos;


    void* other;


    FT_Int top_bearing;
    FT_Int vadvance;
    FT_Vector pp3;
    FT_Vector pp4;


    FT_Byte* cursor;
    FT_Byte* limit;

  } TT_LoaderRec;



# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h" 2



# 66 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Init_Face_Func)( FT_Stream stream,
                        TT_Face face,
                        FT_Int face_index,
                        FT_Int num_params,
                        FT_Parameter* params );
# 102 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Face_Func)( FT_Stream stream,
                        TT_Face face,
                        FT_Int face_index,
                        FT_Int num_params,
                        FT_Parameter* params );
# 124 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef void (*TT_Done_Face_Func)( TT_Face face );
# 160 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_SFNT_HeaderRec_Func)( TT_Face face,
                                  FT_Stream stream,
                                  FT_Long face_index,
                                  SFNT_Header sfnt );
# 190 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Directory_Func)( TT_Face face,
                             FT_Stream stream,
                             SFNT_Header sfnt );
# 238 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Any_Func)( TT_Face face,
                       FT_ULong tag,
                       FT_Long offset,
                       FT_Byte *buffer,
                       FT_ULong* length );
# 274 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Find_SBit_Image_Func)( TT_Face face,
                              FT_UInt glyph_index,
                              FT_ULong strike_index,
                              TT_SBit_Range *arange,
                              TT_SBit_Strike *astrike,
                              FT_ULong *aglyph_offset );
# 310 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_SBit_Metrics_Func)( FT_Stream stream,
                                TT_SBit_Range range,
                                TT_SBit_Metrics metrics );
# 355 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_SBit_Image_Func)( TT_Face face,
                              FT_ULong strike_index,
                              FT_UInt glyph_index,
                              FT_UInt load_flags,
                              FT_Stream stream,
                              FT_Bitmap *amap,
                              TT_SBit_MetricsRec *ametrics );
# 387 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Set_SBit_Strike_OldFunc)( TT_Face face,
                                 FT_UInt x_ppem,
                                 FT_UInt y_ppem,
                                 FT_ULong* astrike_index );
# 418 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_CharMap_Load_Func)( TT_Face face,
                           void* cmap,
                           FT_Stream input );
# 440 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_CharMap_Free_Func)( TT_Face face,
                           void* cmap );
# 467 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Set_SBit_Strike_Func)( TT_Face face,
                              FT_Size_Request req,
                              FT_ULong* astrike_index );
# 493 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Strike_Metrics_Func)( TT_Face face,
                                  FT_ULong strike_index,
                                  FT_Size_Metrics* metrics );
# 518 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Get_PS_Name_Func)( TT_Face face,
                          FT_UInt idx,
                          FT_String** PSname );
# 543 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Metrics_Func)( TT_Face face,
                           FT_Stream stream,
                           FT_Bool vertical );
# 567 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Get_Metrics_Func)( TT_Face face,
                          FT_Bool vertical,
                          FT_UInt gindex,
                          FT_Short* abearing,
                          FT_UShort* aadvance );
# 595 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Table_Func)( TT_Face face,
                         FT_Stream stream );
# 611 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef void (*TT_Free_Table_Func)( TT_Face face );
# 629 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Int
  (*TT_Face_GetKerningFunc)( TT_Face face,
                             FT_UInt left_glyph,
                             FT_UInt right_glyph );
# 647 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
  typedef struct SFNT_Interface_
  {
    TT_Loader_GotoTableFunc goto_table;

    TT_Init_Face_Func init_face;
    TT_Load_Face_Func load_face;
    TT_Done_Face_Func done_face;
    FT_Module_Requester get_interface;

    TT_Load_Any_Func load_any;


    TT_Load_SFNT_HeaderRec_Func load_sfnt_header;
    TT_Load_Directory_Func load_directory;




    TT_Load_Table_Func load_head;
    TT_Load_Metrics_Func load_hhea;
    TT_Load_Table_Func load_cmap;
    TT_Load_Table_Func load_maxp;
    TT_Load_Table_Func load_os2;
    TT_Load_Table_Func load_post;

    TT_Load_Table_Func load_name;
    TT_Free_Table_Func free_name;



    TT_Load_Table_Func load_hdmx_stub;
    TT_Free_Table_Func free_hdmx_stub;



    TT_Load_Table_Func load_kern;

    TT_Load_Table_Func load_gasp;
    TT_Load_Table_Func load_pclt;



    TT_Load_Table_Func load_bhed;




    TT_Set_SBit_Strike_OldFunc set_sbit_strike_stub;
    TT_Load_Table_Func load_sbits_stub;
# 708 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/sfnt.h"
    TT_Find_SBit_Image_Func find_sbit_image;
    TT_Load_SBit_Metrics_Func load_sbit_metrics;



    TT_Load_SBit_Image_Func load_sbit_image;


    TT_Free_Table_Func free_sbits_stub;



    TT_Get_PS_Name_Func get_psname;
    TT_Free_Table_Func free_psnames;


    TT_CharMap_Load_Func load_charmap_stub;
    TT_CharMap_Free_Func free_charmap_stub;





    TT_Face_GetKerningFunc get_kerning;





    TT_Load_Table_Func load_font_dir;
    TT_Load_Metrics_Func load_hmtx;

    TT_Load_Table_Func load_eblc;
    TT_Free_Table_Func free_eblc;

    TT_Set_SBit_Strike_Func set_sbit_strike;
    TT_Load_Strike_Metrics_Func load_strike_metrics;

    TT_Get_Metrics_Func get_metrics;

  } SFNT_Interface;



  typedef SFNT_Interface* SFNT_Service;



# 23 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ttnameid.h" 1
# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ttnameid.h"

# 1141 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ttnameid.h"

# 24 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/services/svxf86nm.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/services/svxf86nm.h"

# 49 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/services/svxf86nm.h"

# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2



# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/services/svmm.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/services/svmm.h"

# 38 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/services/svmm.h"
  typedef FT_Error
  (*FT_Get_MM_Func)( FT_Face face,
                     FT_Multi_Master* master );

  typedef FT_Error
  (*FT_Get_MM_Var_Func)( FT_Face face,
                         FT_MM_Var* *master );

  typedef FT_Error
  (*FT_Set_MM_Design_Func)( FT_Face face,
                            FT_UInt num_coords,
                            FT_Long* coords );

  typedef FT_Error
  (*FT_Set_Var_Design_Func)( FT_Face face,
                             FT_UInt num_coords,
                             FT_Fixed* coords );

  typedef FT_Error
  (*FT_Set_MM_Blend_Func)( FT_Face face,
                           FT_UInt num_coords,
                           FT_Long* coords );


  typedef struct FT_Service_MultiMastersRec_ FT_Service_MultiMastersRec ; typedef struct FT_Service_MultiMastersRec_ const * FT_Service_MultiMasters ; struct FT_Service_MultiMastersRec_
  {
    FT_Get_MM_Func get_mm;
    FT_Set_MM_Design_Func set_mm_design;
    FT_Set_MM_Blend_Func set_mm_blend;
    FT_Get_MM_Var_Func get_mm_var;
    FT_Set_Var_Design_Func set_var_design;
  };





# 29 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2


# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/services/svtteng.h" 1
# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/services/svtteng.h"

# 39 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/services/svtteng.h"
  typedef struct FT_Service_TrueTypeEngineRec_ FT_Service_TrueTypeEngineRec ; typedef struct FT_Service_TrueTypeEngineRec_ const * FT_Service_TrueTypeEngine ; struct FT_Service_TrueTypeEngineRec_
  {
    FT_TrueTypeEngineType engine_type;
  };





# 32 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/services/svttglyf.h" 1
# 24 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/services/svttglyf.h"






  typedef FT_ULong
  (*TT_Glyf_GetLocationFunc)( FT_Face face,
                              FT_UInt gindex,
                              FT_ULong *psize );

  typedef struct FT_Service_TTGlyfRec_ FT_Service_TTGlyfRec ; typedef struct FT_Service_TTGlyfRec_ const * FT_Service_TTGlyf ; struct FT_Service_TTGlyfRec_
  {
    TT_Glyf_GetLocationFunc get_location;
  };





# 33 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2

# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.h" 1
# 27 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.h"



  extern __attribute__((dllexport)) const FT_Driver_ClassRec tt_driver_class;



# 35 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.h" 1
# 24 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.h" 1
# 28 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.h"

# 39 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.h"
  typedef struct TT_DriverRec_* TT_Driver;
# 50 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.h"
  typedef struct TT_SizeRec_* TT_Size;
# 65 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.h"
  typedef FT_GlyphSlot TT_GlyphSlot;
# 76 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.h"
  typedef struct TT_GraphicsState_
  {
    FT_UShort rp0;
    FT_UShort rp1;
    FT_UShort rp2;

    FT_UnitVector dualVector;
    FT_UnitVector projVector;
    FT_UnitVector freeVector;


    FT_Bool both_x_axis;


    FT_Long loop;
    FT_F26Dot6 minimum_distance;
    FT_Int round_state;

    FT_Bool auto_flip;
    FT_F26Dot6 control_value_cutin;
    FT_F26Dot6 single_width_cutin;
    FT_F26Dot6 single_width_value;
    FT_Short delta_base;
    FT_Short delta_shift;

    FT_Byte instruct_control;
    FT_Bool scan_control;
    FT_Int scan_type;

    FT_UShort gep0;
    FT_UShort gep1;
    FT_UShort gep2;

  } TT_GraphicsState;




  static void
  tt_glyphzone_done( TT_GlyphZone zone );

  static FT_Error
  tt_glyphzone_new( FT_Memory memory,
                    FT_UShort maxPoints,
                    FT_Short maxContours,
                    TT_GlyphZone zone );
# 146 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.h"
  typedef enum TT_CodeRange_Tag_
  {
    tt_coderange_none = 0,
    tt_coderange_font,
    tt_coderange_cvt,
    tt_coderange_glyph

  } TT_CodeRange_Tag;


  typedef struct TT_CodeRange_
  {
    FT_Byte* base;
    FT_ULong size;

  } TT_CodeRange;

  typedef TT_CodeRange TT_CodeRangeTable[3];






  typedef struct TT_DefRecord_
  {
    FT_Int range;
    FT_Long start;
    FT_UInt opc;
    FT_Bool active;

  } TT_DefRecord, *TT_DefArray;






  typedef struct TT_Transform_
  {
    FT_Fixed xx, xy;
    FT_Fixed yx, yy;
    FT_F26Dot6 ox, oy;

  } TT_Transform;






  typedef struct TT_SubglyphRec_
  {
    FT_Long index;
    FT_Bool is_scaled;
    FT_Bool is_hinted;
    FT_Bool preserve_pps;

    FT_Long file_offset;

    FT_BBox bbox;
    FT_Pos left_bearing;
    FT_Pos advance;

    TT_GlyphZoneRec zone;

    FT_Long arg1;
    FT_Long arg2;

    FT_UShort element_flag;

    TT_Transform transform;

    FT_Vector pp1, pp2;
    FT_Vector pp3, pp4;

  } TT_SubGlyphRec, *TT_SubGlyph_Stack;
# 291 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.h"
  typedef struct TT_Size_Metrics_
  {

    FT_Long x_ratio;
    FT_Long y_ratio;

    FT_UShort ppem;
    FT_Long ratio;
    FT_Fixed scale;

    FT_F26Dot6 compensations[4];

    FT_Bool valid;

    FT_Bool rotated;
    FT_Bool stretched;

  } TT_Size_Metrics;






  typedef struct TT_SizeRec_
  {
    FT_SizeRec root;



    FT_Size_Metrics metrics;

    TT_Size_Metrics ttmetrics;

    FT_ULong strike_index;



    FT_UInt num_function_defs;
    FT_UInt max_function_defs;
    TT_DefArray function_defs;

    FT_UInt num_instruction_defs;
    FT_UInt max_instruction_defs;
    TT_DefArray instruction_defs;

    FT_UInt max_func;
    FT_UInt max_ins;

    TT_CodeRangeTable codeRangeTable;

    TT_GraphicsState GS;

    FT_ULong cvt_size;
    FT_Long* cvt;

    FT_UShort storage_size;
    FT_Long* storage;

    TT_GlyphZoneRec twilight;







    FT_Bool debug;
    TT_ExecContext context;

    FT_Bool bytecode_ready;
    FT_Bool cvt_ready;



  } TT_SizeRec;






  typedef struct TT_DriverRec_
  {
    FT_DriverRec root;
    TT_ExecContext context;
    TT_GlyphZoneRec zone;

    void* extension_component;

  } TT_DriverRec;
# 397 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.h"
  static FT_Error
  tt_face_init( FT_Stream stream,
                FT_Face ttface,
                FT_Int face_index,
                FT_Int num_params,
                FT_Parameter* params );

  static void
  tt_face_done( FT_Face ttface );






  static FT_Error
  tt_size_init( FT_Size ttsize );

  static void
  tt_size_done( FT_Size ttsize );



  static FT_Error
  tt_size_run_fpgm( TT_Size size );

  static FT_Error
  tt_size_run_prep( TT_Size size );

  static FT_Error
  tt_size_ready_bytecode( TT_Size size );



  static FT_Error
  tt_size_reset( TT_Size size );






  static FT_Error
  tt_driver_init( FT_Module ttdriver );

  static void
  tt_driver_done( FT_Module ttdriver );






  static FT_Error
  tt_slot_init( FT_GlyphSlot slot );



# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.h" 2


# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.h" 1
# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.h"

# 69 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.h"
  typedef FT_F26Dot6
  (*TT_Round_Func)( TT_ExecContext exc, FT_F26Dot6 distance,
                             FT_F26Dot6 compensation );


  typedef void (*TT_Move_Func)( TT_ExecContext exc, TT_GlyphZone zone,
                            FT_UShort point,
                            FT_F26Dot6 distance );


  typedef FT_F26Dot6
  (*TT_Project_Func)( TT_ExecContext exc, FT_Pos dx,
                               FT_Pos dy );


  typedef FT_F26Dot6
  (*TT_Get_CVT_Func)( TT_ExecContext exc, FT_ULong idx );



  typedef void (*TT_Set_CVT_Func)( TT_ExecContext exc, FT_ULong idx,
                               FT_F26Dot6 value );






  typedef struct TT_CallRec_
  {
    FT_Int Caller_Range;
    FT_Long Caller_IP;
    FT_Long Cur_Count;
    FT_Long Cur_Restart;

  } TT_CallRec, *TT_CallStack;







  typedef struct TT_ExecContextRec_
  {
    TT_Face face;
    TT_Size size;
    FT_Memory memory;



    FT_Error error;

    FT_Long top;

    FT_UInt stackSize;
    FT_Long* stack;

    FT_Long args;
    FT_UInt new_top;

    TT_GlyphZoneRec zp0,
                       zp1,
                       zp2,
                       pts,
                       twilight;

    FT_Size_Metrics metrics;
    TT_Size_Metrics tt_metrics;

    TT_GraphicsState GS;

    FT_Int curRange;
    FT_Byte* code;
    FT_Long IP;
    FT_Long codeSize;

    FT_Byte opcode;
    FT_Int length;

    FT_Bool step_ins;

    FT_Long cvtSize;
    FT_Long* cvt;

    FT_UInt glyphSize;
    FT_Byte* glyphIns;

    FT_UInt numFDefs;
    FT_UInt maxFDefs;
    TT_DefArray FDefs;

    FT_UInt numIDefs;
    FT_UInt maxIDefs;
    TT_DefArray IDefs;

    FT_UInt maxFunc;
    FT_UInt maxIns;

    FT_Int callTop,
                       callSize;
    TT_CallStack callStack;

    FT_UShort maxPoints;
    FT_Short maxContours;


    TT_CodeRangeTable codeRangeTable;


    FT_UShort storeSize;
    FT_Long* storage;

    FT_F26Dot6 period;
    FT_F26Dot6 phase;
    FT_F26Dot6 threshold;






    FT_Bool instruction_trap;


    TT_GraphicsState default_GS;

    FT_Bool is_composite;
    FT_Bool pedantic_hinting;



    FT_Long F_dot_P;

    TT_Round_Func func_round;

    TT_Project_Func func_project,
                       func_dualproj,
                       func_freeProj;

    TT_Move_Func func_move;
    TT_Move_Func func_move_orig;

    TT_Get_CVT_Func func_read_cvt;
    TT_Set_CVT_Func func_write_cvt;
    TT_Set_CVT_Func func_move_cvt;

    FT_Bool grayscale;

  } TT_ExecContextRec;


  extern const TT_GraphicsState tt_default_graphics_state;


  static FT_Error
  TT_Goto_CodeRange( TT_ExecContext exec,
                     FT_Int range,
                     FT_Long IP );

  static FT_Error
  TT_Set_CodeRange( TT_ExecContext exec,
                    FT_Int range,
                    void* base,
                    FT_Long length );

  static FT_Error
  TT_Clear_CodeRange( TT_ExecContext exec,
                      FT_Int range );
# 259 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.h"
  extern __attribute__((dllexport)) TT_ExecContext
  TT_New_Context( TT_Driver driver );

  static FT_Error
  TT_Done_Context( TT_ExecContext exec );

  static FT_Error
  TT_Load_Context( TT_ExecContext exec,
                   TT_Face face,
                   TT_Size size );

  static FT_Error
  TT_Save_Context( TT_ExecContext exec,
                   TT_Size ins );

  static FT_Error
  TT_Run_Context( TT_ExecContext exec,
                  FT_Bool debug );
# 300 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.h"
  extern __attribute__((dllexport)) FT_Error
  TT_RunIns( TT_ExecContext exec );



# 28 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.h" 2






  static void
  TT_Init_Glyph_Loading( TT_Face face );

  static FT_Error
  TT_Load_Glyph( TT_Size size,
                 TT_GlyphSlot glyph,
                 FT_UInt glyph_index,
                 FT_Int32 load_flags );



# 36 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.h" 1
# 27 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.h"



  static FT_Error
  tt_face_load_loca( TT_Face face,
                     FT_Stream stream );

  static FT_ULong
  tt_face_get_location( TT_Face face,
                        FT_UInt gindex,
                        FT_UInt *asize );

  static void
  tt_face_done_loca( TT_Face face );

  static FT_Error
  tt_face_load_cvt( TT_Face face,
                    FT_Stream stream );

  static FT_Error
  tt_face_load_fpgm( TT_Face face,
                     FT_Stream stream );


  static FT_Error
  tt_face_load_prep( TT_Face face,
                     FT_Stream stream );


  static FT_Error
  tt_face_load_hdmx( TT_Face face,
                     FT_Stream stream );


  static void
  tt_face_free_hdmx( TT_Face face );


  static FT_Byte*
  tt_face_get_device_metrics( TT_Face face,
                              FT_UInt ppem,
                              FT_UInt gindex );


# 37 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2


# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.h" 1
# 27 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.h"

# 39 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.h"
  typedef struct GX_AVarCorrespondenceRec_
  {
    FT_Fixed fromCoord;
    FT_Fixed toCoord;

  } GX_AVarCorrespondenceRec_, *GX_AVarCorrespondence;
# 56 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.h"
  typedef struct GX_AVarSegmentRec_
  {
    FT_UShort pairCount;
    GX_AVarCorrespondence correspondence;

  } GX_AVarSegmentRec, *GX_AVarSegment;
# 81 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.h"
  typedef struct GX_BlendRec_
  {
    FT_UInt num_axis;
    FT_Fixed* normalizedcoords;

    FT_MM_Var* mmvar;
    FT_Int mmvar_len;

    FT_Bool avar_checked;
    GX_AVarSegment avar_segment;

    FT_UInt tuplecount;
    FT_Fixed* tuplecoords;

    FT_UInt gv_glyphcnt;
    FT_ULong* glyphoffsets;

  } GX_BlendRec;
# 109 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.h"
  typedef enum GX_TupleCountFlags_
  {
    GX_TC_TUPLES_SHARE_POINT_NUMBERS = 0x8000,
    GX_TC_RESERVED_TUPLE_FLAGS = 0x7000,
    GX_TC_TUPLE_COUNT_MASK = 0x0FFF

  } GX_TupleCountFlags;
# 127 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.h"
  typedef enum GX_TupleIndexFlags_
  {
    GX_TI_EMBEDDED_TUPLE_COORD = 0x8000,
    GX_TI_INTERMEDIATE_TUPLE = 0x4000,
    GX_TI_PRIVATE_POINT_NUMBERS = 0x2000,
    GX_TI_RESERVED_TUPLE_FLAG = 0x1000,
    GX_TI_TUPLE_INDEX_MASK = 0x0FFF

  } GX_TupleIndexFlags;
# 144 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.h"
  static FT_Error
  TT_Set_MM_Blend( TT_Face face,
                   FT_UInt num_coords,
                   FT_Fixed* coords );

  static FT_Error
  TT_Set_Var_Design( TT_Face face,
                     FT_UInt num_coords,
                     FT_Fixed* coords );

  static FT_Error
  TT_Get_MM_Var( TT_Face face,
                 FT_MM_Var* *master );


  static FT_Error
  tt_face_vary_cvt( TT_Face face,
                    FT_Stream stream );


  static FT_Error
  TT_Vary_Get_Glyph_Deltas( TT_Face face,
                            FT_UInt glyph_index,
                            FT_Vector* *deltas,
                            FT_UInt n_points );


  static void
  tt_done_blend( FT_Memory memory,
                 GX_Blend blend );



# 40 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2


# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/tterrors.h" 1
# 36 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/tterrors.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fterrors.h" 1
# 162 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fterrors.h"
  enum {




# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fterrdef.h" 1
# 34 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fterrdef.h"
  TT_Err_Ok = 0x00,


  TT_Err_Cannot_Open_Resource = 0x01 + 0,

  TT_Err_Unknown_File_Format = 0x02 + 0,

  TT_Err_Invalid_File_Format = 0x03 + 0,

  TT_Err_Invalid_Version = 0x04 + 0,

  TT_Err_Lower_Module_Version = 0x05 + 0,

  TT_Err_Invalid_Argument = 0x06 + 0,

  TT_Err_Unimplemented_Feature = 0x07 + 0,

  TT_Err_Invalid_Table = 0x08 + 0,

  TT_Err_Invalid_Offset = 0x09 + 0,

  TT_Err_Array_Too_Large = 0x0A + 0,




  TT_Err_Invalid_Glyph_Index = 0x10 + 0,

  TT_Err_Invalid_Character_Code = 0x11 + 0,

  TT_Err_Invalid_Glyph_Format = 0x12 + 0,

  TT_Err_Cannot_Render_Glyph = 0x13 + 0,

  TT_Err_Invalid_Outline = 0x14 + 0,

  TT_Err_Invalid_Composite = 0x15 + 0,

  TT_Err_Too_Many_Hints = 0x16 + 0,

  TT_Err_Invalid_Pixel_Size = 0x17 + 0,




  TT_Err_Invalid_Handle = 0x20 + 0,

  TT_Err_Invalid_Library_Handle = 0x21 + 0,

  TT_Err_Invalid_Driver_Handle = 0x22 + 0,

  TT_Err_Invalid_Face_Handle = 0x23 + 0,

  TT_Err_Invalid_Size_Handle = 0x24 + 0,

  TT_Err_Invalid_Slot_Handle = 0x25 + 0,

  TT_Err_Invalid_CharMap_Handle = 0x26 + 0,

  TT_Err_Invalid_Cache_Handle = 0x27 + 0,

  TT_Err_Invalid_Stream_Handle = 0x28 + 0,




  TT_Err_Too_Many_Drivers = 0x30 + 0,

  TT_Err_Too_Many_Extensions = 0x31 + 0,




  TT_Err_Out_Of_Memory = 0x40 + 0,

  TT_Err_Unlisted_Object = 0x41 + 0,




  TT_Err_Cannot_Open_Stream = 0x51 + 0,

  TT_Err_Invalid_Stream_Seek = 0x52 + 0,

  TT_Err_Invalid_Stream_Skip = 0x53 + 0,

  TT_Err_Invalid_Stream_Read = 0x54 + 0,

  TT_Err_Invalid_Stream_Operation = 0x55 + 0,

  TT_Err_Invalid_Frame_Operation = 0x56 + 0,

  TT_Err_Nested_Frame_Access = 0x57 + 0,

  TT_Err_Invalid_Frame_Read = 0x58 + 0,




  TT_Err_Raster_Uninitialized = 0x60 + 0,

  TT_Err_Raster_Corrupted = 0x61 + 0,

  TT_Err_Raster_Overflow = 0x62 + 0,

  TT_Err_Raster_Negative_Height = 0x63 + 0,




  TT_Err_Too_Many_Caches = 0x70 + 0,




  TT_Err_Invalid_Opcode = 0x80 + 0,

  TT_Err_Too_Few_Arguments = 0x81 + 0,

  TT_Err_Stack_Overflow = 0x82 + 0,

  TT_Err_Code_Overflow = 0x83 + 0,

  TT_Err_Bad_Argument = 0x84 + 0,

  TT_Err_Divide_By_Zero = 0x85 + 0,

  TT_Err_Invalid_Reference = 0x86 + 0,

  TT_Err_Debug_OpCode = 0x87 + 0,

  TT_Err_ENDF_In_Exec_Stream = 0x88 + 0,

  TT_Err_Nested_DEFS = 0x89 + 0,

  TT_Err_Invalid_CodeRange = 0x8A + 0,

  TT_Err_Execution_Too_Long = 0x8B + 0,

  TT_Err_Too_Many_Function_Defs = 0x8C + 0,

  TT_Err_Too_Many_Instruction_Defs = 0x8D + 0,

  TT_Err_Table_Missing = 0x8E + 0,

  TT_Err_Horiz_Header_Missing = 0x8F + 0,

  TT_Err_Locations_Missing = 0x90 + 0,

  TT_Err_Name_Table_Missing = 0x91 + 0,

  TT_Err_CMap_Table_Missing = 0x92 + 0,

  TT_Err_Hmtx_Table_Missing = 0x93 + 0,

  TT_Err_Post_Table_Missing = 0x94 + 0,

  TT_Err_Invalid_Horiz_Metrics = 0x95 + 0,

  TT_Err_Invalid_CharMap_Format = 0x96 + 0,

  TT_Err_Invalid_PPem = 0x97 + 0,

  TT_Err_Invalid_Vert_Metrics = 0x98 + 0,

  TT_Err_Could_Not_Find_Context = 0x99 + 0,

  TT_Err_Invalid_Post_Table_Format = 0x9A + 0,

  TT_Err_Invalid_Post_Table = 0x9B + 0,




  TT_Err_Syntax_Error = 0xA0 + 0,

  TT_Err_Stack_Underflow = 0xA1 + 0,

  TT_Err_Ignore = 0xA2 + 0,




  TT_Err_Missing_Startfont_Field = 0xB0 + 0,

  TT_Err_Missing_Font_Field = 0xB1 + 0,

  TT_Err_Missing_Size_Field = 0xB2 + 0,

  TT_Err_Missing_Chars_Field = 0xB3 + 0,

  TT_Err_Missing_Startchar_Field = 0xB4 + 0,

  TT_Err_Missing_Encoding_Field = 0xB5 + 0,

  TT_Err_Missing_Bbx_Field = 0xB6 + 0,

  TT_Err_Bbx_Too_Big = 0xB7 + 0,

  TT_Err_Corrupted_Font_Header = 0xB8 + 0,

  TT_Err_Corrupted_Font_Glyphs = 0xB9 + 0,
# 168 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fterrors.h" 2



  TT_Err_Max };
# 37 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/tterrors.h" 2
# 43 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c" 2
# 105 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c"
  static FT_Error
  tt_get_kerning( FT_Face ttface,
                  FT_UInt left_glyph,
                  FT_UInt right_glyph,
                  FT_Vector* kerning )
  {
    TT_Face face = (TT_Face)ttface;
    SFNT_Service sfnt = (SFNT_Service)face->sfnt;


    kerning->x = 0;
    kerning->y = 0;

    if ( sfnt )
      kerning->x = sfnt->get_kerning( face, left_glyph, right_glyph );

    return 0;
  }
# 143 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c"
  static FT_Error
  tt_size_select( FT_Size size,
                  FT_ULong strike_index )
  {
    TT_Face ttface = (TT_Face)size->face;
    TT_Size ttsize = (TT_Size)size;
    FT_Error error = TT_Err_Ok;


    ttsize->strike_index = strike_index;

    if ( ( size->face->face_flags & ( 1L << 0 ) ) )
    {

      FT_Select_Metrics( size->face, strike_index );

      tt_size_reset( ttsize );
    }
    else
    {
      SFNT_Service sfnt = (SFNT_Service) ttface->sfnt;
      FT_Size_Metrics* metrics = &size->metrics;


      error = sfnt->load_strike_metrics( ttface, strike_index, metrics );
      if ( error )
        ttsize->strike_index = 0xFFFFFFFFUL;
    }

    return error;
  }




  static FT_Error
  tt_size_request( FT_Size size,
                   FT_Size_Request req )
  {
    TT_Size ttsize = (TT_Size)size;
    FT_Error error = TT_Err_Ok;




    if ( ( size->face->face_flags & ( 1L << 1 ) ) )
    {
      TT_Face ttface = (TT_Face)size->face;
      SFNT_Service sfnt = (SFNT_Service) ttface->sfnt;
      FT_ULong strike_index;


      error = sfnt->set_sbit_strike( ttface, req, &strike_index );

      if ( error )
        ttsize->strike_index = 0xFFFFFFFFUL;
      else
        return tt_size_select( size, strike_index );
    }



    FT_Request_Metrics( size->face, req );

    if ( ( size->face->face_flags & ( 1L << 0 ) ) )
      error = tt_size_reset( ttsize );

    return error;
  }
# 240 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c"
  static FT_Error
  Load_Glyph( FT_GlyphSlot ttslot,
              FT_Size ttsize,
              FT_UInt glyph_index,
              FT_Int32 load_flags )
  {
    TT_GlyphSlot slot = (TT_GlyphSlot)ttslot;
    TT_Size size = (TT_Size)ttsize;
    FT_Face face = ttslot->face;
    FT_Error error;


    if ( !slot )
      return TT_Err_Invalid_Slot_Handle;

    if ( !size )
      return TT_Err_Invalid_Size_Handle;

    if ( !face || glyph_index >= (FT_UInt)face->num_glyphs )
      return TT_Err_Invalid_Argument;

    if ( load_flags & ( 0x400 | 0x1 ) )
    {
      load_flags |= 0x2 |
                    0x8 |
                    0x1;
    }


    error = TT_Load_Glyph( size, slot, glyph_index, load_flags );




    return error;
  }
# 291 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c"
  static const FT_Service_MultiMastersRec tt_service_gx_multi_masters =
  {
    (FT_Get_MM_Func) ((void *)0),
    (FT_Set_MM_Design_Func) ((void *)0),
    (FT_Set_MM_Blend_Func) TT_Set_MM_Blend,
    (FT_Get_MM_Var_Func) TT_Get_MM_Var,
    (FT_Set_Var_Design_Func)TT_Set_Var_Design
  };


  static const FT_Service_TrueTypeEngineRec tt_service_truetype_engine =
  {



    FT_TRUETYPE_ENGINE_TYPE_UNPATENTED
# 316 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttdriver.c"
  };

  static const FT_Service_TTGlyfRec tt_service_truetype_glyf =
  {
    (TT_Glyf_GetLocationFunc)tt_face_get_location
  };

  static const FT_ServiceDescRec tt_services[] =
  {
    { "xf86-driver-name", "TrueType" },

    { "multi-masters", &tt_service_gx_multi_masters },

    { "truetype-engine", &tt_service_truetype_engine },
    { "tt-glyf", &tt_service_truetype_glyf },
    { ((void *)0), ((void *)0) }
  };


  static FT_Module_Interface
  tt_get_interface( FT_Module driver,
                    const char* tt_interface )
  {
    FT_Module_Interface result;
    FT_Module sfntd;
    SFNT_Service sfnt;


    result = ft_service_list_lookup( tt_services, tt_interface );
    if ( result != ((void *)0) )
      return result;


    sfntd = FT_Get_Module( driver->library, "sfnt" );
    if ( sfntd )
    {
      sfnt = (SFNT_Service)( sfntd->clazz->module_interface );
      if ( sfnt )
        return sfnt->get_interface( driver, tt_interface );
    }

    return 0;
  }




 
  const FT_Driver_ClassRec tt_driver_class =
  {
    {
      1 |
      0x100 |

      0x400,




      sizeof ( TT_DriverRec ),

      "truetype",
      0x10000L,
      0x20000L,

      (void*)0,

      tt_driver_init,
      tt_driver_done,
      tt_get_interface,
    },

    sizeof ( TT_FaceRec ),
    sizeof ( TT_SizeRec ),
    sizeof ( FT_GlyphSlotRec ),

    tt_face_init,
    tt_face_done,
    tt_size_init,
    tt_size_done,
    tt_slot_init,
    0,


    ft_stub_set_char_sizes,
    ft_stub_set_pixel_sizes,

    Load_Glyph,

    tt_get_kerning,
    0,
    0,

    tt_size_request,

    tt_size_select



  };
# 23 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/truetype.c" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.c" 1
# 23 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.c"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttags.h" 1
# 24 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttags.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttags.h" 2
# 33 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttags.h"

# 95 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/tttags.h"

# 24 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.c" 2
# 62 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.c"
  static FT_Error
  tt_face_load_loca( TT_Face face,
                     FT_Stream stream )
  {
    FT_Error error;
    FT_ULong table_len;



    error = face->goto_table( face, ( ( (FT_ULong)'g' << 24 ) | ( (FT_ULong)'l' << 16 ) | ( (FT_ULong)'y' << 8 ) | (FT_ULong)'f' ), stream, &face->glyf_len );
    if ( error )
      goto Exit;

    do {} while ( 0 );
    error = face->goto_table( face, ( ( (FT_ULong)'l' << 24 ) | ( (FT_ULong)'o' << 16 ) | ( (FT_ULong)'c' << 8 ) | (FT_ULong)'a' ), stream, &table_len );
    if ( error )
    {
      error = TT_Err_Locations_Missing;
      goto Exit;
    }

    if ( face->header.Index_To_Loc_Format != 0 )
    {
      if ( table_len >= 0x40000L )
      {
        do {} while ( 0 );
        error = TT_Err_Invalid_Table;
        goto Exit;
      }
      face->num_locations = (FT_UInt)( table_len >> 2 );
    }
    else
    {
      if ( table_len >= 0x20000L )
      {
        do {} while ( 0 );
        error = TT_Err_Invalid_Table;
        goto Exit;
      }
      face->num_locations = (FT_UInt)( table_len >> 1 );
    }





    if ( ( ( error = ((FT_Stream_ExtractFrame( stream, table_len, (FT_Byte**)&(face->glyph_locations) ))) ) != 0 ) )
      goto Exit;

    do {} while ( 0 );

  Exit:
    return error;
  }


  static FT_ULong
  tt_face_get_location( TT_Face face,
                        FT_UInt gindex,
                        FT_UInt *asize )
  {
    FT_ULong pos1, pos2;
    FT_Byte* p;
    FT_Byte* p_limit;


    pos1 = pos2 = 0;

    if ( gindex < face->num_locations )
    {
      if ( face->header.Index_To_Loc_Format != 0 )
      {
        p = face->glyph_locations + gindex * 4;
        p_limit = face->glyph_locations + face->num_locations * 4;

        pos1 = ( (unsigned long)( p += 4, ( (FT_UInt32)(( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(0)] )) ) << (24) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(1)] )) ) << (16) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(2)] )) ) << (8) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(3)] )) ) << (0) )) ) ) );
        pos2 = pos1;

        if ( p + 4 <= p_limit )
          pos2 = ( (unsigned long)( p += 4, ( (FT_UInt32)(( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(0)] )) ) << (24) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(1)] )) ) << (16) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(2)] )) ) << (8) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(3)] )) ) << (0) )) ) ) );
      }
      else
      {
        p = face->glyph_locations + gindex * 2;
        p_limit = face->glyph_locations + face->num_locations * 2;

        pos1 = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
        pos2 = pos1;

        if ( p + 2 <= p_limit )
          pos2 = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );

        pos1 <<= 1;
        pos2 <<= 1;
      }
    }







    if ( pos2 >= pos1 )
      *asize = (FT_UInt)( pos2 - pos1 );
    else
      *asize = (FT_UInt)( face->glyf_len - pos1 );

    return pos1;
  }


  static void
  tt_face_done_loca( TT_Face face )
  {
    FT_Stream stream = face->root.stream;


    (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(face->glyph_locations) ));
    face->num_locations = 0;
  }
# 203 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.c"
  static FT_Error
  tt_face_load_cvt( TT_Face face,
                    FT_Stream stream )
  {


    FT_Error error;
    FT_Memory memory = stream->memory;
    FT_ULong table_len;


    do {} while ( 0 );

    error = face->goto_table( face, ( ( (FT_ULong)'c' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'t' << 8 ) | (FT_ULong)' ' ), stream, &table_len );
    if ( error )
    {
      do {} while ( 0 );

      face->cvt_size = 0;
      face->cvt = ((void *)0);
      error = TT_Err_Ok;

      goto Exit;
    }

    face->cvt_size = table_len / 2;

    if ( ( ((face->cvt) = (ft_mem_realloc( memory, sizeof ( *(face->cvt) ), 0, (face->cvt_size), ((void *)0), &error ))), error != 0 ) )
      goto Exit;

    if ( ( ( error = ((FT_Stream_EnterFrame( stream, face->cvt_size * 2L ))) ) != 0 ) )
      goto Exit;

    {
      FT_Short* cur = face->cvt;
      FT_Short* limit = cur + face->cvt_size;


      for ( ; cur < limit; cur++ )
        *cur = ( (FT_Short)FT_Stream_GetShort( stream ) );
    }

    (FT_Stream_ExitFrame( stream ));
    do {} while ( 0 );


    if ( face->doblend )
      error = tt_face_vary_cvt( face, stream );


  Exit:
    return error;
# 264 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.c"
  }
# 284 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.c"
  static FT_Error
  tt_face_load_fpgm( TT_Face face,
                     FT_Stream stream )
  {


    FT_Error error;
    FT_ULong table_len;


    do {} while ( 0 );


    error = face->goto_table( face, ( ( (FT_ULong)'f' << 24 ) | ( (FT_ULong)'p' << 16 ) | ( (FT_ULong)'g' << 8 ) | (FT_ULong)'m' ), stream, &table_len );
    if ( error )
    {
      face->font_program = ((void *)0);
      face->font_program_size = 0;
      error = TT_Err_Ok;

      do {} while ( 0 );
    }
    else
    {
      face->font_program_size = table_len;
      if ( ( ( error = ((FT_Stream_ExtractFrame( stream, table_len, (FT_Byte**)&(face->font_program) ))) ) != 0 ) )
        goto Exit;

      do {} while ( 0 );
    }

  Exit:
    return error;
# 326 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.c"
  }
# 346 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.c"
  static FT_Error
  tt_face_load_prep( TT_Face face,
                     FT_Stream stream )
  {


    FT_Error error;
    FT_ULong table_len;


    do {} while ( 0 );

    error = face->goto_table( face, ( ( (FT_ULong)'p' << 24 ) | ( (FT_ULong)'r' << 16 ) | ( (FT_ULong)'e' << 8 ) | (FT_ULong)'p' ), stream, &table_len );
    if ( error )
    {
      face->cvt_program = ((void *)0);
      face->cvt_program_size = 0;
      error = TT_Err_Ok;

      do {} while ( 0 );
    }
    else
    {
      face->cvt_program_size = table_len;
      if ( ( ( error = ((FT_Stream_ExtractFrame( stream, table_len, (FT_Byte**)&(face->cvt_program) ))) ) != 0 ) )
        goto Exit;

      do {} while ( 0 );
    }

  Exit:
    return error;
# 387 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.c"
  }
# 407 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.c"
  static FT_Error
  tt_face_load_hdmx( TT_Face face,
                     FT_Stream stream )
  {
    FT_Error error;
    FT_Memory memory = stream->memory;
    FT_UInt version, nn, num_records;
    FT_ULong table_size, record_size;
    FT_Byte* p;
    FT_Byte* limit;



    error = face->goto_table( face, ( ( (FT_ULong)'h' << 24 ) | ( (FT_ULong)'d' << 16 ) | ( (FT_ULong)'m' << 8 ) | (FT_ULong)'x' ), stream, &table_size );
    if ( error || table_size < 8 )
      return TT_Err_Ok;

    if ( ( ( error = ((FT_Stream_ExtractFrame( stream, table_size, (FT_Byte**)&(face->hdmx_table) ))) ) != 0 ) )
      goto Exit;

    p = face->hdmx_table;
    limit = p + table_size;

    version = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
    num_records = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
    record_size = ( (unsigned long)( p += 4, ( (FT_UInt32)(( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(0)] )) ) << (24) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(1)] )) ) << (16) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(2)] )) ) << (8) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(3)] )) ) << (0) )) ) ) );
# 445 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttpload.c"
    if ( record_size >= 0xFFFF0000UL )
      record_size &= 0xFFFFU;



    if ( version != 0 || num_records > 255 || record_size > 0x10001L )
    {
      error = TT_Err_Invalid_File_Format;
      goto Fail;
    }

    if ( ( ((face->hdmx_record_sizes) = (ft_mem_realloc( memory, sizeof ( *(face->hdmx_record_sizes) ), 0, (num_records), ((void *)0), &error ))), error != 0 ) )
      goto Fail;

    for ( nn = 0; nn < num_records; nn++ )
    {
      if ( p + record_size > limit )
        break;

      face->hdmx_record_sizes[nn] = p[0];
      p += record_size;
    }

    face->hdmx_record_count = nn;
    face->hdmx_table_size = table_size;
    face->hdmx_record_size = record_size;

  Exit:
    return error;

  Fail:
    (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(face->hdmx_table) ));
    face->hdmx_table_size = 0;
    goto Exit;
  }


  static void
  tt_face_free_hdmx( TT_Face face )
  {
    FT_Stream stream = face->root.stream;
    FT_Memory memory = stream->memory;


    do { ft_mem_free( memory, (face->hdmx_record_sizes) ); (face->hdmx_record_sizes) = ((void *)0); } while ( 0 );
    (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(face->hdmx_table) ));
  }







  static FT_Byte*
  tt_face_get_device_metrics( TT_Face face,
                              FT_UInt ppem,
                              FT_UInt gindex )
  {
    FT_UInt nn;
    FT_Byte* result = ((void *)0);
    FT_ULong record_size = face->hdmx_record_size;
    FT_Byte* record = face->hdmx_table + 8;


    for ( nn = 0; nn < face->hdmx_record_count; nn++ )
      if ( face->hdmx_record_sizes[nn] == ppem )
      {
        gindex += 2;
        if ( gindex < record_size )
          result = record + nn * record_size + gindex;
        break;
      }

    return result;
  }
# 24 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/truetype.c" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c" 1
# 21 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftcalc.h" 1
# 24 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftcalc.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftcalc.h" 2



# 47 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftcalc.h"
  extern FT_Int32
  FT_SqrtFixed( FT_Int32 x );
# 68 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftcalc.h"
  extern __attribute__((dllexport)) FT_Int32
  FT_Sqrt32( FT_Int32 x );
# 106 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftcalc.h"
  extern FT_Long
  FT_MulDiv_No_Round( FT_Long a,
                      FT_Long b,
                      FT_Long c );
# 122 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftcalc.h"
  extern void
  FT_Matrix_Multiply_Scaled( const FT_Matrix* a,
                             FT_Matrix *b,
                             FT_Long scaling );







  extern void
  FT_Vector_Transform_Scaled( FT_Vector* vector,
                              const FT_Matrix* matrix,
                              FT_Long scaling );
# 145 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftcalc.h"
  extern FT_Int
  ft_corner_orientation( FT_Pos in_x,
                         FT_Pos in_y,
                         FT_Pos out_x,
                         FT_Pos out_y );






  extern FT_Int
  ft_corner_is_flat( FT_Pos in_x,
                     FT_Pos in_y,
                     FT_Pos out_x,
                     FT_Pos out_y );
# 173 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/internal/ftcalc.h"

# 22 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c" 2



# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h" 1
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h" 2
# 34 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"

# 108 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Outline_Decompose( FT_Outline* outline,
                        const FT_Outline_Funcs* func_interface,
                        void* user );
# 143 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Outline_New( FT_Library library,
                  FT_UInt numPoints,
                  FT_Int numContours,
                  FT_Outline *anoutline );


  extern __attribute__((dllexport)) FT_Error
  FT_Outline_New_Internal( FT_Memory memory,
                           FT_UInt numPoints,
                           FT_Int numContours,
                           FT_Outline *anoutline );
# 181 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Outline_Done( FT_Library library,
                   FT_Outline* outline );


  extern __attribute__((dllexport)) FT_Error
  FT_Outline_Done_Internal( FT_Memory memory,
                            FT_Outline* outline );
# 205 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Outline_Check( FT_Outline* outline );
# 232 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) void
  FT_Outline_Get_CBox( const FT_Outline* outline,
                       FT_BBox *acbox );
# 253 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) void
  FT_Outline_Translate( const FT_Outline* outline,
                        FT_Pos xOffset,
                        FT_Pos yOffset );
# 278 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Outline_Copy( const FT_Outline* source,
                   FT_Outline *target );
# 302 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) void
  FT_Outline_Transform( const FT_Outline* outline,
                        const FT_Matrix* matrix );
# 344 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Outline_Embolden( FT_Outline* outline,
                       FT_Pos strength );
# 368 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) void
  FT_Outline_Reverse( FT_Outline* outline );
# 403 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Outline_Get_Bitmap( FT_Library library,
                         FT_Outline* outline,
                         const FT_Bitmap *abitmap );
# 445 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) FT_Error
  FT_Outline_Render( FT_Library library,
                     FT_Outline* outline,
                     FT_Raster_Params* params );
# 486 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  typedef enum FT_Orientation_
  {
    FT_ORIENTATION_TRUETYPE = 0,
    FT_ORIENTATION_POSTSCRIPT = 1,
    FT_ORIENTATION_FILL_RIGHT = FT_ORIENTATION_TRUETYPE,
    FT_ORIENTATION_FILL_LEFT = FT_ORIENTATION_POSTSCRIPT,
    FT_ORIENTATION_NONE

  } FT_Orientation;
# 519 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ftoutln.h"
  extern __attribute__((dllexport)) FT_Orientation
  FT_Outline_Get_Orientation( FT_Outline* outline );






# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c" 2
# 72 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
  static void
  Get_HMetrics( TT_Face face,
                FT_UInt idx,
                FT_Bool check,
                FT_Short* lsb,
                FT_UShort* aw )
  {
    ( (SFNT_Service)face->sfnt )->get_metrics( face, 0, idx, lsb, aw );

    if ( check && face->postscript.isFixedPitch )
      *aw = face->horizontal.advance_Width_Max;
  }
# 99 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
  static void
  Get_VMetrics( TT_Face face,
                FT_UInt idx,
                FT_Bool check,
                FT_Short* tsb,
                FT_UShort* ah )
  {
    ( (check) = (check) );

    if ( face->vertical_info )
      ( (SFNT_Service)face->sfnt )->get_metrics( face, 1, idx, tsb, ah );



    else
    {
      *tsb = 0;
      *ah = face->root.units_per_EM;
    }
# 134 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
  }






  static void
  translate_array( FT_UInt n,
                   FT_Vector* coords,
                   FT_Pos delta_x,
                   FT_Pos delta_y )
  {
    FT_UInt k;


    if ( delta_x )
      for ( k = 0; k < n; k++ )
        coords[k].x += delta_x;

    if ( delta_y )
      for ( k = 0; k < n; k++ )
        coords[k].y += delta_y;
  }
# 172 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
  static FT_Error
  TT_Access_Glyph_Frame( TT_Loader loader,
                         FT_UInt glyph_index,
                         FT_ULong offset,
                         FT_UInt byte_count )
  {
    FT_Error error;
    FT_Stream stream = loader->stream;


    ( (glyph_index) = (glyph_index) );


    do {} while ( 0 );


    if ( ( ( error = (FT_Stream_Seek( stream, offset )) ) != 0 ) || ( ( error = ((FT_Stream_EnterFrame( stream, byte_count ))) ) != 0 ) )
      return error;

    loader->cursor = stream->cursor;
    loader->limit = stream->limit;

    return TT_Err_Ok;
  }


  static void
  TT_Forget_Glyph_Frame( TT_Loader loader )
  {
    FT_Stream stream = loader->stream;


    (FT_Stream_ExitFrame( stream ));
  }


  static FT_Error
  TT_Load_Glyph_Header( TT_Loader loader )
  {
    FT_Byte* p = loader->cursor;
    FT_Byte* limit = loader->limit;


    if ( p + 10 > limit )
      return TT_Err_Invalid_Outline;

    loader->n_contours = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );

    loader->bbox.xMin = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
    loader->bbox.yMin = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
    loader->bbox.xMax = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
    loader->bbox.yMax = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );

    do {} while ( 0 );
    do {} while ( 0 )
                                                                ;
    do {} while ( 0 )
                                                                ;
    loader->cursor = p;

    return TT_Err_Ok;
  }


  static FT_Error
  TT_Load_Simple_Glyph( TT_Loader load )
  {
    FT_Error error;
    FT_Byte* p = load->cursor;
    FT_Byte* limit = load->limit;
    FT_GlyphLoader gloader = load->gloader;
    FT_Int n_contours = load->n_contours;
    FT_Outline* outline;
    TT_Face face = (TT_Face)load->face;
    FT_UShort n_ins;
    FT_Int n_points;

    FT_Byte *flag, *flag_limit;
    FT_Byte c, count;
    FT_Vector *vec, *vec_limit;
    FT_Pos x;
    FT_Short *cont, *cont_limit, prev_cont;
    FT_Int xy_size = 0;



    error = ( ( ( (0) == 0 || (int)((gloader)->base.outline.n_points + (gloader)->current.outline.n_points + (0)) <= (int)(gloader)->max_points ) && ( (n_contours) == 0 || (int)((gloader)->base.outline.n_contours + (gloader)->current.outline.n_contours + (n_contours)) <= (int)(gloader)->max_contours ) ) ? 0 : FT_GlyphLoader_CheckPoints( (gloader), (0), (n_contours) ) );
    if ( error )
      goto Fail;


    cont = gloader->current.outline.contours;
    cont_limit = cont + n_contours;


    if ( n_contours >= 0xFFF || p + ( n_contours + 1 ) * 2 > limit )
      goto Invalid_Outline;

    prev_cont = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );

    if ( n_contours > 0 )
      cont[0] = prev_cont;

    for ( cont++; cont < cont_limit; cont++ )
    {
      cont[0] = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
      if ( cont[0] <= prev_cont )
      {

        error = FT_Err_Invalid_Table;
        goto Fail;
      }
      prev_cont = cont[0];
    }

    n_points = 0;
    if ( n_contours > 0 )
    {
      n_points = cont[-1] + 1;
      if ( n_points < 0 )
        goto Invalid_Outline;
    }


    error = ( ( ( (n_points + 4) == 0 || (int)((gloader)->base.outline.n_points + (gloader)->current.outline.n_points + (n_points + 4)) <= (int)(gloader)->max_points ) && ( (0) == 0 || (int)((gloader)->base.outline.n_contours + (gloader)->current.outline.n_contours + (0)) <= (int)(gloader)->max_contours ) ) ? 0 : FT_GlyphLoader_CheckPoints( (gloader), (n_points + 4), (0) ) );
    if ( error )
      goto Fail;


    outline = &gloader->current.outline;

    for ( cont = outline->contours + 1; cont < cont_limit; cont++ )
      if ( cont[-1] >= cont[0] )
        goto Invalid_Outline;


    load->glyph->control_len = 0;
    load->glyph->control_data = 0;

    if ( p + 2 > limit )
      goto Invalid_Outline;

    n_ins = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );

    do {} while ( 0 );

    if ( n_ins > face->max_profile.maxSizeOfInstructions )
    {
      do {} while ( 0 )
                          ;
      error = TT_Err_Too_Many_Hints;
      goto Fail;
    }

    if ( ( limit - p ) < n_ins )
    {
      do {} while ( 0 );
      error = TT_Err_Too_Many_Hints;
      goto Fail;
    }



    if ( ( ( load->load_flags & 0x2 ) == 0 ) )
    {
      load->glyph->control_len = n_ins;
      load->glyph->control_data = load->exec->glyphIns;

      memcpy( load->exec->glyphIns, p, (FT_Long)n_ins );
    }



    p += n_ins;


    flag = (FT_Byte*)outline->tags;
    flag_limit = flag + n_points;

    do {} while ( 0 );

    while ( flag < flag_limit )
    {
      if ( p + 1 > limit )
        goto Invalid_Outline;

      *flag++ = c = ( (unsigned char)*p++ );
      if ( c & 8 )
      {
        if ( p + 1 > limit )
          goto Invalid_Outline;

        count = ( (unsigned char)*p++ );
        if ( flag + (FT_Int)count > flag_limit )
          goto Invalid_Outline;

        for ( ; count > 0; count-- )
          *flag++ = c;
      }
    }



    vec = outline->points;
    vec_limit = vec + n_points;
    flag = (FT_Byte*)outline->tags;
    x = 0;

    if ( p + xy_size > limit )
      goto Invalid_Outline;

    for ( ; vec < vec_limit; vec++, flag++ )
    {
      FT_Pos y = 0;
      FT_Byte f = *flag;


      if ( f & 2 )
      {
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)( (unsigned char)*p++ );
        if ( ( f & 16 ) == 0 )
          y = -y;
      }
      else if ( ( f & 16 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
      }

      x += y;
      vec->x = x;
      *flag = f & ~( 2 | 16 );
    }



    vec = gloader->current.outline.points;
    vec_limit = vec + n_points;
    flag = (FT_Byte*)outline->tags;
    x = 0;

    for ( ; vec < vec_limit; vec++, flag++ )
    {
      FT_Pos y = 0;
      FT_Byte f = *flag;


      if ( f & 4 )
      {
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)( (unsigned char)*p++ );
        if ( ( f & 32 ) == 0 )
          y = -y;
      }
      else if ( ( f & 32 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
      }

      x += y;
      vec->y = x;
      *flag = f & 1;
    }

    outline->n_points = (FT_UShort)n_points;
    outline->n_contours = (FT_Short) n_contours;

    load->cursor = p;

  Fail:
    return error;

  Invalid_Outline:
    error = TT_Err_Invalid_Outline;
    goto Fail;
  }


  static FT_Error
  TT_Load_Composite_Glyph( TT_Loader loader )
  {
    FT_Error error;
    FT_Byte* p = loader->cursor;
    FT_Byte* limit = loader->limit;
    FT_GlyphLoader gloader = loader->gloader;
    FT_SubGlyph subglyph;
    FT_UInt num_subglyphs;


    num_subglyphs = 0;

    do
    {
      FT_Fixed xx, xy, yy, yx;
      FT_UInt count;



      error = FT_GlyphLoader_CheckSubGlyphs( gloader, num_subglyphs + 1 );
      if ( error )
        goto Fail;


      if ( p + 4 > limit )
        goto Invalid_Composite;

      subglyph = gloader->current.subglyphs + num_subglyphs;

      subglyph->arg1 = subglyph->arg2 = 0;

      subglyph->flags = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
      subglyph->index = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );


      count = 2;
      if ( subglyph->flags & 0x0001 )
        count += 2;
      if ( subglyph->flags & 0x0008 )
        count += 2;
      else if ( subglyph->flags & 0x0040 )
        count += 4;
      else if ( subglyph->flags & 0x0080 )
        count += 8;

      if ( p + count > limit )
        goto Invalid_Composite;


      if ( subglyph->flags & 0x0001 )
      {
        subglyph->arg1 = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
        subglyph->arg2 = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
      }
      else
      {
        subglyph->arg1 = ( (signed char)*p++ );
        subglyph->arg2 = ( (signed char)*p++ );
      }


      xx = yy = 0x10000L;
      xy = yx = 0;

      if ( subglyph->flags & 0x0008 )
      {
        xx = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) << 2;
        yy = xx;
      }
      else if ( subglyph->flags & 0x0040 )
      {
        xx = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) << 2;
        yy = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) << 2;
      }
      else if ( subglyph->flags & 0x0080 )
      {
        xx = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) << 2;
        yx = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) << 2;
        xy = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) << 2;
        yy = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_Int16)(( ((const FT_Char*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_Int16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) << 2;
      }

      subglyph->transform.xx = xx;
      subglyph->transform.xy = xy;
      subglyph->transform.yx = yx;
      subglyph->transform.yy = yy;

      num_subglyphs++;

    } while ( subglyph->flags & 0x0020 );

    gloader->current.num_subglyphs = num_subglyphs;



    {
      FT_Stream stream = loader->stream;






      loader->ins_pos = (FT_ULong)( FT_Stream_Pos( stream ) +
                                    p - limit );
    }



    loader->cursor = p;

  Fail:
    return error;

  Invalid_Composite:
    error = TT_Err_Invalid_Composite;
    goto Fail;
  }


  static void
  TT_Init_Glyph_Loading( TT_Face face )
  {
    face->access_glyph_frame = TT_Access_Glyph_Frame;
    face->read_glyph_header = TT_Load_Glyph_Header;
    face->read_simple_glyph = TT_Load_Simple_Glyph;
    face->read_composite_glyph = TT_Load_Composite_Glyph;
    face->forget_glyph_frame = TT_Forget_Glyph_Frame;
  }


  static void
  tt_prepare_zone( TT_GlyphZone zone,
                   FT_GlyphLoad load,
                   FT_UInt start_point,
                   FT_UInt start_contour )
  {
    zone->n_points = (FT_UShort)( load->outline.n_points - start_point );
    zone->n_contours = (FT_Short) ( load->outline.n_contours -
                                       start_contour );
    zone->org = load->extra_points + start_point;
    zone->cur = load->outline.points + start_point;
    zone->orus = load->extra_points2 + start_point;
    zone->tags = (FT_Byte*)load->outline.tags + start_point;
    zone->contours = (FT_UShort*)load->outline.contours + start_contour;
    zone->first_point = (FT_UShort)start_point;
  }
# 619 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
  static FT_Error
  TT_Hint_Glyph( TT_Loader loader,
                 FT_Bool is_composite )
  {
    TT_GlyphZone zone = &loader->zone;
    FT_Pos origin;


    FT_UInt n_ins;






    n_ins = loader->glyph->control_len;


    origin = zone->cur[zone->n_points - 4].x;
    origin = ( ((origin) + 32) & ~63 ) - origin;
    if ( origin )
      translate_array( zone->n_points, zone->cur, origin, 0 );



    if ( n_ins > 0 )
      memcpy( zone->org, zone->cur, (zone->n_points) * sizeof ( *(zone->org) ) );


    loader->exec->GS = ((TT_Size)loader->size)->GS;



    if ( is_composite )
    {
      loader->exec->metrics.x_scale = 1 << 16;
      loader->exec->metrics.y_scale = 1 << 16;

      memcpy( zone->orus, zone->cur, (zone->n_points) * sizeof ( *(zone->orus) ) );
    }
    else
    {
      loader->exec->metrics.x_scale =
        ((TT_Size)loader->size)->metrics.x_scale;
      loader->exec->metrics.y_scale =
        ((TT_Size)loader->size)->metrics.y_scale;
    }



    zone->cur[zone->n_points - 3].x =
      ( ((zone->cur[zone->n_points - 3].x) + 32) & ~63 );
    zone->cur[zone->n_points - 1].y =
      ( ((zone->cur[zone->n_points - 1].y) + 32) & ~63 );



    if ( n_ins > 0 )
    {
      FT_Bool debug;
      FT_Error error;


      error = TT_Set_CodeRange( loader->exec, tt_coderange_glyph,
                                loader->exec->glyphIns, n_ins );
      if ( error )
        return error;

      loader->exec->is_composite = is_composite;
      loader->exec->pts = *zone;

      debug = ( (FT_Bool)( !( loader->load_flags & 0x1 ) && ((TT_Size)loader->size)->debug ) )
                                                                   ;

      error = TT_Run_Context( loader->exec, debug );
      if ( error && loader->exec->pedantic_hinting )
        return error;
    }




    if ( !loader->preserve_pps )
    {
      loader->pp1 = zone->cur[zone->n_points - 4];
      loader->pp2 = zone->cur[zone->n_points - 3];
      loader->pp3 = zone->cur[zone->n_points - 2];
      loader->pp4 = zone->cur[zone->n_points - 1];
    }

    return TT_Err_Ok;
  }
# 723 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
  static FT_Error
  TT_Process_Simple_Glyph( TT_Loader loader )
  {
    FT_GlyphLoader gloader = loader->gloader;
    FT_Error error = TT_Err_Ok;
    FT_Outline* outline;
    FT_Int n_points;


    outline = &gloader->current.outline;
    n_points = outline->n_points;



    outline->points[n_points ] = loader->pp1;
    outline->points[n_points + 1] = loader->pp2;
    outline->points[n_points + 2] = loader->pp3;
    outline->points[n_points + 3] = loader->pp4;

    outline->tags[n_points ] = 0;
    outline->tags[n_points + 1] = 0;
    outline->tags[n_points + 2] = 0;
    outline->tags[n_points + 3] = 0;

    n_points += 4;



    if ( ((TT_Face)loader->face)->doblend )
    {

      FT_Vector* deltas;
      FT_Memory memory = loader->face->memory;
      FT_Int i;


      error = TT_Vary_Get_Glyph_Deltas( (TT_Face)(loader->face),
                                        loader->glyph_index,
                                        &deltas,
                                        n_points );
      if ( error )
        return error;

      for ( i = 0; i < n_points; ++i )
      {
        outline->points[i].x += deltas[i].x;
        outline->points[i].y += deltas[i].y;
      }

      do { ft_mem_free( memory, (deltas) ); (deltas) = ((void *)0); } while ( 0 );
    }



    if ( ( ( loader->load_flags & 0x2 ) == 0 ) )
    {
      tt_prepare_zone( &loader->zone, &gloader->current, 0, 0 );

      memcpy( loader->zone.orus, loader->zone.cur, (loader->zone.n_points + 4) * sizeof ( *(loader->zone.orus) ) )
                                                ;
    }


    if ( ( loader->load_flags & 0x1 ) == 0 )
    {
      FT_Vector* vec = outline->points;
      FT_Vector* limit = outline->points + n_points;
      FT_Fixed x_scale = ((TT_Size)loader->size)->metrics.x_scale;
      FT_Fixed y_scale = ((TT_Size)loader->size)->metrics.y_scale;


      for ( ; vec < limit; vec++ )
      {
        vec->x = FT_MulFix( vec->x, x_scale );
        vec->y = FT_MulFix( vec->y, y_scale );
      }

      loader->pp1 = outline->points[n_points - 4];
      loader->pp2 = outline->points[n_points - 3];
      loader->pp3 = outline->points[n_points - 2];
      loader->pp4 = outline->points[n_points - 1];
    }

    if ( ( ( loader->load_flags & 0x2 ) == 0 ) )
    {
      loader->zone.n_points += 4;

      error = TT_Hint_Glyph( loader, 0 );
    }

    return error;
  }
# 826 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
  static FT_Error
  TT_Process_Composite_Component( TT_Loader loader,
                                  FT_SubGlyph subglyph,
                                  FT_UInt start_point,
                                  FT_UInt num_base_points )
  {
    FT_GlyphLoader gloader = loader->gloader;
    FT_Vector* base_vec = gloader->base.outline.points;
    FT_UInt num_points = gloader->base.outline.n_points;
    FT_Bool have_scale;
    FT_Pos x, y;


    have_scale = ( (FT_Bool)( subglyph->flags & ( 0x0008 | 0x0040 | 0x0080 ) ) )

                                                                     ;


    if ( have_scale )
    {
      FT_UInt i;


      for ( i = num_base_points; i < num_points; i++ )
        FT_Vector_Transform( base_vec + i, &subglyph->transform );
    }


    if ( !( subglyph->flags & 0x0002 ) )
    {
      FT_UInt k = subglyph->arg1;
      FT_UInt l = subglyph->arg2;
      FT_Vector* p1;
      FT_Vector* p2;






      k += start_point;
      l += num_base_points;
      if ( k >= num_base_points ||
           l >= num_points )
        return TT_Err_Invalid_Composite;

      p1 = gloader->base.outline.points + k;
      p2 = gloader->base.outline.points + l;

      x = p1->x - p2->x;
      y = p1->y - p2->y;
    }
    else
    {
      x = subglyph->arg1;
      y = subglyph->arg2;

      if ( !x && !y )
        return TT_Err_Ok;





      if ( have_scale &&



            ( subglyph->flags & 0x0800 ) )

      {
# 929 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
        FT_Fixed mac_xscale = FT_SqrtFixed(
                                 FT_MulFix( subglyph->transform.xx,
                                            subglyph->transform.xx ) +
                                 FT_MulFix( subglyph->transform.xy,
                                            subglyph->transform.xy ) );
        FT_Fixed mac_yscale = FT_SqrtFixed(
                                 FT_MulFix( subglyph->transform.yy,
                                            subglyph->transform.yy ) +
                                 FT_MulFix( subglyph->transform.yx,
                                            subglyph->transform.yx ) );


        x = FT_MulFix( x, mac_xscale );
        y = FT_MulFix( y, mac_yscale );



      }

      if ( !( loader->load_flags & 0x1 ) )
      {
        FT_Fixed x_scale = ((TT_Size)loader->size)->metrics.x_scale;
        FT_Fixed y_scale = ((TT_Size)loader->size)->metrics.y_scale;


        x = FT_MulFix( x, x_scale );
        y = FT_MulFix( y, y_scale );

        if ( subglyph->flags & 0x0004 )
        {
          x = ( ((x) + 32) & ~63 );
          y = ( ((y) + 32) & ~63 );
        }
      }
    }

    if ( x || y )
      translate_array( num_points - num_base_points,
                       base_vec + num_base_points,
                       x, y );

    return TT_Err_Ok;
  }
# 984 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
  static FT_Error
  TT_Process_Composite_Glyph( TT_Loader loader,
                              FT_UInt start_point,
                              FT_UInt start_contour )
  {
    FT_Error error;
    FT_Outline* outline;
    FT_UInt i;


    outline = &loader->gloader->base.outline;


    error = ( ( ( (outline->n_points + 4) == 0 || (int)((loader->gloader)->base.outline.n_points + (loader->gloader)->current.outline.n_points + (outline->n_points + 4)) <= (int)(loader->gloader)->max_points ) && ( (0) == 0 || (int)((loader->gloader)->base.outline.n_contours + (loader->gloader)->current.outline.n_contours + (0)) <= (int)(loader->gloader)->max_contours ) ) ? 0 : FT_GlyphLoader_CheckPoints( (loader->gloader), (outline->n_points + 4), (0) ) )

                                            ;
    if ( error )
      return error;

    outline->points[outline->n_points ] = loader->pp1;
    outline->points[outline->n_points + 1] = loader->pp2;
    outline->points[outline->n_points + 2] = loader->pp3;
    outline->points[outline->n_points + 3] = loader->pp4;

    outline->tags[outline->n_points ] = 0;
    outline->tags[outline->n_points + 1] = 0;
    outline->tags[outline->n_points + 2] = 0;
    outline->tags[outline->n_points + 3] = 0;



    {
      FT_Stream stream = loader->stream;
      FT_UShort n_ins;




      if ( ( ( error = (FT_Stream_Seek( stream, loader->ins_pos )) ) != 0 ) ||
           ( n_ins = (FT_UShort)FT_Stream_ReadShort( stream, &error ), error != FT_Err_Ok ) )
        return error;

      do {} while ( 0 );


      if ( n_ins > ((TT_Face)loader->face)->max_profile.maxSizeOfInstructions )
      {
        do {} while ( 0 )
                            ;

        return TT_Err_Too_Many_Hints;
      }
      else if ( n_ins == 0 )
        return TT_Err_Ok;

      if ( ( ( error = (FT_Stream_Read( stream, (FT_Byte*)loader->exec->glyphIns, n_ins )) ) != 0 ) )
        return error;

      loader->glyph->control_data = loader->exec->glyphIns;
      loader->glyph->control_len = n_ins;
    }



    tt_prepare_zone( &loader->zone, &loader->gloader->base,
                     start_point, start_contour );



    for ( i = start_point; i < loader->zone.n_points; i++ )
      loader->zone.tags[i] &= ~( 8 |
                                 16 );

    loader->zone.n_points += 4;

    return TT_Hint_Glyph( loader, 1 );
  }
# 1088 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
  static FT_Error
  load_truetype_glyph( TT_Loader loader,
                       FT_UInt glyph_index,
                       FT_UInt recurse_count )
  {
    FT_Error error;
    FT_Fixed x_scale, y_scale;
    FT_ULong offset;
    TT_Face face = (TT_Face)loader->face;
    FT_GlyphLoader gloader = loader->gloader;
    FT_Bool opened_frame = 0;


    FT_Vector* deltas = ((void *)0);
# 1113 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
    if ( recurse_count > 1 &&
         recurse_count > face->max_profile.maxComponentDepth )
    {
      error = TT_Err_Invalid_Composite;
      goto Exit;
    }


    if ( glyph_index >= (FT_UInt)face->root.num_glyphs )
    {
      error = TT_Err_Invalid_Glyph_Index;
      goto Exit;
    }

    loader->glyph_index = glyph_index;

    if ( ( loader->load_flags & 0x1 ) == 0 )
    {
      x_scale = ((TT_Size)loader->size)->metrics.x_scale;
      y_scale = ((TT_Size)loader->size)->metrics.y_scale;
    }
    else
    {
      x_scale = 0x10000L;
      y_scale = 0x10000L;
    }


    {
      FT_Short left_bearing = 0, top_bearing = 0;
      FT_UShort advance_width = 0, advance_height = 0;


      Get_HMetrics( face, glyph_index,
                    (FT_Bool)!( loader->load_flags &
                                0x200 ),
                    &left_bearing,
                    &advance_width );
      Get_VMetrics( face, glyph_index,
                    (FT_Bool)!( loader->load_flags &
                                0x200 ),
                    &top_bearing,
                    &advance_height );
# 1198 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
      loader->left_bearing = left_bearing;
      loader->advance = advance_width;
      loader->top_bearing = top_bearing;
      loader->vadvance = advance_height;

      if ( !loader->linear_def )
      {
        loader->linear_def = 1;
        loader->linear = advance_width;
      }
    }
# 1241 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
      offset = tt_face_get_location( face, glyph_index,
                                     (FT_UInt*)&loader->byte_len );

    if ( loader->byte_len > 0 )
    {
      error = face->access_glyph_frame( loader, glyph_index,
                                        loader->glyf_offset + offset,
                                        loader->byte_len );
      if ( error )
        goto Exit;

      opened_frame = 1;


      error = face->read_glyph_header( loader );
      if ( error )
        goto Exit;
    }

    if ( loader->byte_len == 0 || loader->n_contours == 0 )
    {
      loader->bbox.xMin = 0;
      loader->bbox.xMax = 0;
      loader->bbox.yMin = 0;
      loader->bbox.yMax = 0;

      do { (loader)->pp1.x = (loader)->bbox.xMin - (loader)->left_bearing; (loader)->pp1.y = 0; (loader)->pp2.x = (loader)->pp1.x + (loader)->advance; (loader)->pp2.y = 0; (loader)->pp3.x = 0; (loader)->pp3.y = (loader)->top_bearing + (loader)->bbox.yMax; (loader)->pp4.x = 0; (loader)->pp4.y = (loader)->pp3.y - (loader)->vadvance; } while ( 0 );



      if ( ((TT_Face)(loader->face))->doblend )
      {

        FT_Memory memory = loader->face->memory;


        error = TT_Vary_Get_Glyph_Deltas( (TT_Face)(loader->face),
                                          glyph_index, &deltas, 4 );
        if ( error )
          goto Exit;

        loader->pp1.x += deltas[0].x; loader->pp1.y += deltas[0].y;
        loader->pp2.x += deltas[1].x; loader->pp2.y += deltas[1].y;
        loader->pp3.x += deltas[2].x; loader->pp3.y += deltas[2].y;
        loader->pp4.x += deltas[3].x; loader->pp4.y += deltas[3].y;

        do { ft_mem_free( memory, (deltas) ); (deltas) = ((void *)0); } while ( 0 );
      }



      if ( ( loader->load_flags & 0x1 ) == 0 )
      {
        loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
        loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
        loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
        loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
      }

      error = TT_Err_Ok;
      goto Exit;
    }

    do { (loader)->pp1.x = (loader)->bbox.xMin - (loader)->left_bearing; (loader)->pp1.y = 0; (loader)->pp2.x = (loader)->pp1.x + (loader)->advance; (loader)->pp2.y = 0; (loader)->pp3.x = 0; (loader)->pp3.y = (loader)->top_bearing + (loader)->bbox.yMax; (loader)->pp4.x = 0; (loader)->pp4.y = (loader)->pp3.y - (loader)->vadvance; } while ( 0 );







    if ( loader->n_contours > 0 )
    {
      error = face->read_simple_glyph( loader );
      if ( error )
        goto Exit;


      face->forget_glyph_frame( loader );
      opened_frame = 0;

      error = TT_Process_Simple_Glyph( loader );
      if ( error )
        goto Exit;

      FT_GlyphLoader_Add( gloader );
    }






    else if ( loader->n_contours == -1 )
    {
      FT_UInt start_point;
      FT_UInt start_contour;
      FT_ULong ins_pos;


      start_point = gloader->base.outline.n_points;
      start_contour = gloader->base.outline.n_contours;


      error = face->read_composite_glyph( loader );
      if ( error )
        goto Exit;


      ins_pos = loader->ins_pos;


      face->forget_glyph_frame( loader );
      opened_frame = 0;



      if ( face->doblend )
      {
        FT_Int i, limit;
        FT_SubGlyph subglyph;
        FT_Memory memory = face->root.memory;





        if ( ( error = TT_Vary_Get_Glyph_Deltas(
                         face,
                         glyph_index,
                         &deltas,
                         gloader->current.num_subglyphs + 4 )) != 0 )
          goto Exit;

        subglyph = gloader->current.subglyphs + gloader->base.num_subglyphs;
        limit = gloader->current.num_subglyphs;

        for ( i = 0; i < limit; ++i, ++subglyph )
        {
          if ( subglyph->flags & 0x0002 )
          {
            subglyph->arg1 += deltas[i].x;
            subglyph->arg2 += deltas[i].y;
          }
        }

        loader->pp1.x += deltas[i + 0].x; loader->pp1.y += deltas[i + 0].y;
        loader->pp2.x += deltas[i + 1].x; loader->pp2.y += deltas[i + 1].y;
        loader->pp3.x += deltas[i + 2].x; loader->pp3.y += deltas[i + 2].y;
        loader->pp4.x += deltas[i + 3].x; loader->pp4.y += deltas[i + 3].y;

        do { ft_mem_free( memory, (deltas) ); (deltas) = ((void *)0); } while ( 0 );
      }



      if ( ( loader->load_flags & 0x1 ) == 0 )
      {
        loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
        loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
        loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
        loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
      }




      if ( loader->load_flags & 0x400 )
      {
        FT_GlyphLoader_Add( gloader );
        loader->glyph->format = FT_GLYPH_FORMAT_COMPOSITE;

        goto Exit;
      }





      {
        FT_UInt n, num_base_points;
        FT_SubGlyph subglyph = 0;

        FT_UInt num_points = start_point;
        FT_UInt num_subglyphs = gloader->current.num_subglyphs;
        FT_UInt num_base_subgs = gloader->base.num_subglyphs;

        FT_Stream old_stream = loader->stream;


        FT_GlyphLoader_Add( gloader );


        for ( n = 0; n < num_subglyphs; n++ )
        {
          FT_Vector pp[4];






          subglyph = gloader->base.subglyphs + num_base_subgs + n;

          pp[0] = loader->pp1;
          pp[1] = loader->pp2;
          pp[2] = loader->pp3;
          pp[3] = loader->pp4;

          num_base_points = gloader->base.outline.n_points;

          error = load_truetype_glyph( loader, subglyph->index,
                                       recurse_count + 1 );
          if ( error )
            goto Exit;


          subglyph = gloader->base.subglyphs + num_base_subgs + n;

          if ( !( subglyph->flags & 0x0200 ) )
          {
            loader->pp1 = pp[0];
            loader->pp2 = pp[1];
            loader->pp3 = pp[2];
            loader->pp4 = pp[3];
          }

          num_points = gloader->base.outline.n_points;

          if ( num_points == num_base_points )
            continue;







          TT_Process_Composite_Component( loader, subglyph, start_point,
                                          num_base_points );
        }

        loader->stream = old_stream;


        loader->ins_pos = ins_pos;
        if ( ( ( loader->load_flags & 0x2 ) == 0 ) &&



             subglyph->flags & 0x0100 &&



             num_points > start_point )
          TT_Process_Composite_Glyph( loader, start_point, start_contour );

      }
    }
    else
    {

      error = TT_Err_Invalid_Outline;
      goto Exit;
    }





  Exit:

    if ( opened_frame )
      face->forget_glyph_frame( loader );
# 1525 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
    return error;
  }


  static FT_Error
  compute_glyph_metrics( TT_Loader loader,
                         FT_UInt glyph_index )
  {
    FT_BBox bbox;
    TT_Face face = (TT_Face)loader->face;
    FT_Fixed y_scale;
    TT_GlyphSlot glyph = loader->glyph;
    TT_Size size = (TT_Size)loader->size;


    y_scale = 0x10000L;
    if ( ( loader->load_flags & 0x1 ) == 0 )
      y_scale = size->root.metrics.y_scale;

    if ( glyph->format != FT_GLYPH_FORMAT_COMPOSITE )
      FT_Outline_Get_CBox( &glyph->outline, &bbox );
    else
      bbox = loader->bbox;



    {
      FT_Pos advance = loader->linear;







      if ( face->postscript.isFixedPitch &&
           ( loader->load_flags & 0x200 ) == 0 )
        advance = face->horizontal.advance_Width_Max;



      glyph->linearHoriAdvance = advance;
    }

    glyph->metrics.horiBearingX = bbox.xMin;
    glyph->metrics.horiBearingY = bbox.yMax;
    glyph->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;





    {
      FT_Pos top;
      FT_Pos advance;



      if ( face->vertical_info &&
           face->vertical.number_Of_VMetrics > 0 )
      {
        top = (FT_Short)FT_DivFix( loader->pp3.y - bbox.yMax,
                                   y_scale );

        if ( loader->pp3.y <= loader->pp4.y )
          advance = 0;
        else
          advance = (FT_UShort)FT_DivFix( loader->pp3.y - loader->pp4.y,
                                          y_scale );
      }
      else
      {
        FT_Pos height;
# 1608 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
        height = (FT_Short)FT_DivFix( bbox.yMax - bbox.yMin,
                                      y_scale );
        if ( face->os2.version != 0xFFFFU )
          advance = (FT_Pos)( face->os2.sTypoAscender -
                              face->os2.sTypoDescender );
        else
          advance = (FT_Pos)( face->horizontal.Ascender -
                              face->horizontal.Descender );

        top = ( advance - height ) / 2;
      }
# 1653 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
      glyph->linearVertAdvance = advance;


      if ( !( loader->load_flags & 0x1 ) )
      {
        top = FT_MulFix( top, y_scale );
        advance = FT_MulFix( advance, y_scale );
      }




      glyph->metrics.vertBearingX = ( bbox.xMin - bbox.xMax ) / 2;
      glyph->metrics.vertBearingY = top;
      glyph->metrics.vertAdvance = advance;
    }


    if ( !face->postscript.isFixedPitch &&
         ( ( loader->load_flags & 0x2 ) == 0 ) )
    {
      FT_Byte* widthp;


      widthp = tt_face_get_device_metrics( face,
                                           size->root.metrics.x_ppem,
                                           glyph_index );

      if ( widthp )
        glyph->metrics.horiAdvance = *widthp << 6;
    }


    glyph->metrics.width = bbox.xMax - bbox.xMin;
    glyph->metrics.height = bbox.yMax - bbox.yMin;

    return 0;
  }




  static FT_Error
  load_sbit_image( TT_Size size,
                   TT_GlyphSlot glyph,
                   FT_UInt glyph_index,
                   FT_Int32 load_flags )
  {
    TT_Face face;
    SFNT_Service sfnt;
    FT_Stream stream;
    FT_Error error;
    TT_SBit_MetricsRec metrics;


    face = (TT_Face)glyph->face;
    sfnt = (SFNT_Service)face->sfnt;
    stream = face->root.stream;

    error = sfnt->load_sbit_image( face,
                                   size->strike_index,
                                   glyph_index,
                                   (FT_Int)load_flags,
                                   stream,
                                   &glyph->bitmap,
                                   &metrics );
    if ( !error )
    {
      glyph->outline.n_points = 0;
      glyph->outline.n_contours = 0;

      glyph->metrics.width = (FT_Pos)metrics.width << 6;
      glyph->metrics.height = (FT_Pos)metrics.height << 6;

      glyph->metrics.horiBearingX = (FT_Pos)metrics.horiBearingX << 6;
      glyph->metrics.horiBearingY = (FT_Pos)metrics.horiBearingY << 6;
      glyph->metrics.horiAdvance = (FT_Pos)metrics.horiAdvance << 6;

      glyph->metrics.vertBearingX = (FT_Pos)metrics.vertBearingX << 6;
      glyph->metrics.vertBearingY = (FT_Pos)metrics.vertBearingY << 6;
      glyph->metrics.vertAdvance = (FT_Pos)metrics.vertAdvance << 6;

      glyph->format = FT_GLYPH_FORMAT_BITMAP;
      if ( load_flags & 0x10 )
      {
        glyph->bitmap_left = metrics.vertBearingX;
        glyph->bitmap_top = metrics.vertBearingY;
      }
      else
      {
        glyph->bitmap_left = metrics.horiBearingX;
        glyph->bitmap_top = metrics.horiBearingY;
      }
    }

    return error;
  }




  static FT_Error
  tt_loader_init( TT_Loader loader,
                  TT_Size size,
                  TT_GlyphSlot glyph,
                  FT_Int32 load_flags )
  {
    TT_Face face;
    FT_Stream stream;


    face = (TT_Face)glyph->face;
    stream = face->root.stream;

    memset( loader, 0, sizeof ( TT_LoaderRec ) );




    if ( ( ( load_flags & 0x2 ) == 0 ) )
    {
      TT_ExecContext exec;
      FT_Bool grayscale;


      if ( !size->cvt_ready )
      {
        FT_Error error = tt_size_ready_bytecode( size );
        if ( error )
          return error;
      }


      exec = size->debug ? size->context
                         : ( (TT_Driver)((FT_Face)(face))->driver )->context;
      if ( !exec )
        return TT_Err_Could_Not_Find_Context;

      grayscale =
        ( (FT_Bool)( ( (FT_Render_Mode)( ( (load_flags) >> 16 ) & 15 ) ) != FT_RENDER_MODE_MONO ) );

      TT_Load_Context( exec, face, size );



      if ( grayscale != exec->grayscale )
      {
        FT_UInt i;


        exec->grayscale = grayscale;

        for ( i = 0; i < size->cvt_size; i++ )
          size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );
        tt_size_run_prep( size );
      }


      if ( exec->GS.instruct_control & 1 )
        load_flags |= 0x2;


      if ( exec->GS.instruct_control & 2 )
        exec->GS = tt_default_graphics_state;

      exec->pedantic_hinting = ( (FT_Bool)( load_flags & 0x80 ) );
      loader->exec = exec;
      loader->instructions = exec->glyphIns;
    }
# 1837 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
    {
      FT_Error error = face->goto_table( face, ( ( (FT_ULong)'g' << 24 ) | ( (FT_ULong)'l' << 16 ) | ( (FT_ULong)'y' << 8 ) | (FT_ULong)'f' ), stream, 0 );


      if ( error )
      {
        do {} while ( 0 );
        return error;
      }
      loader->glyf_offset = FT_Stream_Pos( stream );
    }


    {
      FT_GlyphLoader gloader = glyph->internal->loader;


      FT_GlyphLoader_Rewind( gloader );
      loader->gloader = gloader;
    }

    loader->load_flags = load_flags;

    loader->face = (FT_Face)face;
    loader->size = (FT_Size)size;
    loader->glyph = (FT_GlyphSlot)glyph;
    loader->stream = stream;

    return TT_Err_Ok;
  }
# 1896 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgload.c"
  static FT_Error
  TT_Load_Glyph( TT_Size size,
                 TT_GlyphSlot glyph,
                 FT_UInt glyph_index,
                 FT_Int32 load_flags )
  {
    TT_Face face;
    FT_Error error;
    TT_LoaderRec loader;


    face = (TT_Face)glyph->face;
    error = TT_Err_Ok;







    if ( size->strike_index != 0xFFFFFFFFUL &&
         ( load_flags & 0x8 ) == 0 )
    {
      error = load_sbit_image( size, glyph, glyph_index, load_flags );
      if ( !error )
        return TT_Err_Ok;
    }




    if ( !( load_flags & 0x1 ) && !size->ttmetrics.valid )
      return TT_Err_Invalid_Size_Handle;

    if ( load_flags & 0x4000 )
      return TT_Err_Invalid_Argument;

    error = tt_loader_init( &loader, size, glyph, load_flags );
    if ( error )
      return error;

    glyph->format = FT_GLYPH_FORMAT_OUTLINE;
    glyph->num_subglyphs = 0;
    glyph->outline.flags = 0;


    error = load_truetype_glyph( &loader, glyph_index, 0 );
    if ( !error )
    {
      if ( glyph->format == FT_GLYPH_FORMAT_COMPOSITE )
      {
        glyph->num_subglyphs = loader.gloader->base.num_subglyphs;
        glyph->subglyphs = loader.gloader->base.subglyphs;
      }
      else
      {
        glyph->outline = loader.gloader->base.outline;
        glyph->outline.flags &= ~0x200;



        if ( ( face->header.Flags & 2 ) == 0 && loader.pp1.x )
          FT_Outline_Translate( &glyph->outline, -loader.pp1.x, 0 );
      }



      if ( ( ( load_flags & 0x2 ) == 0 ) )
      {
        if ( loader.exec->GS.scan_control )
        {

          switch ( loader.exec->GS.scan_type )
          {
          case 0:
            glyph->outline.flags |= 0x20;
            break;
          case 1:

            break;
          case 4:
            glyph->outline.flags |= 0x10 |
                                    0x20;
            break;
          case 5:
            glyph->outline.flags |= 0x10;
            break;

          default:
            glyph->outline.flags |= 0x8;
            break;
          }
        }
        else
          glyph->outline.flags |= 0x8;
      }



      compute_glyph_metrics( &loader, glyph_index );
    }





    if ( !( load_flags & 0x1 ) &&
         size->root.metrics.y_ppem < 24 )
      glyph->outline.flags |= 0x100;

    return error;
  }
# 25 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/truetype.c" 2
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c" 1
# 37 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ttunpat.h" 1
# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ttunpat.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 27 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ttunpat.h" 2
# 35 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ttunpat.h"

# 53 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/ttunpat.h"

# 38 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c" 2
# 74 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
  static void
  tt_glyphzone_done( TT_GlyphZone zone )
  {
    FT_Memory memory = zone->memory;


    if ( memory )
    {
      do { ft_mem_free( memory, (zone->contours) ); (zone->contours) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (zone->tags) ); (zone->tags) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (zone->cur) ); (zone->cur) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (zone->org) ); (zone->org) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (zone->orus) ); (zone->orus) = ((void *)0); } while ( 0 );

      zone->max_points = zone->n_points = 0;
      zone->max_contours = zone->n_contours = 0;
      zone->memory = ((void *)0);
    }
  }
# 116 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_glyphzone_new( FT_Memory memory,
                    FT_UShort maxPoints,
                    FT_Short maxContours,
                    TT_GlyphZone zone )
  {
    FT_Error error;


    memset( zone, 0, sizeof ( *zone ) );
    zone->memory = memory;

    if ( ( ((zone->org) = (ft_mem_realloc( memory, sizeof ( *(zone->org) ), 0, (maxPoints), ((void *)0), &error ))), error != 0 ) ||
         ( ((zone->cur) = (ft_mem_realloc( memory, sizeof ( *(zone->cur) ), 0, (maxPoints), ((void *)0), &error ))), error != 0 ) ||
         ( ((zone->orus) = (ft_mem_realloc( memory, sizeof ( *(zone->orus) ), 0, (maxPoints), ((void *)0), &error ))), error != 0 ) ||
         ( ((zone->tags) = (ft_mem_realloc( memory, sizeof ( *(zone->tags) ), 0, (maxPoints), ((void *)0), &error ))), error != 0 ) ||
         ( ((zone->contours) = (ft_mem_realloc( memory, sizeof ( *(zone->contours) ), 0, (maxContours), ((void *)0), &error ))), error != 0 ) )
    {
      tt_glyphzone_done( zone );
    }
    else
    {
      zone->max_points = maxPoints;
      zone->max_contours = maxContours;
    }

    return error;
  }
# 170 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_face_init( FT_Stream stream,
                FT_Face ttface,
                FT_Int face_index,
                FT_Int num_params,
                FT_Parameter* params )
  {
    FT_Error error;
    FT_Library library;
    SFNT_Service sfnt;
    TT_Face face = (TT_Face)ttface;


    library = face->root.driver->root.library;
    sfnt = (SFNT_Service)FT_Get_Module_Interface( library, "sfnt" );
    if ( !sfnt )
      goto Bad_Format;


    if ( ( ( error = (FT_Stream_Seek( stream, 0 )) ) != 0 ) )
      goto Exit;


    error = sfnt->init_face( stream, face, face_index, num_params, params );
    if ( error )
      goto Exit;




    if ( face->format_tag != 0x00010000L &&
         face->format_tag != 0x00020000L &&
         face->format_tag != ( ( (FT_ULong)'t' << 24 ) | ( (FT_ULong)'r' << 16 ) | ( (FT_ULong)'u' << 8 ) | (FT_ULong)'e' ) )
    {
      do {} while ( 0 );
      goto Bad_Format;
    }


    face->root.face_flags |= ( 1L << 11 );



    if ( face_index < 0 )
      return TT_Err_Ok;


    error = sfnt->load_face( stream, face, face_index, num_params, params );
    if ( error )
      goto Exit;

    error = tt_face_load_hdmx( face, stream );
    if ( error )
      goto Exit;

    if ( face->root.face_flags & ( 1L << 0 ) )
    {
# 241 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
      if ( !error )
        error = tt_face_load_loca( face, stream );
      if ( !error )
        error = tt_face_load_cvt( face, stream );
      if ( !error )
        error = tt_face_load_fpgm( face, stream );
      if ( !error )
        error = tt_face_load_prep( face, stream );



    }




    {
      FT_Bool unpatented_hinting;
      int i;



      unpatented_hinting = ( (FT_Bool)( library->debug_hooks[1] != ((void *)0) ) )
                                                                          ;

      for ( i = 0; i < num_params && !face->unpatented_hinting; i++ )
        if ( params[i].tag == ( ( (FT_ULong)'u' << 24 ) | ( (FT_ULong)'n' << 16 ) | ( (FT_ULong)'p' << 8 ) | (FT_ULong)'a' ) )
          unpatented_hinting = 1;



      if ( !unpatented_hinting )
      {
        static const char* const trick_names[] =
        {
          "DFKaiSho-SB",
          "DFKai-SB",
          "HuaTianSongTi?",
          "MingLiU",
          "PMingLiU",
          "MingLi43",
          ((void *)0)
        };
        int nn;




        for ( nn = 0; trick_names[nn] != ((void *)0); nn++ )
        {
          if ( ttface->family_name &&
               strstr( ttface->family_name, trick_names[nn] ) )
          {
            unpatented_hinting = 1;
            break;
          }
        }
      }

      ttface->internal->ignore_unpatented_hinter =
        ( (FT_Bool)( !unpatented_hinting ) );
    }





    TT_Init_Glyph_Loading( face );

  Exit:
    return error;

  Bad_Format:
    error = TT_Err_Unknown_File_Format;
    goto Exit;
  }
# 330 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
  static void
  tt_face_done( FT_Face ttface )
  {
    TT_Face face = (TT_Face)ttface;
    FT_Memory memory = face->root.memory;
    FT_Stream stream = face->root.stream;

    SFNT_Service sfnt = (SFNT_Service)face->sfnt;



    if ( face->extra.finalizer )
      face->extra.finalizer( face->extra.data );

    if ( sfnt )
      sfnt->done_face( face );


    tt_face_done_loca( face );

    tt_face_free_hdmx( face );


    do { ft_mem_free( memory, (face->cvt) ); (face->cvt) = ((void *)0); } while ( 0 );
    face->cvt_size = 0;


    (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(face->font_program) ));
    (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(face->cvt_program) ));
    face->font_program_size = 0;
    face->cvt_program_size = 0;


    tt_done_blend( memory, face->blend );
    face->blend = ((void *)0);

  }
# 391 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_size_run_fpgm( TT_Size size )
  {
    TT_Face face = (TT_Face)size->root.face;
    TT_ExecContext exec;
    FT_Error error;



    if ( size->debug )
      exec = size->context;
    else
      exec = ( (TT_Driver)((FT_Face)(face))->driver )->context;

    if ( !exec )
      return TT_Err_Could_Not_Find_Context;

    TT_Load_Context( exec, face, size );

    exec->callTop = 0;
    exec->top = 0;

    exec->period = 64;
    exec->phase = 0;
    exec->threshold = 0;

    exec->instruction_trap = 0;
    exec->F_dot_P = 0x10000L;

    {
      FT_Size_Metrics* metrics = &exec->metrics;
      TT_Size_Metrics* tt_metrics = &exec->tt_metrics;


      metrics->x_ppem = 0;
      metrics->y_ppem = 0;
      metrics->x_scale = 0;
      metrics->y_scale = 0;

      tt_metrics->ppem = 0;
      tt_metrics->scale = 0;
      tt_metrics->ratio = 0x10000L;
    }


    TT_Set_CodeRange( exec,
                      tt_coderange_font,
                      face->font_program,
                      face->font_program_size );


    TT_Clear_CodeRange( exec, tt_coderange_cvt );
    TT_Clear_CodeRange( exec, tt_coderange_glyph );

    if ( face->font_program_size > 0 )
    {
      error = TT_Goto_CodeRange( exec, tt_coderange_font, 0 );

      if ( !error )
        error = face->interpreter( exec );
    }
    else
      error = TT_Err_Ok;

    if ( !error )
      TT_Save_Context( exec, size );

    return error;
  }
# 476 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_size_run_prep( TT_Size size )
  {
    TT_Face face = (TT_Face)size->root.face;
    TT_ExecContext exec;
    FT_Error error;



    if ( size->debug )
      exec = size->context;
    else
      exec = ( (TT_Driver)((FT_Face)(face))->driver )->context;

    if ( !exec )
      return TT_Err_Could_Not_Find_Context;

    TT_Load_Context( exec, face, size );

    exec->callTop = 0;
    exec->top = 0;

    exec->instruction_trap = 0;

    TT_Set_CodeRange( exec,
                      tt_coderange_cvt,
                      face->cvt_program,
                      face->cvt_program_size );

    TT_Clear_CodeRange( exec, tt_coderange_glyph );

    if ( face->cvt_program_size > 0 )
    {
      error = TT_Goto_CodeRange( exec, tt_coderange_cvt, 0 );

      if ( !error && !size->debug )
        error = face->interpreter( exec );
    }
    else
      error = TT_Err_Ok;


    size->GS = exec->GS;

    TT_Save_Context( exec, size );

    return error;
  }






  static void
  tt_size_done_bytecode( FT_Size ftsize )
  {
    TT_Size size = (TT_Size)ftsize;
    TT_Face face = (TT_Face)ftsize->face;
    FT_Memory memory = face->root.memory;


    if ( size->debug )
    {

      size->context = ((void *)0);
      size->debug = 0;
    }

    do { ft_mem_free( memory, (size->cvt) ); (size->cvt) = ((void *)0); } while ( 0 );
    size->cvt_size = 0;


    do { ft_mem_free( memory, (size->storage) ); (size->storage) = ((void *)0); } while ( 0 );
    size->storage_size = 0;


    tt_glyphzone_done( &size->twilight );

    do { ft_mem_free( memory, (size->function_defs) ); (size->function_defs) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (size->instruction_defs) ); (size->instruction_defs) = ((void *)0); } while ( 0 );

    size->num_function_defs = 0;
    size->max_function_defs = 0;
    size->num_instruction_defs = 0;
    size->max_instruction_defs = 0;

    size->max_func = 0;
    size->max_ins = 0;

    size->bytecode_ready = 0;
    size->cvt_ready = 0;
  }




  static FT_Error
  tt_size_init_bytecode( FT_Size ftsize )
  {
    FT_Error error;
    TT_Size size = (TT_Size)ftsize;
    TT_Face face = (TT_Face)ftsize->face;
    FT_Memory memory = face->root.memory;
    FT_Int i;

    FT_UShort n_twilight;
    TT_MaxProfile* maxp = &face->max_profile;


    size->bytecode_ready = 1;
    size->cvt_ready = 0;

    size->max_function_defs = maxp->maxFunctionDefs;
    size->max_instruction_defs = maxp->maxInstructionDefs;

    size->num_function_defs = 0;
    size->num_instruction_defs = 0;

    size->max_func = 0;
    size->max_ins = 0;

    size->cvt_size = face->cvt_size;
    size->storage_size = maxp->maxStorage;


    {
      FT_Size_Metrics* metrics = &size->metrics;
      TT_Size_Metrics* metrics2 = &size->ttmetrics;

      metrics->x_ppem = 0;
      metrics->y_ppem = 0;

      metrics2->rotated = 0;
      metrics2->stretched = 0;


      for ( i = 0; i < 4; i++ )
        metrics2->compensations[i] = 0;
    }


    if ( ( ((size->function_defs) = (ft_mem_realloc( memory, sizeof ( *(size->function_defs) ), 0, (size->max_function_defs), ((void *)0), &error ))), error != 0 ) ||
         ( ((size->instruction_defs) = (ft_mem_realloc( memory, sizeof ( *(size->instruction_defs) ), 0, (size->max_instruction_defs), ((void *)0), &error ))), error != 0 ) ||
         ( ((size->cvt) = (ft_mem_realloc( memory, sizeof ( *(size->cvt) ), 0, (size->cvt_size), ((void *)0), &error ))), error != 0 ) ||
         ( ((size->storage) = (ft_mem_realloc( memory, sizeof ( *(size->storage) ), 0, (size->storage_size), ((void *)0), &error ))), error != 0 ) )
      goto Exit;


    n_twilight = maxp->maxTwilightPoints;


    n_twilight += 4;

    error = tt_glyphzone_new( memory, n_twilight, 0, &size->twilight );
    if ( error )
      goto Exit;

    size->twilight.n_points = n_twilight;

    size->GS = tt_default_graphics_state;


    {
      FT_Library library = face->root.driver->root.library;


      face->interpreter = (TT_Interpreter)
                            library->debug_hooks[0];
      if ( !face->interpreter )
        face->interpreter = (TT_Interpreter)TT_RunIns;
    }


    error = tt_size_run_fpgm( size );

  Exit:
    if ( error )
      tt_size_done_bytecode( ftsize );

    return error;
  }


  static FT_Error
  tt_size_ready_bytecode( TT_Size size )
  {
    FT_Error error = TT_Err_Ok;


    if ( !size->bytecode_ready )
    {
      error = tt_size_init_bytecode( (FT_Size)size );
      if ( error )
        goto Exit;
    }


    if ( !size->cvt_ready )
    {
      FT_UInt i;
      TT_Face face = (TT_Face) size->root.face;




      for ( i = 0; i < size->cvt_size; i++ )
        size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );


      for ( i = 0; i < (FT_UInt)size->twilight.n_points; i++ )
      {
        size->twilight.org[i].x = 0;
        size->twilight.org[i].y = 0;
        size->twilight.cur[i].x = 0;
        size->twilight.cur[i].y = 0;
      }


      for ( i = 0; i < (FT_UInt)size->storage_size; i++ )
        size->storage[i] = 0;

      size->GS = tt_default_graphics_state;

      error = tt_size_run_prep( size );
      if ( !error )
        size->cvt_ready = 1;
    }

  Exit:
    return error;
  }
# 726 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_size_init( FT_Size ttsize )
  {
    TT_Size size = (TT_Size)ttsize;
    FT_Error error = TT_Err_Ok;


    size->bytecode_ready = 0;
    size->cvt_ready = 0;


    size->ttmetrics.valid = 0;
    size->strike_index = 0xFFFFFFFFUL;

    return error;
  }
# 755 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
  static void
  tt_size_done( FT_Size ttsize )
  {
    TT_Size size = (TT_Size)ttsize;



    if ( size->bytecode_ready )
      tt_size_done_bytecode( ttsize );


    size->ttmetrics.valid = 0;
  }
# 782 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_size_reset( TT_Size size )
  {
    TT_Face face;
    FT_Error error = TT_Err_Ok;
    FT_Size_Metrics* metrics;


    size->ttmetrics.valid = 0;

    face = (TT_Face)size->root.face;

    metrics = &size->metrics;


    *metrics = size->root.metrics;

    if ( metrics->x_ppem < 1 || metrics->y_ppem < 1 )
      return TT_Err_Invalid_PPem;





    if ( face->header.Flags & 8 )
    {
      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,
                                    face->root.units_per_EM );
      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,
                                    face->root.units_per_EM );

      metrics->ascender =
        ( ((FT_MulFix( face->root.ascender, metrics->y_scale )) + 32) & ~63 );
      metrics->descender =
        ( ((FT_MulFix( face->root.descender, metrics->y_scale )) + 32) & ~63 );
      metrics->height =
        ( ((FT_MulFix( face->root.height, metrics->y_scale )) + 32) & ~63 );
      metrics->max_advance =
        ( ((FT_MulFix( face->root.max_advance_width, metrics->x_scale )) + 32) & ~63 )
                                                     ;
    }


    if ( metrics->x_ppem >= metrics->y_ppem )
    {
      size->ttmetrics.scale = metrics->x_scale;
      size->ttmetrics.ppem = metrics->x_ppem;
      size->ttmetrics.x_ratio = 0x10000L;
      size->ttmetrics.y_ratio = FT_MulDiv( metrics->y_ppem,
                                           0x10000L,
                                           metrics->x_ppem );
    }
    else
    {
      size->ttmetrics.scale = metrics->y_scale;
      size->ttmetrics.ppem = metrics->y_ppem;
      size->ttmetrics.x_ratio = FT_MulDiv( metrics->x_ppem,
                                           0x10000L,
                                           metrics->y_ppem );
      size->ttmetrics.y_ratio = 0x10000L;
    }


    size->cvt_ready = 0;


    if ( !error )
      size->ttmetrics.valid = 1;

    return error;
  }
# 869 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_driver_init( FT_Module ttdriver )
  {



    TT_Driver driver = (TT_Driver)ttdriver;


    if ( !TT_New_Context( driver ) )
      return TT_Err_Could_Not_Find_Context;







    return TT_Err_Ok;
  }
# 902 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
  static void
  tt_driver_done( FT_Module ttdriver )
  {

    TT_Driver driver = (TT_Driver)ttdriver;



    if ( driver->context )
    {
      TT_Done_Context( driver->context );
      driver->context = ((void *)0);
    }




  }
# 936 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_slot_init( FT_GlyphSlot slot )
  {
    return FT_GlyphLoader_CreateExtra( slot->internal->loader );
  }
# 26 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/truetype.c" 2


# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c" 1
# 22 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h" 1
# 22 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"
# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/freetype.h" 1
# 23 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h" 2
# 31 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"

# 52 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"
  typedef FT_Fixed FT_Angle;
# 123 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"
  extern __attribute__((dllexport)) FT_Fixed
  FT_Sin( FT_Angle angle );
# 147 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"
  extern __attribute__((dllexport)) FT_Fixed
  FT_Cos( FT_Angle angle );
# 167 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"
  extern __attribute__((dllexport)) FT_Fixed
  FT_Tan( FT_Angle angle );
# 191 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"
  extern __attribute__((dllexport)) FT_Angle
  FT_Atan2( FT_Fixed x,
            FT_Fixed y );
# 216 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"
  extern __attribute__((dllexport)) FT_Angle
  FT_Angle_Diff( FT_Angle angle1,
                 FT_Angle angle2 );
# 243 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"
  extern __attribute__((dllexport)) void
  FT_Vector_Unit( FT_Vector* vec,
                  FT_Angle angle );
# 265 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"
  extern __attribute__((dllexport)) void
  FT_Vector_Rotate( FT_Vector* vec,
                    FT_Angle angle );
# 287 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"
  extern __attribute__((dllexport)) FT_Fixed
  FT_Vector_Length( FT_Vector* vec );
# 311 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"
  extern __attribute__((dllexport)) void
  FT_Vector_Polarize( FT_Vector* vec,
                      FT_Fixed *length,
                      FT_Angle *angle );
# 337 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/include/freetype/fttrigon.h"
  extern __attribute__((dllexport)) void
  FT_Vector_From_Polar( FT_Vector* vec,
                        FT_Fixed length,
                        FT_Angle angle );





# 23 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c" 2
# 221 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  typedef void (*TInstruction_Function)( TT_ExecContext exc, FT_Long* args );
# 274 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Error
  TT_Goto_CodeRange( TT_ExecContext exec,
                     FT_Int range,
                     FT_Long IP )
  {
    TT_CodeRange* coderange;


    do {} while ( 0 );

    coderange = &exec->codeRangeTable[range - 1];

    do {} while ( 0 );





    do {} while ( 0 );

    exec->code = coderange->base;
    exec->codeSize = coderange->size;
    exec->IP = IP;
    exec->curRange = range;

    return TT_Err_Ok;
  }
# 324 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Error
  TT_Set_CodeRange( TT_ExecContext exec,
                    FT_Int range,
                    void* base,
                    FT_Long length )
  {
    do {} while ( 0 );

    exec->codeRangeTable[range - 1].base = (FT_Byte*)base;
    exec->codeRangeTable[range - 1].size = length;

    return TT_Err_Ok;
  }
# 359 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Error
  TT_Clear_CodeRange( TT_ExecContext exec,
                      FT_Int range )
  {
    do {} while ( 0 );

    exec->codeRangeTable[range - 1].base = ((void *)0);
    exec->codeRangeTable[range - 1].size = 0;

    return TT_Err_Ok;
  }
# 398 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Error
  TT_Done_Context( TT_ExecContext exec )
  {
    FT_Memory memory = exec->memory;



    exec->maxPoints = 0;
    exec->maxContours = 0;


    do { ft_mem_free( memory, (exec->stack) ); (exec->stack) = ((void *)0); } while ( 0 );
    exec->stackSize = 0;


    do { ft_mem_free( memory, (exec->callStack) ); (exec->callStack) = ((void *)0); } while ( 0 );
    exec->callSize = 0;
    exec->callTop = 0;


    do { ft_mem_free( memory, (exec->glyphIns) ); (exec->glyphIns) = ((void *)0); } while ( 0 );
    exec->glyphSize = 0;

    exec->size = ((void *)0);
    exec->face = ((void *)0);

    do { ft_mem_free( memory, (exec) ); (exec) = ((void *)0); } while ( 0 );

    return TT_Err_Ok;
  }
# 447 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Error
  Init_Context( TT_ExecContext exec,
                FT_Memory memory )
  {
    FT_Error error;


    do {} while ( 0 );

    exec->memory = memory;
    exec->callSize = 32;

    if ( ( ((exec->callStack) = (ft_mem_realloc( memory, sizeof ( *(exec->callStack) ), 0, (exec->callSize), ((void *)0), &error ))), error != 0 ) )
      goto Fail_Memory;



    exec->maxPoints = 0;
    exec->maxContours = 0;

    exec->stackSize = 0;
    exec->glyphSize = 0;

    exec->stack = ((void *)0);
    exec->glyphIns = ((void *)0);

    exec->face = ((void *)0);
    exec->size = ((void *)0);

    return TT_Err_Ok;

  Fail_Memory:
    do {} while ( 0 )
                               ;
    TT_Done_Context( exec );

    return error;
 }
# 511 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Error
  Update_Max( FT_Memory memory,
              FT_ULong* size,
              FT_Long multiplier,
              void* _pbuff,
              FT_ULong new_max )
  {
    FT_Error error;
    void** pbuff = (void**)_pbuff;


    if ( *size < new_max )
    {
      if ( ( ((*pbuff) = (ft_mem_realloc( memory, 1, (*size * multiplier), (new_max * multiplier), (*pbuff), &error ))), error != 0 ) )
        return error;
      *size = new_max;
    }

    return TT_Err_Ok;
  }
# 555 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Error
  TT_Load_Context( TT_ExecContext exec,
                   TT_Face face,
                   TT_Size size )
  {
    FT_Int i;
    FT_ULong tmp;
    TT_MaxProfile* maxp;
    FT_Error error;


    exec->face = face;
    maxp = &face->max_profile;
    exec->size = size;

    if ( size )
    {
      exec->numFDefs = size->num_function_defs;
      exec->maxFDefs = size->max_function_defs;
      exec->numIDefs = size->num_instruction_defs;
      exec->maxIDefs = size->max_instruction_defs;
      exec->FDefs = size->function_defs;
      exec->IDefs = size->instruction_defs;
      exec->tt_metrics = size->ttmetrics;
      exec->metrics = size->metrics;

      exec->maxFunc = size->max_func;
      exec->maxIns = size->max_ins;

      for ( i = 0; i < 3; i++ )
        exec->codeRangeTable[i] = size->codeRangeTable[i];


      exec->GS = size->GS;

      exec->cvtSize = size->cvt_size;
      exec->cvt = size->cvt;

      exec->storeSize = size->storage_size;
      exec->storage = size->storage;

      exec->twilight = size->twilight;
    }



    tmp = exec->stackSize;
    error = Update_Max( exec->memory,
                        &tmp,
                        sizeof ( FT_F26Dot6 ),
                        (void*)&exec->stack,
                        maxp->maxStackElements + 32 );
    exec->stackSize = (FT_UInt)tmp;
    if ( error )
      return error;

    tmp = exec->glyphSize;
    error = Update_Max( exec->memory,
                        &tmp,
                        sizeof ( FT_Byte ),
                        (void*)&exec->glyphIns,
                        maxp->maxSizeOfInstructions );
    exec->glyphSize = (FT_UShort)tmp;
    if ( error )
      return error;

    exec->pts.n_points = 0;
    exec->pts.n_contours = 0;

    exec->zp1 = exec->pts;
    exec->zp2 = exec->pts;
    exec->zp0 = exec->pts;

    exec->instruction_trap = 0;

    return TT_Err_Ok;
  }
# 654 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Error
  TT_Save_Context( TT_ExecContext exec,
                   TT_Size size )
  {
    FT_Int i;





    size->num_function_defs = exec->numFDefs;
    size->num_instruction_defs = exec->numIDefs;

    size->max_func = exec->maxFunc;
    size->max_ins = exec->maxIns;

    for ( i = 0; i < 3; i++ )
      size->codeRangeTable[i] = exec->codeRangeTable[i];

    return TT_Err_Ok;
  }
# 701 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Error
  TT_Run_Context( TT_ExecContext exec,
                  FT_Bool debug )
  {
    FT_Error error;


    if ( ( error = TT_Goto_CodeRange( exec, tt_coderange_glyph, 0 ) )
           != TT_Err_Ok )
      return error;

    exec->zp0 = exec->pts;
    exec->zp1 = exec->pts;
    exec->zp2 = exec->pts;

    exec->GS.gep0 = 1;
    exec->GS.gep1 = 1;
    exec->GS.gep2 = 1;

    exec->GS.projVector.x = 0x4000;
    exec->GS.projVector.y = 0x0000;

    exec->GS.freeVector = exec->GS.projVector;
    exec->GS.dualVector = exec->GS.projVector;


    exec->GS.both_x_axis = 1;


    exec->GS.round_state = 1;
    exec->GS.loop = 1;



    exec->top = 0;
    exec->callTop = 0;


    ( (debug) = (debug) );

    return exec->face->interpreter( exec );






  }


  const TT_GraphicsState tt_default_graphics_state =
  {
    0, 0, 0,
    { 0x4000, 0 },
    { 0x4000, 0 },
    { 0x4000, 0 },


    1,


    1, 64, 1,
    1, 68, 0, 0, 9, 3,
    0, 0, 2, 1, 1, 1
  };




  extern __attribute__((dllexport)) TT_ExecContext
  TT_New_Context( TT_Driver driver )
  {
    TT_ExecContext exec;
    FT_Memory memory;


    memory = driver->root.root.memory;
    exec = driver->context;

    if ( !driver->context )
    {
      FT_Error error;



      if ( ( ((exec) = (ft_mem_alloc( memory, (sizeof ( *(exec) )), &error ))), error != 0 ) )
        goto Exit;


      error = Init_Context( exec, memory );
      if ( error )
        goto Fail;


      driver->context = exec;
    }

  Exit:
    return driver->context;

  Fail:
    do { ft_mem_free( memory, (exec) ); (exec) = ((void *)0); } while ( 0 );

    return 0;
  }
# 830 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static
  const FT_Byte Pop_Push_Count[256] =
  {



                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 2 ),
                      ( ( 0 << 4 ) | 2 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 5 << 4 ) | 0 ),

                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 1 << 4 ) | 2 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 2 ),
                      ( ( 0 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),

                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 0 << 4 ) | 1 ),
                      ( ( 0 << 4 ) | 1 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),

                      ( ( 2 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 3 << 4 ) | 3 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),

                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),

                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),

                      ( ( 0 << 4 ) | 1 ),
                      ( ( 0 << 4 ) | 2 ),
                      ( ( 0 << 4 ) | 3 ),
                      ( ( 0 << 4 ) | 4 ),
                      ( ( 0 << 4 ) | 5 ),
                      ( ( 0 << 4 ) | 6 ),
                      ( ( 0 << 4 ) | 7 ),
                      ( ( 0 << 4 ) | 8 ),
                      ( ( 0 << 4 ) | 1 ),
                      ( ( 0 << 4 ) | 2 ),
                      ( ( 0 << 4 ) | 3 ),
                      ( ( 0 << 4 ) | 4 ),
                      ( ( 0 << 4 ) | 5 ),
                      ( ( 0 << 4 ) | 6 ),
                      ( ( 0 << 4 ) | 7 ),
                      ( ( 0 << 4 ) | 8 ),

                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),

                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 )
  };


  static
  const FT_Char opcode_length[256] =
  {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

   -1,-2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 3, 4, 5, 6, 7, 8, 9, 3, 5, 7, 9, 11,13,15,17,

    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
  };





  static FT_Int32
  TT_MulFix14( FT_Int32 a,
               FT_Int b )
  {
    FT_Int32 sign;
    FT_UInt32 ah, al, mid, lo, hi;


    sign = a ^ b;

    if ( a < 0 )
      a = -a;
    if ( b < 0 )
      b = -b;

    ah = (FT_UInt32)( ( a >> 16 ) & 0xFFFFU );
    al = (FT_UInt32)( a & 0xFFFFU );

    lo = al * b;
    mid = ah * b;
    hi = mid >> 16;
    mid = ( mid << 16 ) + ( 1 << 13 );
    lo += mid;
    if ( lo < mid )
      hi += 1;

    mid = ( lo >> 14 ) | ( hi << 18 );

    return sign >= 0 ? (FT_Int32)mid : -(FT_Int32)mid;
  }
# 1202 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Int32
  TT_DotFix14( FT_Int32 ax,
               FT_Int32 ay,
               FT_Int bx,
               FT_Int by )
  {
    FT_Int32 m, s, hi1, hi2, hi;
    FT_UInt32 l, lo1, lo2, lo;



    l = (FT_UInt32)( ( ax & 0xFFFFU ) * bx );
    m = ( ax >> 16 ) * bx;

    lo1 = l + (FT_UInt32)( m << 16 );
    hi1 = ( m >> 16 ) + ( (FT_Int32)l >> 31 ) + ( lo1 < l );


    l = (FT_UInt32)( ( ay & 0xFFFFU ) * by );
    m = ( ay >> 16 ) * by;

    lo2 = l + (FT_UInt32)( m << 16 );
    hi2 = ( m >> 16 ) + ( (FT_Int32)l >> 31 ) + ( lo2 < l );


    lo = lo1 + lo2;
    hi = hi1 + hi2 + ( lo < lo1 );


    s = hi >> 31;
    l = lo + (FT_UInt32)s;
    hi += s + ( l < lo );
    lo = l;

    l = lo + 0x2000U;
    hi += ( l < lo );

    return ( hi << 18 ) | ( l >> 14 );
  }
# 1317 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  TT_VecLen( FT_F26Dot6 X,
             FT_F26Dot6 Y )
  {
    FT_Vector v;


    v.x = X;
    v.y = Y;

    return FT_Vector_Length( &v );
  }
# 1345 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Long
  Current_Ratio( TT_ExecContext exc )
  {
    if ( !(*exc).tt_metrics.ratio )
    {

      if ( (*exc).face->unpatented_hinting )
      {
        if ( (*exc).GS.both_x_axis )
          (*exc).tt_metrics.ratio = (*exc).tt_metrics.x_ratio;
        else
          (*exc).tt_metrics.ratio = (*exc).tt_metrics.y_ratio;
      }
      else

      {
        if ( (*exc).GS.projVector.y == 0 )
          (*exc).tt_metrics.ratio = (*exc).tt_metrics.x_ratio;

        else if ( (*exc).GS.projVector.x == 0 )
          (*exc).tt_metrics.ratio = (*exc).tt_metrics.y_ratio;

        else
        {
          FT_Long x, y;


          x = FT_MulDiv( (*exc).GS.projVector.x,
                         (*exc).tt_metrics.x_ratio, 0x4000 );
          y = FT_MulDiv( (*exc).GS.projVector.y,
                         (*exc).tt_metrics.y_ratio, 0x4000 );
          (*exc).tt_metrics.ratio = TT_VecLen( x, y );
        }
      }
    }
    return (*exc).tt_metrics.ratio;
  }


  static FT_Long
  Current_Ppem( TT_ExecContext exc )
  {
    return FT_MulFix( (*exc).tt_metrics.ppem, Current_Ratio( exc ) );
  }
# 1398 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Read_CVT( TT_ExecContext exc, FT_ULong idx )
  {
    return (*exc).cvt[idx];
  }


  static FT_F26Dot6
  Read_CVT_Stretched( TT_ExecContext exc, FT_ULong idx )
  {
    return FT_MulFix( (*exc).cvt[idx], Current_Ratio( exc ) );
  }


  static void
  Write_CVT( TT_ExecContext exc, FT_ULong idx,
                      FT_F26Dot6 value )
  {
    (*exc).cvt[idx] = value;
  }


  static void
  Write_CVT_Stretched( TT_ExecContext exc, FT_ULong idx,
                                FT_F26Dot6 value )
  {
    (*exc).cvt[idx] = FT_DivFix( value, Current_Ratio( exc ) );
  }


  static void
  Move_CVT( TT_ExecContext exc, FT_ULong idx,
                     FT_F26Dot6 value )
  {
    (*exc).cvt[idx] += value;
  }


  static void
  Move_CVT_Stretched( TT_ExecContext exc, FT_ULong idx,
                               FT_F26Dot6 value )
  {
    (*exc).cvt[idx] += FT_DivFix( value, Current_Ratio( exc ) );
  }
# 1459 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Short
  GetShortIns( TT_ExecContext exc )
  {

    (*exc).IP += 2;
    return (FT_Short)( ( (*exc).code[(*exc).IP - 2] << 8 ) +
                         (*exc).code[(*exc).IP - 1] );
  }
# 1485 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Bool
  Ins_Goto_CodeRange( TT_ExecContext exc, FT_Int aRange,
                               FT_ULong aIP )
  {
    TT_CodeRange* range;


    if ( aRange < 1 || aRange > 3 )
    {
      (*exc).error = TT_Err_Bad_Argument;
      return 1;
    }

    range = &(*exc).codeRangeTable[aRange - 1];

    if ( range->base == ((void *)0) )
    {
      (*exc).error = TT_Err_Invalid_CodeRange;
      return 1;
    }





    if ( aIP > range->size )
    {
      (*exc).error = TT_Err_Code_Overflow;
      return 1;
    }

    (*exc).code = range->base;
    (*exc).codeSize = range->size;
    (*exc).IP = aIP;
    (*exc).curRange = aRange;

    return 0;
  }
# 1542 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Direct_Move( TT_ExecContext exc, TT_GlyphZone zone,
                        FT_UShort point,
                        FT_F26Dot6 distance )
  {
    FT_F26Dot6 v;



    do {} while ( 0 );


    v = (*exc).GS.freeVector.x;

    if ( v != 0 )
    {
      zone->cur[point].x += FT_MulDiv( distance,
                                       v * 0x10000L,
                                       (*exc).F_dot_P );

      zone->tags[point] |= 8;
    }

    v = (*exc).GS.freeVector.y;

    if ( v != 0 )
    {
      zone->cur[point].y += FT_MulDiv( distance,
                                       v * 0x10000L,
                                       (*exc).F_dot_P );

      zone->tags[point] |= 16;
    }
  }
# 1595 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Direct_Move_Orig( TT_ExecContext exc, TT_GlyphZone zone,
                             FT_UShort point,
                             FT_F26Dot6 distance )
  {
    FT_F26Dot6 v;



    do {} while ( 0 );


    v = (*exc).GS.freeVector.x;

    if ( v != 0 )
      zone->org[point].x += FT_MulDiv( distance,
                                       v * 0x10000L,
                                       (*exc).F_dot_P );

    v = (*exc).GS.freeVector.y;

    if ( v != 0 )
      zone->org[point].y += FT_MulDiv( distance,
                                       v * 0x10000L,
                                       (*exc).F_dot_P );
  }
# 1633 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Direct_Move_X( TT_ExecContext exc, TT_GlyphZone zone,
                          FT_UShort point,
                          FT_F26Dot6 distance )
  {
    ( (exc) = (exc) );

    zone->cur[point].x += distance;
    zone->tags[point] |= 8;
  }


  static void
  Direct_Move_Y( TT_ExecContext exc, TT_GlyphZone zone,
                          FT_UShort point,
                          FT_F26Dot6 distance )
  {
    ( (exc) = (exc) );

    zone->cur[point].y += distance;
    zone->tags[point] |= 16;
  }
# 1667 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Direct_Move_Orig_X( TT_ExecContext exc, TT_GlyphZone zone,
                               FT_UShort point,
                               FT_F26Dot6 distance )
  {
    ( (exc) = (exc) );

    zone->org[point].x += distance;
  }


  static void
  Direct_Move_Orig_Y( TT_ExecContext exc, TT_GlyphZone zone,
                               FT_UShort point,
                               FT_F26Dot6 distance )
  {
    ( (exc) = (exc) );

    zone->org[point].y += distance;
  }
# 1711 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_None( TT_ExecContext exc, FT_F26Dot6 distance,
                       FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;

    ( (exc) = (exc) );


    if ( distance >= 0 )
    {
      val = distance + compensation;
      if ( distance && val < 0 )
        val = 0;
    }
    else {
      val = distance - compensation;
      if ( val > 0 )
        val = 0;
    }
    return val;
  }
# 1751 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_To_Grid( TT_ExecContext exc, FT_F26Dot6 distance,
                          FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;

    ( (exc) = (exc) );


    if ( distance >= 0 )
    {
      val = distance + compensation + 32;
      if ( distance && val > 0 )
        val &= ~63;
      else
        val = 0;
    }
    else
    {
      val = -( ((compensation - distance) + 32) & ~63 );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }
# 1795 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_To_Half_Grid( TT_ExecContext exc, FT_F26Dot6 distance,
                               FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;

    ( (exc) = (exc) );


    if ( distance >= 0 )
    {
      val = ( (distance + compensation) & ~63 ) + 32;
      if ( distance && val < 0 )
        val = 0;
    }
    else
    {
      val = -( ( (compensation - distance) & ~63 ) + 32 );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }
# 1837 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_Down_To_Grid( TT_ExecContext exc, FT_F26Dot6 distance,
                               FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;

    ( (exc) = (exc) );


    if ( distance >= 0 )
    {
      val = distance + compensation;
      if ( distance && val > 0 )
        val &= ~63;
      else
        val = 0;
    }
    else
    {
      val = -( ( compensation - distance ) & -64 );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }
# 1881 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_Up_To_Grid( TT_ExecContext exc, FT_F26Dot6 distance,
                             FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;

    ( (exc) = (exc) );


    if ( distance >= 0 )
    {
      val = distance + compensation + 63;
      if ( distance && val > 0 )
        val &= ~63;
      else
        val = 0;
    }
    else
    {
      val = - ( ((compensation - distance) + 63) & ~63 );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }
# 1925 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_To_Double_Grid( TT_ExecContext exc, FT_F26Dot6 distance,
                                 FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;

    ( (exc) = (exc) );


    if ( distance >= 0 )
    {
      val = distance + compensation + 16;
      if ( distance && val > 0 )
        val &= ~31;
      else
        val = 0;
    }
    else
    {
      val = -( ((compensation - distance) + ((32)/2)) & ~((32)-1) );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }
# 1975 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_Super( TT_ExecContext exc, FT_F26Dot6 distance,
                        FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;


    if ( distance >= 0 )
    {
      val = ( distance - (*exc).phase + (*exc).threshold + compensation ) &
              -(*exc).period;
      if ( distance && val < 0 )
        val = 0;
      val += (*exc).phase;
    }
    else
    {
      val = -( ( (*exc).threshold - (*exc).phase - distance + compensation ) &
               -(*exc).period );
      if ( val > 0 )
        val = 0;
      val -= (*exc).phase;
    }

    return val;
  }
# 2023 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_Super_45( TT_ExecContext exc, FT_F26Dot6 distance,
                           FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;


    if ( distance >= 0 )
    {
      val = ( ( distance - (*exc).phase + (*exc).threshold + compensation ) /
                (*exc).period ) * (*exc).period;
      if ( distance && val < 0 )
        val = 0;
      val += (*exc).phase;
    }
    else
    {
      val = -( ( ( (*exc).threshold - (*exc).phase - distance + compensation ) /
                   (*exc).period ) * (*exc).period );
      if ( val > 0 )
        val = 0;
      val -= (*exc).phase;
    }

    return val;
  }
# 2062 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Compute_Round( TT_ExecContext exc, FT_Byte round_mode )
  {
    switch ( round_mode )
    {
    case 5:
      (*exc).func_round = (TT_Round_Func)Round_None;
      break;

    case 1:
      (*exc).func_round = (TT_Round_Func)Round_To_Grid;
      break;

    case 4:
      (*exc).func_round = (TT_Round_Func)Round_Up_To_Grid;
      break;

    case 3:
      (*exc).func_round = (TT_Round_Func)Round_Down_To_Grid;
      break;

    case 0:
      (*exc).func_round = (TT_Round_Func)Round_To_Half_Grid;
      break;

    case 2:
      (*exc).func_round = (TT_Round_Func)Round_To_Double_Grid;
      break;

    case 6:
      (*exc).func_round = (TT_Round_Func)Round_Super;
      break;

    case 7:
      (*exc).func_round = (TT_Round_Func)Round_Super_45;
      break;
    }
  }
# 2114 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  SetSuperRound( TT_ExecContext exc, FT_F26Dot6 GridPeriod,
                          FT_Long selector )
  {
    switch ( (FT_Int)( selector & 0xC0 ) )
    {
      case 0:
        (*exc).period = GridPeriod / 2;
        break;

      case 0x40:
        (*exc).period = GridPeriod;
        break;

      case 0x80:
        (*exc).period = GridPeriod * 2;
        break;



      case 0xC0:
        (*exc).period = GridPeriod;
        break;
    }

    switch ( (FT_Int)( selector & 0x30 ) )
    {
    case 0:
      (*exc).phase = 0;
      break;

    case 0x10:
      (*exc).phase = (*exc).period / 4;
      break;

    case 0x20:
      (*exc).phase = (*exc).period / 2;
      break;

    case 0x30:
      (*exc).phase = (*exc).period * 3 / 4;
      break;
    }

    if ( ( selector & 0x0F ) == 0 )
      (*exc).threshold = (*exc).period - 1;
    else
      (*exc).threshold = ( (FT_Int)( selector & 0x0F ) - 4 ) * (*exc).period / 8;

    (*exc).period /= 256;
    (*exc).phase /= 256;
    (*exc).threshold /= 256;
  }
# 2185 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Project( TT_ExecContext exc, FT_Pos dx,
                    FT_Pos dy )
  {

    do {} while ( 0 );


    return TT_DotFix14( dx, dy,
                        (*exc).GS.projVector.x,
                        (*exc).GS.projVector.y );
  }
# 2215 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Dual_Project( TT_ExecContext exc, FT_Pos dx,
                         FT_Pos dy )
  {
    return TT_DotFix14( dx, dy,
                        (*exc).GS.dualVector.x,
                        (*exc).GS.dualVector.y );
  }
# 2241 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Project_x( TT_ExecContext exc, FT_Pos dx,
                      FT_Pos dy )
  {
    ( (exc) = (exc) );
    ( (dy) = (dy) );

    return dx;
  }
# 2268 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Project_y( TT_ExecContext exc, FT_Pos dx,
                      FT_Pos dy )
  {
    ( (exc) = (exc) );
    ( (dx) = (dx) );

    return dy;
  }
# 2288 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Compute_Funcs( TT_ExecContext exc )
  {

    if ( (*exc).face->unpatented_hinting )
    {




      (*exc).GS.both_x_axis = (FT_Bool)( (*exc).GS.projVector.x == 0x4000 &&
                                      (*exc).GS.freeVector.x == 0x4000 );




      (*exc).GS.projVector.x = 0;
      (*exc).GS.projVector.y = 0;
      (*exc).GS.freeVector.x = 0;
      (*exc).GS.freeVector.y = 0;

      if ( (*exc).GS.both_x_axis )
      {
        (*exc).func_project = Project_x;
        (*exc).func_move = Direct_Move_X;
        (*exc).func_move_orig = Direct_Move_Orig_X;
      }
      else
      {
        (*exc).func_project = Project_y;
        (*exc).func_move = Direct_Move_Y;
        (*exc).func_move_orig = Direct_Move_Orig_Y;
      }

      if ( (*exc).GS.dualVector.x == 0x4000 )
        (*exc).func_dualproj = Project_x;
      else
      {
        if ( (*exc).GS.dualVector.y == 0x4000 )
          (*exc).func_dualproj = Project_y;
        else
          (*exc).func_dualproj = Dual_Project;
      }


      (*exc).tt_metrics.ratio = 0;

      return;
    }


    if ( (*exc).GS.freeVector.x == 0x4000 )
      (*exc).F_dot_P = (*exc).GS.projVector.x * 0x10000L;
    else
    {
      if ( (*exc).GS.freeVector.y == 0x4000 )
        (*exc).F_dot_P = (*exc).GS.projVector.y * 0x10000L;
      else
        (*exc).F_dot_P = (FT_Long)(*exc).GS.projVector.x * (*exc).GS.freeVector.x * 4 +
                      (FT_Long)(*exc).GS.projVector.y * (*exc).GS.freeVector.y * 4;
    }

    if ( (*exc).GS.projVector.x == 0x4000 )
      (*exc).func_project = (TT_Project_Func)Project_x;
    else
    {
      if ( (*exc).GS.projVector.y == 0x4000 )
        (*exc).func_project = (TT_Project_Func)Project_y;
      else
        (*exc).func_project = (TT_Project_Func)Project;
    }

    if ( (*exc).GS.dualVector.x == 0x4000 )
      (*exc).func_dualproj = (TT_Project_Func)Project_x;
    else
    {
      if ( (*exc).GS.dualVector.y == 0x4000 )
        (*exc).func_dualproj = (TT_Project_Func)Project_y;
      else
        (*exc).func_dualproj = (TT_Project_Func)Dual_Project;
    }

    (*exc).func_move = (TT_Move_Func)Direct_Move;
    (*exc).func_move_orig = (TT_Move_Func)Direct_Move_Orig;

    if ( (*exc).F_dot_P == 0x40000000L )
    {
      if ( (*exc).GS.freeVector.x == 0x4000 )
      {
        (*exc).func_move = (TT_Move_Func)Direct_Move_X;
        (*exc).func_move_orig = (TT_Move_Func)Direct_Move_Orig_X;
      }
      else
      {
        if ( (*exc).GS.freeVector.y == 0x4000 )
        {
          (*exc).func_move = (TT_Move_Func)Direct_Move_Y;
          (*exc).func_move_orig = (TT_Move_Func)Direct_Move_Orig_Y;
        }
      }
    }




    if ( ( ((*exc).F_dot_P) < 0 ? -((*exc).F_dot_P) : ((*exc).F_dot_P) ) < 0x4000000L )
      (*exc).F_dot_P = 0x40000000L;


    (*exc).tt_metrics.ratio = 0;
  }
# 2425 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Bool
  Normalize( TT_ExecContext exc, FT_F26Dot6 Vx,
                      FT_F26Dot6 Vy,
                      FT_UnitVector* R )
  {
    FT_F26Dot6 W;
    FT_Bool S1, S2;

    ( (exc) = (exc) );


    if ( ( (Vx) < 0 ? -(Vx) : (Vx) ) < 0x10000L && ( (Vy) < 0 ? -(Vy) : (Vy) ) < 0x10000L )
    {
      Vx *= 0x100;
      Vy *= 0x100;

      W = TT_VecLen( Vx, Vy );

      if ( W == 0 )
      {


        return 0;
      }

      R->x = (FT_F2Dot14)FT_MulDiv( Vx, 0x4000L, W );
      R->y = (FT_F2Dot14)FT_MulDiv( Vy, 0x4000L, W );

      return 0;
    }

    W = TT_VecLen( Vx, Vy );

    Vx = FT_MulDiv( Vx, 0x4000L, W );
    Vy = FT_MulDiv( Vy, 0x4000L, W );

    W = Vx * Vx + Vy * Vy;




    if ( Vx < 0 )
    {
      Vx = -Vx;
      S1 = 1;
    }
    else
      S1 = 0;

    if ( Vy < 0 )
    {
      Vy = -Vy;
      S2 = 1;
    }
    else
      S2 = 0;

    while ( W < 0x10000000L )
    {

      if ( Vx < Vy )
        Vx++;
      else
        Vy++;

      W = Vx * Vx + Vy * Vy;
    }

    while ( W >= 0x10004000L )
    {

      if ( Vx < Vy )
        Vx--;
      else
        Vy--;

      W = Vx * Vx + Vy * Vy;
    }




    if ( S1 )
      Vx = -Vx;

    if ( S2 )
      Vy = -Vy;

    R->x = (FT_F2Dot14)Vx;
    R->y = (FT_F2Dot14)Vy;

    return 0;
  }
# 2527 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Bool
  Ins_SxVTL( TT_ExecContext exc, FT_UShort aIdx1,
                      FT_UShort aIdx2,
                      FT_Int aOpc,
                      FT_UnitVector* Vec )
  {
    FT_Long A, B, C;
    FT_Vector* p1;
    FT_Vector* p2;


    if ( ( (FT_UInt)(aIdx1) >= (FT_UInt)((*exc).zp2.n_points) ) ||
         ( (FT_UInt)(aIdx2) >= (FT_UInt)((*exc).zp1.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return 1;
    }

    p1 = (*exc).zp1.cur + aIdx2;
    p2 = (*exc).zp2.cur + aIdx1;

    A = p1->x - p2->x;
    B = p1->y - p2->y;

    if ( ( aOpc & 1 ) != 0 )
    {
      C = B;
      B = A;
      A = -C;
    }

    Normalize( exc, A, B, Vec );

    return 0;
  }
# 4080 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MINDEX( TT_ExecContext exc, FT_Long* args )
  {
    FT_Long L, K;


    L = args[0];

    if ( L <= 0 || L > (*exc).args )
    {
      (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    K = (*exc).stack[(*exc).args - L];

    memmove( &(*exc).stack[(*exc).args - L ], &(*exc).stack[(*exc).args - L + 1], (( L - 1 )) * sizeof ( *(&(*exc).stack[(*exc).args - L ]) ) )

                              ;

    (*exc).stack[(*exc).args - 1] = K;
  }
# 4110 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ROLL( TT_ExecContext exc, FT_Long* args )
  {
    FT_Long A, B, C;

    ( (exc) = (exc) );


    A = args[2];
    B = args[1];
    C = args[0];

    args[2] = C;
    args[1] = A;
    args[0] = B;
  }
# 4137 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static FT_Bool
  SkipCode( TT_ExecContext exc )
  {
    (*exc).IP += (*exc).length;

    if ( (*exc).IP < (*exc).codeSize )
    {
      (*exc).opcode = (*exc).code[(*exc).IP];

      (*exc).length = opcode_length[(*exc).opcode];
      if ( (*exc).length < 0 )
      {
        if ( (*exc).IP + 1 > (*exc).codeSize )
          goto Fail_Overflow;
        (*exc).length = 2 - (*exc).length * (*exc).code[(*exc).IP + 1];
      }

      if ( (*exc).IP + (*exc).length <= (*exc).codeSize )
        return 0;
    }

  Fail_Overflow:
    (*exc).error = TT_Err_Code_Overflow;
    return 1;
  }
# 4170 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_IF( TT_ExecContext exc, FT_Long* args )
  {
    FT_Int nIfs;
    FT_Bool Out;


    if ( args[0] != 0 )
      return;

    nIfs = 1;
    Out = 0;

    do
    {
      if ( SkipCode( exc ) == 1 )
        return;

      switch ( (*exc).opcode )
      {
      case 0x58:
        nIfs++;
        break;

      case 0x1B:
        Out = ( (FT_Bool)( nIfs == 1 ) );
        break;

      case 0x59:
        nIfs--;
        Out = ( (FT_Bool)( nIfs == 0 ) );
        break;
      }
    } while ( Out == 0 );
  }
# 4213 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ELSE( TT_ExecContext exc, FT_Long* args )
  {
    FT_Int nIfs;

    ( (exc) = (exc) ); ( (args) = (args) );


    nIfs = 1;

    do
    {
      if ( SkipCode( exc ) == 1 )
        return;

      switch ( (*exc).opcode )
      {
      case 0x58:
        nIfs++;
        break;

      case 0x59:
        nIfs--;
        break;
      }
    } while ( nIfs != 0 );
  }
# 4257 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_FDEF( TT_ExecContext exc, FT_Long* args )
  {
    FT_ULong n;
    TT_DefRecord* rec;
    TT_DefRecord* limit;





    rec = (*exc).FDefs;
    limit = rec + (*exc).numFDefs;
    n = args[0];

    for ( ; rec < limit; rec++ )
    {
      if ( rec->opc == n )
        break;
    }

    if ( rec == limit )
    {

      if ( (*exc).numFDefs >= (*exc).maxFDefs )
      {
        (*exc).error = TT_Err_Too_Many_Function_Defs;
        return;
      }
      (*exc).numFDefs++;
    }

    rec->range = (*exc).curRange;
    rec->opc = n;
    rec->start = (*exc).IP + 1;
    rec->active = 1;

    if ( n > (*exc).maxFunc )
      (*exc).maxFunc = n;




    while ( SkipCode( exc ) == 0 )
    {
      switch ( (*exc).opcode )
      {
      case 0x89:
      case 0x2C:
        (*exc).error = TT_Err_Nested_DEFS;
        return;

      case 0x2D:
        return;
      }
    }
  }
# 4322 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ENDF( TT_ExecContext exc, FT_Long* args )
  {
    TT_CallRec* pRec;

    ( (exc) = (exc) ); ( (args) = (args) );


    if ( (*exc).callTop <= 0 )
    {
      (*exc).error = TT_Err_ENDF_In_Exec_Stream;
      return;
    }

    (*exc).callTop--;

    pRec = &(*exc).callStack[(*exc).callTop];

    pRec->Cur_Count--;

    (*exc).step_ins = 0;

    if ( pRec->Cur_Count > 0 )
    {
      (*exc).callTop++;
      (*exc).IP = pRec->Cur_Restart;
    }
    else

      Ins_Goto_CodeRange( exc, pRec->Caller_Range, pRec->Caller_IP )
                                           ;
# 4361 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  }
# 4370 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_CALL( TT_ExecContext exc, FT_Long* args )
  {
    FT_ULong F;
    TT_CallRec* pCrec;
    TT_DefRecord* def;




    F = args[0];
    if ( ( (FT_UInt)(F) >= (FT_UInt)((*exc).maxFunc + 1) ) )
      goto Fail;
# 4393 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
    def = (*exc).FDefs + F;
    if ( (*exc).maxFunc + 1 != (*exc).numFDefs || def->opc != F )
    {

      TT_DefRecord* limit;


      def = (*exc).FDefs;
      limit = def + (*exc).numFDefs;

      while ( def < limit && def->opc != F )
        def++;

      if ( def == limit )
        goto Fail;
    }


    if ( !def->active )
      goto Fail;


    if ( (*exc).callTop >= (*exc).callSize )
    {
      (*exc).error = TT_Err_Stack_Overflow;
      return;
    }

    pCrec = (*exc).callStack + (*exc).callTop;

    pCrec->Caller_Range = (*exc).curRange;
    pCrec->Caller_IP = (*exc).IP + 1;
    pCrec->Cur_Count = 1;
    pCrec->Cur_Restart = def->start;

    (*exc).callTop++;

    Ins_Goto_CodeRange( exc, def->range, def->start )
                                    ;

    (*exc).step_ins = 0;
    return;

  Fail:
    (*exc).error = TT_Err_Invalid_Reference;
  }
# 4447 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_LOOPCALL( TT_ExecContext exc, FT_Long* args )
  {
    FT_ULong F;
    TT_CallRec* pCrec;
    TT_DefRecord* def;



    F = args[1];
    if ( ( (FT_UInt)(F) >= (FT_UInt)((*exc).maxFunc + 1) ) )
      goto Fail;
# 4469 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
    def = (*exc).FDefs + F;
    if ( (*exc).maxFunc + 1 != (*exc).numFDefs || def->opc != F )
    {

      TT_DefRecord* limit;


      def = (*exc).FDefs;
      limit = def + (*exc).numFDefs;

      while ( def < limit && def->opc != F )
        def++;

      if ( def == limit )
        goto Fail;
    }


    if ( !def->active )
      goto Fail;


    if ( (*exc).callTop >= (*exc).callSize )
    {
      (*exc).error = TT_Err_Stack_Overflow;
      return;
    }

    if ( args[0] > 0 )
    {
      pCrec = (*exc).callStack + (*exc).callTop;

      pCrec->Caller_Range = (*exc).curRange;
      pCrec->Caller_IP = (*exc).IP + 1;
      pCrec->Cur_Count = (FT_Int)args[0];
      pCrec->Cur_Restart = def->start;

      (*exc).callTop++;

      Ins_Goto_CodeRange( exc, def->range, def->start );

      (*exc).step_ins = 0;
    }
    return;

  Fail:
    (*exc).error = TT_Err_Invalid_Reference;
  }
# 4525 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_IDEF( TT_ExecContext exc, FT_Long* args )
  {
    TT_DefRecord* def;
    TT_DefRecord* limit;




    def = (*exc).IDefs;
    limit = def + (*exc).numIDefs;

    for ( ; def < limit; def++ )
      if ( def->opc == (FT_ULong)args[0] )
        break;

    if ( def == limit )
    {

      if ( (*exc).numIDefs >= (*exc).maxIDefs )
      {
        (*exc).error = TT_Err_Too_Many_Instruction_Defs;
        return;
      }
      (*exc).numIDefs++;
    }

    def->opc = args[0];
    def->start = (*exc).IP+1;
    def->range = (*exc).curRange;
    def->active = 1;

    if ( (FT_ULong)args[0] > (*exc).maxIns )
      (*exc).maxIns = args[0];




    while ( SkipCode( exc ) == 0 )
    {
      switch ( (*exc).opcode )
      {
      case 0x89:
      case 0x2C:
        (*exc).error = TT_Err_Nested_DEFS;
        return;
      case 0x2D:
        return;
      }
    }
  }
# 4593 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_NPUSHB( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort L, K;


    L = (FT_UShort)(*exc).code[(*exc).IP + 1];

    if ( ( (FT_UInt)(L) >= (FT_UInt)((*exc).stackSize + 1 - (*exc).top) ) )
    {
      (*exc).error = TT_Err_Stack_Overflow;
      return;
    }

    for ( K = 1; K <= L; K++ )
      args[K - 1] = (*exc).code[(*exc).IP + K + 1];

    (*exc).new_top += L;
  }
# 4620 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_NPUSHW( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort L, K;


    L = (FT_UShort)(*exc).code[(*exc).IP + 1];

    if ( ( (FT_UInt)(L) >= (FT_UInt)((*exc).stackSize + 1 - (*exc).top) ) )
    {
      (*exc).error = TT_Err_Stack_Overflow;
      return;
    }

    (*exc).IP += 2;

    for ( K = 0; K < L; K++ )
      args[K] = GetShortIns( exc );

    (*exc).step_ins = 0;
    (*exc).new_top += L;
  }
# 4650 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_PUSHB( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort L, K;


    L = (FT_UShort)( (*exc).opcode - 0xB0 + 1 );

    if ( ( (FT_UInt)(L) >= (FT_UInt)((*exc).stackSize + 1 - (*exc).top) ) )
    {
      (*exc).error = TT_Err_Stack_Overflow;
      return;
    }

    for ( K = 1; K <= L; K++ )
      args[K - 1] = (*exc).code[(*exc).IP + K];
  }
# 4675 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_PUSHW( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort L, K;


    L = (FT_UShort)( (*exc).opcode - 0xB8 + 1 );

    if ( ( (FT_UInt)(L) >= (FT_UInt)((*exc).stackSize + 1 - (*exc).top) ) )
    {
      (*exc).error = TT_Err_Stack_Overflow;
      return;
    }

    (*exc).IP++;

    for ( K = 0; K < L; K++ )
      args[K] = GetShortIns( exc );

    (*exc).step_ins = 0;
  }
# 4716 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_GC( TT_ExecContext exc, FT_Long* args )
  {
    FT_ULong L;
    FT_F26Dot6 R;


    L = (FT_ULong)args[0];

    if ( ( (FT_UInt)(L) >= (FT_UInt)((*exc).zp2.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
      {
        (*exc).error = TT_Err_Invalid_Reference;
        return;
      }
      else
        R = 0;
    }
    else
    {
      if ( (*exc).opcode & 1 )
        R = (*exc).func_dualproj( exc, (&(*exc).zp2.org[L])->x, (&(*exc).zp2.org[L])->y );
      else
        R = (*exc).func_project( exc, (&(*exc).zp2.cur[L])->x, (&(*exc).zp2.cur[L])->y );
    }

    args[0] = R;
  }
# 4757 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SCFS( TT_ExecContext exc, FT_Long* args )
  {
    FT_Long K;
    FT_UShort L;


    L = (FT_UShort)args[0];

    if ( ( (FT_UInt)(L) >= (FT_UInt)((*exc).zp2.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    K = (*exc).func_project( exc, (&(*exc).zp2.cur[L])->x, (&(*exc).zp2.cur[L])->y );

    (*exc).func_move( exc, &(*exc).zp2, L, args[1] - K );



    if ( (*exc).GS.gep2 == 0 )
      (*exc).zp2.org[L] = (*exc).zp2.cur[L];
  }
# 4799 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MD( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort K, L;
    FT_F26Dot6 D;


    K = (FT_UShort)args[1];
    L = (FT_UShort)args[0];

    if( ( (FT_UInt)(L) >= (FT_UInt)((*exc).zp0.n_points) ) ||
        ( (FT_UInt)(K) >= (FT_UInt)((*exc).zp1.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
      {
        (*exc).error = TT_Err_Invalid_Reference;
        return;
      }
      D = 0;
    }
    else
    {
      if ( (*exc).opcode & 1 )
        D = (*exc).func_project( exc, ((*exc).zp0.cur + L)->x - ((*exc).zp1.cur + K)->x, ((*exc).zp0.cur + L)->y - ((*exc).zp1.cur + K)->y );
      else
      {
        FT_Vector* vec1 = (*exc).zp0.orus + L;
        FT_Vector* vec2 = (*exc).zp1.orus + K;


        if ( (*exc).metrics.x_scale == (*exc).metrics.y_scale )
        {

          D = (*exc).func_dualproj( exc, (vec1)->x - (vec2)->x, (vec1)->y - (vec2)->y );
          D = FT_MulFix( D, (*exc).metrics.x_scale );
        }
        else
        {
          FT_Vector vec;


          vec.x = FT_MulFix( vec1->x - vec2->x, (*exc).metrics.x_scale );
          vec.y = FT_MulFix( vec1->y - vec2->y, (*exc).metrics.y_scale );

          D = (*exc).func_dualproj( exc, (&vec)->x, (&vec)->y );
        }
      }
    }

    args[0] = D;
  }
# 4858 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SDPVTL( TT_ExecContext exc, FT_Long* args )
  {
    FT_Long A, B, C;
    FT_UShort p1, p2;


    p1 = (FT_UShort)args[1];
    p2 = (FT_UShort)args[0];

    if ( ( (FT_UInt)(p2) >= (FT_UInt)((*exc).zp1.n_points) ) ||
         ( (FT_UInt)(p1) >= (FT_UInt)((*exc).zp2.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    {
      FT_Vector* v1 = (*exc).zp1.org + p2;
      FT_Vector* v2 = (*exc).zp2.org + p1;


      A = v1->x - v2->x;
      B = v1->y - v2->y;
    }

    if ( ( (*exc).opcode & 1 ) != 0 )
    {
      C = B;
      B = A;
      A = -C;
    }

    Normalize( exc, A, B, &(*exc).GS.dualVector );

    {
      FT_Vector* v1 = (*exc).zp1.cur + p2;
      FT_Vector* v2 = (*exc).zp2.cur + p1;


      A = v1->x - v2->x;
      B = v1->y - v2->y;
    }

    if ( ( (*exc).opcode & 1 ) != 0 )
    {
      C = B;
      B = A;
      A = -C;
    }

    Normalize( exc, A, B, &(*exc).GS.projVector );

    if ( (*exc).face->unpatented_hinting ) { (*exc).GS.freeVector.x = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0x4000 : 0 ); (*exc).GS.freeVector.y = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0 : 0x4000 ); };

    Compute_Funcs( exc );
  }
# 4924 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SZP0( TT_ExecContext exc, FT_Long* args )
  {
    switch ( (FT_Int)args[0] )
    {
    case 0:
      (*exc).zp0 = (*exc).twilight;
      break;

    case 1:
      (*exc).zp0 = (*exc).pts;
      break;

    default:
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    (*exc).GS.gep0 = (FT_UShort)args[0];
  }
# 4953 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SZP1( TT_ExecContext exc, FT_Long* args )
  {
    switch ( (FT_Int)args[0] )
    {
    case 0:
      (*exc).zp1 = (*exc).twilight;
      break;

    case 1:
      (*exc).zp1 = (*exc).pts;
      break;

    default:
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    (*exc).GS.gep1 = (FT_UShort)args[0];
  }
# 4982 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SZP2( TT_ExecContext exc, FT_Long* args )
  {
    switch ( (FT_Int)args[0] )
    {
    case 0:
      (*exc).zp2 = (*exc).twilight;
      break;

    case 1:
      (*exc).zp2 = (*exc).pts;
      break;

    default:
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    (*exc).GS.gep2 = (FT_UShort)args[0];
  }
# 5011 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SZPS( TT_ExecContext exc, FT_Long* args )
  {
    switch ( (FT_Int)args[0] )
    {
    case 0:
      (*exc).zp0 = (*exc).twilight;
      break;

    case 1:
      (*exc).zp0 = (*exc).pts;
      break;

    default:
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    (*exc).zp1 = (*exc).zp0;
    (*exc).zp2 = (*exc).zp0;

    (*exc).GS.gep0 = (FT_UShort)args[0];
    (*exc).GS.gep1 = (FT_UShort)args[0];
    (*exc).GS.gep2 = (FT_UShort)args[0];
  }
# 5045 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_INSTCTRL( TT_ExecContext exc, FT_Long* args )
  {
    FT_Long K, L;


    K = args[1];
    L = args[0];

    if ( K < 1 || K > 2 )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    if ( L != 0 )
        L = K;

    (*exc).GS.instruct_control = ( (FT_Bool)( ( (FT_Byte)(*exc).GS.instruct_control & ~(FT_Byte)K ) | (FT_Byte)L ) )
                                                                       ;
  }
# 5075 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SCANCTRL( TT_ExecContext exc, FT_Long* args )
  {
    FT_Int A;



    A = (FT_Int)( args[0] & 0xFF );

    if ( A == 0xFF )
    {
      (*exc).GS.scan_control = 1;
      return;
    }
    else if ( A == 0 )
    {
      (*exc).GS.scan_control = 0;
      return;
    }

    if ( ( args[0] & 0x100 ) != 0 && (*exc).tt_metrics.ppem < A )
      (*exc).GS.scan_control = 1;

    if ( ( args[0] & 0x200 ) != 0 && (*exc).tt_metrics.rotated )
      (*exc).GS.scan_control = 1;

    if ( ( args[0] & 0x400 ) != 0 && (*exc).tt_metrics.stretched )
      (*exc).GS.scan_control = 1;

    if ( ( args[0] & 0x800 ) != 0 && (*exc).tt_metrics.ppem >= A )
      (*exc).GS.scan_control = 0;

    if ( ( args[0] & 0x1000 ) != 0 && (*exc).tt_metrics.rotated )
      (*exc).GS.scan_control = 0;

    if ( ( args[0] & 0x2000 ) != 0 && (*exc).tt_metrics.stretched )
      (*exc).GS.scan_control = 0;
  }
# 5121 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SCANTYPE( TT_ExecContext exc, FT_Long* args )
  {
    if ( args[0] >= 0 )
      (*exc).GS.scan_type = (FT_Int)args[0];
  }
# 5144 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_FLIPPT( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort point;

    ( (exc) = (exc) ); ( (args) = (args) );


    if ( (*exc).top < (*exc).GS.loop )
    {
      (*exc).error = TT_Err_Too_Few_Arguments;
      return;
    }

    while ( (*exc).GS.loop > 0 )
    {
      (*exc).args--;

      point = (FT_UShort)(*exc).stack[(*exc).args];

      if ( ( (FT_UInt)(point) >= (FT_UInt)((*exc).pts.n_points) ) )
      {
        if ( (*exc).pedantic_hinting )
        {
          (*exc).error = TT_Err_Invalid_Reference;
          return;
        }
      }
      else
        (*exc).pts.tags[point] ^= 1;

      (*exc).GS.loop--;
    }

    (*exc).GS.loop = 1;
    (*exc).new_top = (*exc).args;
  }
# 5189 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_FLIPRGON( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort I, K, L;


    K = (FT_UShort)args[1];
    L = (FT_UShort)args[0];

    if ( ( (FT_UInt)(K) >= (FT_UInt)((*exc).pts.n_points) ) ||
         ( (FT_UInt)(L) >= (FT_UInt)((*exc).pts.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    for ( I = L; I <= K; I++ )
      (*exc).pts.tags[I] |= 1;
  }
# 5217 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_FLIPRGOFF( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort I, K, L;


    K = (FT_UShort)args[1];
    L = (FT_UShort)args[0];

    if ( ( (FT_UInt)(K) >= (FT_UInt)((*exc).pts.n_points) ) ||
         ( (FT_UInt)(L) >= (FT_UInt)((*exc).pts.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    for ( I = L; I <= K; I++ )
      (*exc).pts.tags[I] &= ~1;
  }


  static FT_Bool
  Compute_Point_Displacement( TT_ExecContext exc, FT_F26Dot6* x,
                                       FT_F26Dot6* y,
                                       TT_GlyphZone zone,
                                       FT_UShort* refp )
  {
    TT_GlyphZoneRec zp;
    FT_UShort p;
    FT_F26Dot6 d;


    if ( (*exc).opcode & 1 )
    {
      zp = (*exc).zp0;
      p = (*exc).GS.rp1;
    }
    else
    {
      zp = (*exc).zp1;
      p = (*exc).GS.rp2;
    }

    if ( ( (FT_UInt)(p) >= (FT_UInt)(zp.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      *refp = 0;
      return 1;
    }

    *zone = zp;
    *refp = p;

    d = (*exc).func_project( exc, (zp.cur + p)->x - (zp.org + p)->x, (zp.cur + p)->y - (zp.org + p)->y );


    if ( (*exc).face->unpatented_hinting )
    {
      if ( (*exc).GS.both_x_axis )
      {
        *x = d;
        *y = 0;
      }
      else
      {
        *x = 0;
        *y = d;
      }
    }
    else

    {
      *x = FT_MulDiv( d,
                      (FT_Long)(*exc).GS.freeVector.x * 0x10000L,
                      (*exc).F_dot_P );
      *y = FT_MulDiv( d,
                      (FT_Long)(*exc).GS.freeVector.y * 0x10000L,
                      (*exc).F_dot_P );
    }

    return 0;
  }


  static void
  Move_Zp2_Point( TT_ExecContext exc, FT_UShort point,
                           FT_F26Dot6 dx,
                           FT_F26Dot6 dy,
                           FT_Bool touch )
  {

    if ( (*exc).face->unpatented_hinting )
    {
      if ( (*exc).GS.both_x_axis )
      {
        (*exc).zp2.cur[point].x += dx;
        if ( touch )
          (*exc).zp2.tags[point] |= 8;
      }
      else
      {
        (*exc).zp2.cur[point].y += dy;
        if ( touch )
          (*exc).zp2.tags[point] |= 16;
      }
      return;
    }


    if ( (*exc).GS.freeVector.x != 0 )
    {
      (*exc).zp2.cur[point].x += dx;
      if ( touch )
        (*exc).zp2.tags[point] |= 8;
    }

    if ( (*exc).GS.freeVector.y != 0 )
    {
      (*exc).zp2.cur[point].y += dy;
      if ( touch )
        (*exc).zp2.tags[point] |= 16;
    }
  }
# 5350 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SHP( TT_ExecContext exc, FT_Long* args )
  {
    TT_GlyphZoneRec zp;
    FT_UShort refp;

    FT_F26Dot6 dx,
                     dy;
    FT_UShort point;

    ( (exc) = (exc) ); ( (args) = (args) );


    if ( (*exc).top < (*exc).GS.loop )
    {
      (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )
      return;

    while ( (*exc).GS.loop > 0 )
    {
      (*exc).args--;
      point = (FT_UShort)(*exc).stack[(*exc).args];

      if ( ( (FT_UInt)(point) >= (FT_UInt)((*exc).zp2.n_points) ) )
      {
        if ( (*exc).pedantic_hinting )
        {
          (*exc).error = TT_Err_Invalid_Reference;
          return;
        }
      }
      else

        Move_Zp2_Point( exc, point, dx, dy, 1 );

      (*exc).GS.loop--;
    }

    (*exc).GS.loop = 1;
    (*exc).new_top = (*exc).args;
  }
# 5403 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SHC( TT_ExecContext exc, FT_Long* args )
  {
    TT_GlyphZoneRec zp;
    FT_UShort refp;
    FT_F26Dot6 dx,
                    dy;

    FT_Short contour;
    FT_UShort first_point, last_point, i;


    contour = (FT_UShort)args[0];

    if ( ( (FT_UInt)(contour) >= (FT_UInt)((*exc).pts.n_contours) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )
      return;

    if ( contour == 0 )
      first_point = 0;
    else
      first_point = (FT_UShort)( (*exc).pts.contours[contour - 1] + 1 -
                                 (*exc).pts.first_point );

    last_point = (FT_UShort)( (*exc).pts.contours[contour] -
                              (*exc).pts.first_point );



    if ( ( (FT_UInt)(last_point) >= (FT_UInt)((*exc).zp2.n_points) ) )
    {
      if ( (*exc).zp2.n_points > 0 )
        last_point = (FT_UShort)((*exc).zp2.n_points - 1);
      else
        last_point = 0;
    }


    for ( i = first_point; i <= last_point; i++ )
    {
      if ( zp.cur != (*exc).zp2.cur || refp != i )
        Move_Zp2_Point( exc, i, dx, dy, 1 );
    }
  }
# 5461 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SHZ( TT_ExecContext exc, FT_Long* args )
  {
    TT_GlyphZoneRec zp;
    FT_UShort refp;
    FT_F26Dot6 dx,
                    dy;

    FT_UShort last_point, i;


    if ( ( (FT_UInt)(args[0]) >= (FT_UInt)(2) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )
      return;





    if ( (*exc).GS.gep2 == 0 && (*exc).zp2.n_points > 0 )
      last_point = (FT_UShort)( (*exc).zp2.n_points - 1 );
    else if ( (*exc).GS.gep2 == 1 && (*exc).zp2.n_contours > 0 )
      last_point = (FT_UShort)( (*exc).zp2.contours[(*exc).zp2.n_contours - 1] );
    else
      last_point = 0;


    for ( i = 0; i <= last_point; i++ )
    {
      if ( zp.cur != (*exc).zp2.cur || refp != i )
        Move_Zp2_Point( exc, i, dx, dy, 0 );
    }
  }
# 5508 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SHPIX( TT_ExecContext exc, FT_Long* args )
  {
    FT_F26Dot6 dx, dy;
    FT_UShort point;


    if ( (*exc).top < (*exc).GS.loop + 1 )
    {
      (*exc).error = TT_Err_Invalid_Reference;
      return;
    }


    if ( (*exc).face->unpatented_hinting )
    {
      if ( (*exc).GS.both_x_axis )
      {
        dx = TT_MulFix14( args[0], 0x4000 );
        dy = 0;
      }
      else
      {
        dx = 0;
        dy = TT_MulFix14( args[0], 0x4000 );
      }
    }
    else

    {
      dx = TT_MulFix14( args[0], (*exc).GS.freeVector.x );
      dy = TT_MulFix14( args[0], (*exc).GS.freeVector.y );
    }

    while ( (*exc).GS.loop > 0 )
    {
      (*exc).args--;

      point = (FT_UShort)(*exc).stack[(*exc).args];

      if ( ( (FT_UInt)(point) >= (FT_UInt)((*exc).zp2.n_points) ) )
      {
        if ( (*exc).pedantic_hinting )
        {
          (*exc).error = TT_Err_Invalid_Reference;
          return;
        }
      }
      else
        Move_Zp2_Point( exc, point, dx, dy, 1 );

      (*exc).GS.loop--;
    }

    (*exc).GS.loop = 1;
    (*exc).new_top = (*exc).args;
  }
# 5573 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MSIRP( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort point;
    FT_F26Dot6 distance;


    point = (FT_UShort)args[0];

    if ( ( (FT_UInt)(point) >= (FT_UInt)((*exc).zp1.n_points) ) ||
         ( (FT_UInt)((*exc).GS.rp0) >= (FT_UInt)((*exc).zp0.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }


    if ( (*exc).GS.gep1 == 0 )

    {
      (*exc).zp1.org[point] = (*exc).zp0.org[(*exc).GS.rp0];
      (*exc).func_move_orig( exc, &(*exc).zp1, point, args[1] );
      (*exc).zp1.cur[point] = (*exc).zp1.org[point];
    }

    distance = (*exc).func_project( exc, ((*exc).zp1.cur + point)->x - ((*exc).zp0.cur + (*exc).GS.rp0)->x, ((*exc).zp1.cur + point)->y - ((*exc).zp0.cur + (*exc).GS.rp0)->y )
                                                           ;

    (*exc).func_move( exc, &(*exc).zp1, point, args[1] - distance );

    (*exc).GS.rp1 = (*exc).GS.rp0;
    (*exc).GS.rp2 = point;

    if ( ( (*exc).opcode & 1 ) != 0 )
      (*exc).GS.rp0 = point;
  }
# 5618 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MDAP( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort point;
    FT_F26Dot6 cur_dist,
                distance;


    point = (FT_UShort)args[0];

    if ( ( (FT_UInt)(point) >= (FT_UInt)((*exc).zp0.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }



    if ( ( (*exc).opcode & 1 ) != 0 )
    {
      cur_dist = (*exc).func_project( exc, (&(*exc).zp0.cur[point])->x, (&(*exc).zp0.cur[point])->y );
      distance = (*exc).func_round( exc, cur_dist, (*exc).tt_metrics.compensations[0] )
                                                                   - cur_dist;
    }
    else
      distance = 0;

    (*exc).func_move( exc, &(*exc).zp0, point, distance );

    (*exc).GS.rp0 = point;
    (*exc).GS.rp1 = point;
  }
# 5659 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MIAP( TT_ExecContext exc, FT_Long* args )
  {
    FT_ULong cvtEntry;
    FT_UShort point;
    FT_F26Dot6 distance,
                org_dist;


    cvtEntry = (FT_ULong)args[1];
    point = (FT_UShort)args[0];

    if ( ( (FT_UInt)(point) >= (FT_UInt)((*exc).zp0.n_points) ) ||
         ( (FT_UInt)(cvtEntry) >= (FT_UInt)((*exc).cvtSize) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }
# 5701 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
    distance = (*exc).func_read_cvt( exc, cvtEntry );

    if ( (*exc).GS.gep0 == 0 )
    {
      (*exc).zp0.org[point].x = TT_MulFix14( distance, (*exc).GS.freeVector.x );
      (*exc).zp0.org[point].y = TT_MulFix14( distance, (*exc).GS.freeVector.y ),
      (*exc).zp0.cur[point] = (*exc).zp0.org[point];
    }

    org_dist = (*exc).func_project( exc, (&(*exc).zp0.cur[point])->x, (&(*exc).zp0.cur[point])->y );

    if ( ( (*exc).opcode & 1 ) != 0 )
    {
      if ( ( (distance - org_dist) < 0 ? -(distance - org_dist) : (distance - org_dist) ) > (*exc).GS.control_value_cutin )
        distance = org_dist;

      distance = (*exc).func_round( exc, distance, (*exc).tt_metrics.compensations[0] );
    }

    (*exc).func_move( exc, &(*exc).zp0, point, distance - org_dist );

    (*exc).GS.rp0 = point;
    (*exc).GS.rp1 = point;
  }
# 5733 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MDRP( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort point;
    FT_F26Dot6 org_dist, distance;


    point = (FT_UShort)args[0];

    if ( ( (FT_UInt)(point) >= (FT_UInt)((*exc).zp1.n_points) ) ||
         ( (FT_UInt)((*exc).GS.rp0) >= (FT_UInt)((*exc).zp0.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }






    if ( (*exc).GS.gep0 == 0 || (*exc).GS.gep1 == 0 )
    {
      FT_Vector* vec1 = &(*exc).zp1.org[point];
      FT_Vector* vec2 = &(*exc).zp0.org[(*exc).GS.rp0];


      org_dist = (*exc).func_dualproj( exc, (vec1)->x - (vec2)->x, (vec1)->y - (vec2)->y );
    }
    else
    {
      FT_Vector* vec1 = &(*exc).zp1.orus[point];
      FT_Vector* vec2 = &(*exc).zp0.orus[(*exc).GS.rp0];


      if ( (*exc).metrics.x_scale == (*exc).metrics.y_scale )
      {

        org_dist = (*exc).func_dualproj( exc, (vec1)->x - (vec2)->x, (vec1)->y - (vec2)->y );
        org_dist = FT_MulFix( org_dist, (*exc).metrics.x_scale );
      }
      else
      {
        FT_Vector vec;


        vec.x = FT_MulFix( vec1->x - vec2->x, (*exc).metrics.x_scale );
        vec.y = FT_MulFix( vec1->y - vec2->y, (*exc).metrics.y_scale );

        org_dist = (*exc).func_dualproj( exc, (&vec)->x, (&vec)->y );
      }
    }



    if ( ( (org_dist - (*exc).GS.single_width_value) < 0 ? -(org_dist - (*exc).GS.single_width_value) : (org_dist - (*exc).GS.single_width_value) ) <
         (*exc).GS.single_width_cutin )
    {
      if ( org_dist >= 0 )
        org_dist = (*exc).GS.single_width_value;
      else
        org_dist = -(*exc).GS.single_width_value;
    }



    if ( ( (*exc).opcode & 4 ) != 0 )
      distance = (*exc).func_round( exc, org_dist, (*exc).tt_metrics.compensations[(*exc).opcode & 3] )

                                                                 ;
    else
      distance = Round_None( exc, org_dist, (*exc).tt_metrics.compensations[(*exc).opcode & 3] )

                                                                 ;



    if ( ( (*exc).opcode & 8 ) != 0 )
    {
      if ( org_dist >= 0 )
      {
        if ( distance < (*exc).GS.minimum_distance )
          distance = (*exc).GS.minimum_distance;
      }
      else
      {
        if ( distance > -(*exc).GS.minimum_distance )
          distance = -(*exc).GS.minimum_distance;
      }
    }



    org_dist = (*exc).func_project( exc, ((*exc).zp1.cur + point)->x - ((*exc).zp0.cur + (*exc).GS.rp0)->x, ((*exc).zp1.cur + point)->y - ((*exc).zp0.cur + (*exc).GS.rp0)->y )
                                                           ;

    (*exc).func_move( exc, &(*exc).zp1, point, distance - org_dist );

    (*exc).GS.rp1 = (*exc).GS.rp0;
    (*exc).GS.rp2 = point;

    if ( ( (*exc).opcode & 16 ) != 0 )
      (*exc).GS.rp0 = point;
  }
# 5846 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MIRP( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort point;
    FT_ULong cvtEntry;

    FT_F26Dot6 cvt_dist,
                distance,
                cur_dist,
                org_dist;


    point = (FT_UShort)args[0];
    cvtEntry = (FT_ULong)( args[1] + 1 );



    if ( ( (FT_UInt)(point) >= (FT_UInt)((*exc).zp1.n_points) ) ||
         ( (FT_UInt)(cvtEntry) >= (FT_UInt)((*exc).cvtSize + 1) ) ||
         ( (FT_UInt)((*exc).GS.rp0) >= (FT_UInt)((*exc).zp0.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    if ( !cvtEntry )
      cvt_dist = 0;
    else
      cvt_dist = (*exc).func_read_cvt( exc, cvtEntry - 1 );



    if ( ( (cvt_dist - (*exc).GS.single_width_value) < 0 ? -(cvt_dist - (*exc).GS.single_width_value) : (cvt_dist - (*exc).GS.single_width_value) ) <
         (*exc).GS.single_width_cutin )
    {
      if ( cvt_dist >= 0 )
        cvt_dist = (*exc).GS.single_width_value;
      else
        cvt_dist = -(*exc).GS.single_width_value;
    }



    if ( (*exc).GS.gep1 == 0 )
    {
      (*exc).zp1.org[point].x = (*exc).zp0.org[(*exc).GS.rp0].x +
                             TT_MulFix14( cvt_dist, (*exc).GS.freeVector.x );

      (*exc).zp1.org[point].y = (*exc).zp0.org[(*exc).GS.rp0].y +
                             TT_MulFix14( cvt_dist, (*exc).GS.freeVector.y );

      (*exc).zp1.cur[point] = (*exc).zp0.cur[point];
    }

    org_dist = (*exc).func_dualproj( exc, (&(*exc).zp1.org[point])->x - (&(*exc).zp0.org[(*exc).GS.rp0])->x, (&(*exc).zp1.org[point])->y - (&(*exc).zp0.org[(*exc).GS.rp0])->y )
                                                            ;
    cur_dist = (*exc).func_project( exc, (&(*exc).zp1.cur[point])->x - (&(*exc).zp0.cur[(*exc).GS.rp0])->x, (&(*exc).zp1.cur[point])->y - (&(*exc).zp0.cur[(*exc).GS.rp0])->y )
                                                            ;



    if ( (*exc).GS.auto_flip )
    {
      if ( ( org_dist ^ cvt_dist ) < 0 )
        cvt_dist = -cvt_dist;
    }



    if ( ( (*exc).opcode & 4 ) != 0 )
    {



      if ( (*exc).GS.gep0 == (*exc).GS.gep1 )
        if ( ( (cvt_dist - org_dist) < 0 ? -(cvt_dist - org_dist) : (cvt_dist - org_dist) ) >= (*exc).GS.control_value_cutin )
          cvt_dist = org_dist;

      distance = (*exc).func_round( exc, cvt_dist, (*exc).tt_metrics.compensations[(*exc).opcode & 3] )

                                                                 ;
    }
    else
      distance = Round_None( exc, cvt_dist, (*exc).tt_metrics.compensations[(*exc).opcode & 3] )

                                                                 ;



    if ( ( (*exc).opcode & 8 ) != 0 )
    {
      if ( org_dist >= 0 )
      {
        if ( distance < (*exc).GS.minimum_distance )
          distance = (*exc).GS.minimum_distance;
      }
      else
      {
        if ( distance > -(*exc).GS.minimum_distance )
          distance = -(*exc).GS.minimum_distance;
      }
    }

    (*exc).func_move( exc, &(*exc).zp1, point, distance - cur_dist );

    (*exc).GS.rp1 = (*exc).GS.rp0;

    if ( ( (*exc).opcode & 16 ) != 0 )
      (*exc).GS.rp0 = point;


    (*exc).GS.rp2 = point;
  }
# 5968 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ALIGNRP( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort point;
    FT_F26Dot6 distance;

    ( (exc) = (exc) ); ( (args) = (args) );


    if ( (*exc).top < (*exc).GS.loop ||
         ( (FT_UInt)((*exc).GS.rp0) >= (FT_UInt)((*exc).zp0.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    while ( (*exc).GS.loop > 0 )
    {
      (*exc).args--;

      point = (FT_UShort)(*exc).stack[(*exc).args];

      if ( ( (FT_UInt)(point) >= (FT_UInt)((*exc).zp1.n_points) ) )
      {
        if ( (*exc).pedantic_hinting )
        {
          (*exc).error = TT_Err_Invalid_Reference;
          return;
        }
      }
      else
      {
        distance = (*exc).func_project( exc, ((*exc).zp1.cur + point)->x - ((*exc).zp0.cur + (*exc).GS.rp0)->x, ((*exc).zp1.cur + point)->y - ((*exc).zp0.cur + (*exc).GS.rp0)->y )
                                                               ;

        (*exc).func_move( exc, &(*exc).zp1, point, -distance );
      }

      (*exc).GS.loop--;
    }

    (*exc).GS.loop = 1;
    (*exc).new_top = (*exc).args;
  }
# 6021 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ISECT( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort point,
                a0, a1,
                b0, b1;

    FT_F26Dot6 discriminant;

    FT_F26Dot6 dx, dy,
                dax, day,
                dbx, dby;

    FT_F26Dot6 val;

    FT_Vector R;


    point = (FT_UShort)args[0];

    a0 = (FT_UShort)args[1];
    a1 = (FT_UShort)args[2];
    b0 = (FT_UShort)args[3];
    b1 = (FT_UShort)args[4];

    if ( ( (FT_UInt)(b0) >= (FT_UInt)((*exc).zp0.n_points) ) ||
         ( (FT_UInt)(b1) >= (FT_UInt)((*exc).zp0.n_points) ) ||
         ( (FT_UInt)(a0) >= (FT_UInt)((*exc).zp1.n_points) ) ||
         ( (FT_UInt)(a1) >= (FT_UInt)((*exc).zp1.n_points) ) ||
         ( (FT_UInt)(point) >= (FT_UInt)((*exc).zp2.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    dbx = (*exc).zp0.cur[b1].x - (*exc).zp0.cur[b0].x;
    dby = (*exc).zp0.cur[b1].y - (*exc).zp0.cur[b0].y;

    dax = (*exc).zp1.cur[a1].x - (*exc).zp1.cur[a0].x;
    day = (*exc).zp1.cur[a1].y - (*exc).zp1.cur[a0].y;

    dx = (*exc).zp0.cur[b0].x - (*exc).zp1.cur[a0].x;
    dy = (*exc).zp0.cur[b0].y - (*exc).zp1.cur[a0].y;

    (*exc).zp2.tags[point] |= ( 8 | 16 );

    discriminant = FT_MulDiv( dax, -dby, 0x40 ) +
                   FT_MulDiv( day, dbx, 0x40 );

    if ( ( (discriminant) < 0 ? -(discriminant) : (discriminant) ) >= 0x40 )
    {
      val = FT_MulDiv( dx, -dby, 0x40 ) + FT_MulDiv( dy, dbx, 0x40 );

      R.x = FT_MulDiv( val, dax, discriminant );
      R.y = FT_MulDiv( val, day, discriminant );

      (*exc).zp2.cur[point].x = (*exc).zp1.cur[a0].x + R.x;
      (*exc).zp2.cur[point].y = (*exc).zp1.cur[a0].y + R.y;
    }
    else
    {


      (*exc).zp2.cur[point].x = ( (*exc).zp1.cur[a0].x +
                               (*exc).zp1.cur[a1].x +
                               (*exc).zp0.cur[b0].x +
                               (*exc).zp0.cur[b1].x ) / 4;
      (*exc).zp2.cur[point].y = ( (*exc).zp1.cur[a0].y +
                               (*exc).zp1.cur[a1].y +
                               (*exc).zp0.cur[b0].y +
                               (*exc).zp0.cur[b1].y ) / 4;
    }
  }
# 6103 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ALIGNPTS( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort p1, p2;
    FT_F26Dot6 distance;


    p1 = (FT_UShort)args[0];
    p2 = (FT_UShort)args[1];

    if ( ( (FT_UInt)(args[0]) >= (FT_UInt)((*exc).zp1.n_points) ) ||
         ( (FT_UInt)(args[1]) >= (FT_UInt)((*exc).zp0.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    distance = (*exc).func_project( exc, ((*exc).zp0.cur + p2)->x - ((*exc).zp1.cur + p1)->x, ((*exc).zp0.cur + p2)->y - ((*exc).zp1.cur + p1)->y )
                                                    / 2;

    (*exc).func_move( exc, &(*exc).zp1, p1, distance );
    (*exc).func_move( exc, &(*exc).zp0, p2, -distance );
  }
# 6138 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_IP( TT_ExecContext exc, FT_Long* args )
  {
    FT_F26Dot6 old_range, cur_range;
    FT_Vector* orus_base;
    FT_Vector* cur_base;
    FT_Int twilight;

    ( (exc) = (exc) ); ( (args) = (args) );


    if ( (*exc).top < (*exc).GS.loop )
    {
      (*exc).error = TT_Err_Invalid_Reference;
      return;
    }






    twilight = (*exc).GS.gep0 == 0 || (*exc).GS.gep1 == 0 || (*exc).GS.gep2 == 0;

    if ( ( (FT_UInt)((*exc).GS.rp1) >= (FT_UInt)((*exc).zp0.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    if ( twilight )
      orus_base = &(*exc).zp0.org[(*exc).GS.rp1];
    else
      orus_base = &(*exc).zp0.orus[(*exc).GS.rp1];

    cur_base = &(*exc).zp0.cur[(*exc).GS.rp1];





    if ( ( (FT_UInt)((*exc).GS.rp1) >= (FT_UInt)((*exc).zp0.n_points) ) ||
         ( (FT_UInt)((*exc).GS.rp2) >= (FT_UInt)((*exc).zp1.n_points) ) )
    {
      old_range = 0;
      cur_range = 0;
    }
    else
    {
      if ( twilight )
        old_range = (*exc).func_dualproj( exc, (&(*exc).zp1.org[(*exc).GS.rp2])->x - (orus_base)->x, (&(*exc).zp1.org[(*exc).GS.rp2])->y - (orus_base)->y )
                                                  ;
      else
        old_range = (*exc).func_dualproj( exc, (&(*exc).zp1.orus[(*exc).GS.rp2])->x - (orus_base)->x, (&(*exc).zp1.orus[(*exc).GS.rp2])->y - (orus_base)->y )
                                                  ;

      cur_range = (*exc).func_project( exc, (&(*exc).zp1.cur[(*exc).GS.rp2])->x - (cur_base)->x, (&(*exc).zp1.cur[(*exc).GS.rp2])->y - (cur_base)->y );
    }

    for ( ; (*exc).GS.loop > 0; --(*exc).GS.loop )
    {
      FT_UInt point = (FT_UInt)(*exc).stack[--(*exc).args];
      FT_F26Dot6 org_dist, cur_dist, new_dist;



      if ( ( (FT_UInt)(point) >= (FT_UInt)((*exc).zp2.n_points) ) )
      {
        if ( (*exc).pedantic_hinting )
        {
          (*exc).error = TT_Err_Invalid_Reference;
          return;
        }
        continue;
      }

      if ( twilight )
        org_dist = (*exc).func_dualproj( exc, (&(*exc).zp2.org[point])->x - (orus_base)->x, (&(*exc).zp2.org[point])->y - (orus_base)->y );
      else
        org_dist = (*exc).func_dualproj( exc, (&(*exc).zp2.orus[point])->x - (orus_base)->x, (&(*exc).zp2.orus[point])->y - (orus_base)->y );

      cur_dist = (*exc).func_project( exc, (&(*exc).zp2.cur[point])->x - (cur_base)->x, (&(*exc).zp2.cur[point])->y - (cur_base)->y );

      if ( org_dist )
        new_dist = ( old_range != 0 )
                     ? FT_MulDiv( org_dist, cur_range, old_range )
                     : cur_dist;
      else
        new_dist = 0;

      (*exc).func_move( exc, &(*exc).zp2, (FT_UShort)point, new_dist - cur_dist );
    }
    (*exc).GS.loop = 1;
    (*exc).new_top = (*exc).args;
  }
# 6242 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_UTP( TT_ExecContext exc, FT_Long* args )
  {
    FT_UShort point;
    FT_Byte mask;


    point = (FT_UShort)args[0];

    if ( ( (FT_UInt)(point) >= (FT_UInt)((*exc).zp0.n_points) ) )
    {
      if ( (*exc).pedantic_hinting )
        (*exc).error = TT_Err_Invalid_Reference;
      return;
    }

    mask = 0xFF;

    if ( (*exc).GS.freeVector.x != 0 )
      mask &= ~8;

    if ( (*exc).GS.freeVector.y != 0 )
      mask &= ~16;

    (*exc).zp0.tags[point] &= mask;
  }



  typedef struct IUP_WorkerRec_
  {
    FT_Vector* orgs;
    FT_Vector* curs;
    FT_Vector* orus;
    FT_UInt max_points;

  } IUP_WorkerRec, *IUP_Worker;


  static void
  _iup_worker_shift( IUP_Worker worker,
                     FT_UInt p1,
                     FT_UInt p2,
                     FT_UInt p )
  {
    FT_UInt i;
    FT_F26Dot6 dx;


    dx = worker->curs[p].x - worker->orgs[p].x;
    if ( dx != 0 )
    {
      for ( i = p1; i < p; i++ )
        worker->curs[i].x += dx;

      for ( i = p + 1; i <= p2; i++ )
        worker->curs[i].x += dx;
    }
  }


  static void
  _iup_worker_interpolate( IUP_Worker worker,
                           FT_UInt p1,
                           FT_UInt p2,
                           FT_UInt ref1,
                           FT_UInt ref2 )
  {
    FT_UInt i;
    FT_F26Dot6 orus1, orus2, org1, org2, delta1, delta2;


    if ( p1 > p2 )
      return;

    if ( ( (FT_UInt)(ref1) >= (FT_UInt)(worker->max_points) ) ||
         ( (FT_UInt)(ref2) >= (FT_UInt)(worker->max_points) ) )
      return;

    orus1 = worker->orus[ref1].x;
    orus2 = worker->orus[ref2].x;

    if ( orus1 > orus2 )
    {
      FT_F26Dot6 tmp_o;
      FT_UInt tmp_r;


      tmp_o = orus1;
      orus1 = orus2;
      orus2 = tmp_o;

      tmp_r = ref1;
      ref1 = ref2;
      ref2 = tmp_r;
    }

    org1 = worker->orgs[ref1].x;
    org2 = worker->orgs[ref2].x;
    delta1 = worker->curs[ref1].x - org1;
    delta2 = worker->curs[ref2].x - org2;

    if ( orus1 == orus2 )
    {

      for ( i = p1; i <= p2; i++ )
      {
        FT_F26Dot6 x = worker->orgs[i].x;


        if ( x <= org1 )
          x += delta1;
        else
          x += delta2;

        worker->curs[i].x = x;
      }
    }
    else
    {
      FT_Fixed scale = 0;
      FT_Bool scale_valid = 0;



      for ( i = p1; i <= p2; i++ )
      {
        FT_F26Dot6 x = worker->orgs[i].x;


        if ( x <= org1 )
          x += delta1;

        else if ( x >= org2 )
          x += delta2;

        else
        {
          if ( !scale_valid )
          {
            scale_valid = 1;
            scale = FT_MulDiv( org2 + delta2 - ( org1 + delta1 ),
                                     0x10000, orus2 - orus1 );
          }

          x = ( org1 + delta1 ) +
              FT_MulFix( worker->orus[i].x - orus1, scale );
        }
        worker->curs[i].x = x;
      }
    }
  }
# 6402 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_IUP( TT_ExecContext exc, FT_Long* args )
  {
    IUP_WorkerRec V;
    FT_Byte mask;

    FT_UInt first_point;
    FT_UInt end_point;

    FT_UInt first_touched;
    FT_UInt cur_touched;

    FT_UInt point;
    FT_Short contour;

    ( (exc) = (exc) ); ( (args) = (args) );



    if ( (*exc).pts.n_contours == 0 )
      return;

    if ( (*exc).opcode & 1 )
    {
      mask = 8;
      V.orgs = (*exc).pts.org;
      V.curs = (*exc).pts.cur;
      V.orus = (*exc).pts.orus;
    }
    else
    {
      mask = 16;
      V.orgs = (FT_Vector*)( (FT_Pos*)(*exc).pts.org + 1 );
      V.curs = (FT_Vector*)( (FT_Pos*)(*exc).pts.cur + 1 );
      V.orus = (FT_Vector*)( (FT_Pos*)(*exc).pts.orus + 1 );
    }
    V.max_points = (*exc).pts.n_points;

    contour = 0;
    point = 0;

    do
    {
      end_point = (*exc).pts.contours[contour] - (*exc).pts.first_point;
      first_point = point;

      if ( (*exc).pts.n_points <= end_point )
        end_point = (*exc).pts.n_points;

      while ( point <= end_point && ( (*exc).pts.tags[point] & mask ) == 0 )
        point++;

      if ( point <= end_point )
      {
        first_touched = point;
        cur_touched = point;

        point++;

        while ( point <= end_point )
        {
          if ( ( (*exc).pts.tags[point] & mask ) != 0 )
          {
            if ( point > 0 )
              _iup_worker_interpolate( &V,
                                       cur_touched + 1,
                                       point - 1,
                                       cur_touched,
                                       point );
            cur_touched = point;
          }

          point++;
        }

        if ( cur_touched == first_touched )
          _iup_worker_shift( &V, first_point, end_point, cur_touched );
        else
        {
          _iup_worker_interpolate( &V,
                                   (FT_UShort)( cur_touched + 1 ),
                                   end_point,
                                   cur_touched,
                                   first_touched );

          if ( first_touched > 0 )
            _iup_worker_interpolate( &V,
                                     first_point,
                                     first_touched - 1,
                                     cur_touched,
                                     first_touched );
        }
      }
      contour++;
    } while ( contour < (*exc).pts.n_contours );
  }
# 6506 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_DELTAP( TT_ExecContext exc, FT_Long* args )
  {
    FT_ULong k, nump;
    FT_UShort A;
    FT_ULong C;
    FT_Long B;




    if ( (*exc).face->unpatented_hinting )
    {
      FT_Long n = args[0] * 2;


      if ( (*exc).args < n )
      {
        (*exc).error = TT_Err_Too_Few_Arguments;
        return;
      }

      (*exc).args -= n;
      (*exc).new_top = (*exc).args;
      return;
    }


    nump = (FT_ULong)args[0];


    for ( k = 1; k <= nump; k++ )
    {
      if ( (*exc).args < 2 )
      {
        (*exc).error = TT_Err_Too_Few_Arguments;
        return;
      }

      (*exc).args -= 2;

      A = (FT_UShort)(*exc).stack[(*exc).args + 1];
      B = (*exc).stack[(*exc).args];







      if ( !( (FT_UInt)(A) >= (FT_UInt)((*exc).zp0.n_points) ) )
      {
        C = ( (FT_ULong)B & 0xF0 ) >> 4;

        switch ( (*exc).opcode )
        {
        case 0x5D:
          break;

        case 0x71:
          C += 16;
          break;

        case 0x72:
          C += 32;
          break;
        }

        C += (*exc).GS.delta_base;

        if ( Current_Ppem( exc ) == (FT_Long)C )
        {
          B = ( (FT_ULong)B & 0xF ) - 8;
          if ( B >= 0 )
            B++;
          B = B * 64 / ( 1L << (*exc).GS.delta_shift );

          (*exc).func_move( exc, &(*exc).zp0, A, B );
        }
      }
      else
        if ( (*exc).pedantic_hinting )
          (*exc).error = TT_Err_Invalid_Reference;
    }

    (*exc).new_top = (*exc).args;
  }
# 6601 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_DELTAC( TT_ExecContext exc, FT_Long* args )
  {
    FT_ULong nump, k;
    FT_ULong A, C;
    FT_Long B;




    if ( (*exc).face->unpatented_hinting )
    {
      FT_Long n = args[0] * 2;


      if ( (*exc).args < n )
      {
        (*exc).error = TT_Err_Too_Few_Arguments;
        return;
      }

      (*exc).args -= n;
      (*exc).new_top = (*exc).args;
      return;
    }


    nump = (FT_ULong)args[0];

    for ( k = 1; k <= nump; k++ )
    {
      if ( (*exc).args < 2 )
      {
        (*exc).error = TT_Err_Too_Few_Arguments;
        return;
      }

      (*exc).args -= 2;

      A = (FT_ULong)(*exc).stack[(*exc).args + 1];
      B = (*exc).stack[(*exc).args];

      if ( ( (FT_UInt)(A) >= (FT_UInt)((*exc).cvtSize) ) )
      {
        if ( (*exc).pedantic_hinting )
        {
          (*exc).error = TT_Err_Invalid_Reference;
          return;
        }
      }
      else
      {
        C = ( (FT_ULong)B & 0xF0 ) >> 4;

        switch ( (*exc).opcode )
        {
        case 0x73:
          break;

        case 0x74:
          C += 16;
          break;

        case 0x75:
          C += 32;
          break;
        }

        C += (*exc).GS.delta_base;

        if ( Current_Ppem( exc ) == (FT_Long)C )
        {
          B = ( (FT_ULong)B & 0xF ) - 8;
          if ( B >= 0 )
            B++;
          B = B * 64 / ( 1L << (*exc).GS.delta_shift );

          (*exc).func_move_cvt( exc, A, B );
        }
      }
    }

    (*exc).new_top = (*exc).args;
  }
# 6700 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  static void
  Ins_GETINFO( TT_ExecContext exc, FT_Long* args )
  {
    FT_Long K;


    K = 0;


    if ( ( args[0] & 1 ) != 0 )
      K = 35;


    if ( ( args[0] & 2 ) != 0 && (*exc).tt_metrics.rotated )
      K |= 0x80;


    if ( ( args[0] & 4 ) != 0 && (*exc).tt_metrics.stretched )
      K |= 1 << 8;


    if ( ( args[0] & 32 ) != 0 && (*exc).grayscale )
      K |= 1 << 12;

    args[0] = K;
  }


  static void
  Ins_UNKNOWN( TT_ExecContext exc, FT_Long* args )
  {
    TT_DefRecord* def = (*exc).IDefs;
    TT_DefRecord* limit = def + (*exc).numIDefs;

    ( (exc) = (exc) ); ( (args) = (args) );


    for ( ; def < limit; def++ )
    {
      if ( (FT_Byte)def->opc == (*exc).opcode && def->active )
      {
        TT_CallRec* call;


        if ( (*exc).callTop >= (*exc).callSize )
        {
          (*exc).error = TT_Err_Stack_Overflow;
          return;
        }

        call = (*exc).callStack + (*exc).callTop++;

        call->Caller_Range = (*exc).curRange;
        call->Caller_IP = (*exc).IP+1;
        call->Cur_Count = 1;
        call->Cur_Restart = def->start;

        Ins_Goto_CodeRange( exc, def->range, def->start );

        (*exc).step_ins = 0;
        return;
      }
    }

    (*exc).error = TT_Err_Invalid_Opcode;
  }
# 7088 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttinterp.c"
  extern __attribute__((dllexport)) FT_Error
  TT_RunIns( TT_ExecContext exc )
  {
    FT_Long ins_counter = 0;







    (*exc).tt_metrics.ratio = 0;
    if ( (*exc).metrics.x_ppem != (*exc).metrics.y_ppem )
    {

      (*exc).func_read_cvt = Read_CVT_Stretched;
      (*exc).func_write_cvt = Write_CVT_Stretched;
      (*exc).func_move_cvt = Move_CVT_Stretched;
    }
    else
    {

      (*exc).func_read_cvt = Read_CVT;
      (*exc).func_write_cvt = Write_CVT;
      (*exc).func_move_cvt = Move_CVT;
    }

    Compute_Funcs( exc );
    Compute_Round( exc, (FT_Byte)exc->GS.round_state );

    do
    {
      (*exc).opcode = (*exc).code[(*exc).IP];

      if ( ( (*exc).length = opcode_length[(*exc).opcode] ) < 0 )
      {
        if ( (*exc).IP + 1 > (*exc).codeSize )
          goto LErrorCodeOverflow_;

        (*exc).length = 2 - (*exc).length * (*exc).code[(*exc).IP + 1];
      }

      if ( (*exc).IP + (*exc).length > (*exc).codeSize )
        goto LErrorCodeOverflow_;


      (*exc).args = (*exc).top - ( Pop_Push_Count[(*exc).opcode] >> 4 );



      if ( (*exc).args < 0 )
      {
        (*exc).error = TT_Err_Too_Few_Arguments;
        goto LErrorLabel_;
      }

      (*exc).new_top = (*exc).args + ( Pop_Push_Count[(*exc).opcode] & 15 );




      if ( (*exc).new_top > (*exc).stackSize )
      {
        (*exc).error = TT_Err_Stack_Overflow;
        goto LErrorLabel_;
      }

      (*exc).step_ins = 1;
      (*exc).error = TT_Err_Ok;



      {
        FT_Long* args = (*exc).stack + (*exc).args;
        FT_Byte opcode = (*exc).opcode;






        switch ( opcode )
        {
        case 0x00:
        case 0x01:
        case 0x02:
        case 0x03:
        case 0x04:
        case 0x05:
          {
            FT_Short AA, BB;


            AA = (FT_Short)( ( opcode & 1 ) << 14 );
            BB = (FT_Short)( AA ^ 0x4000 );

            if ( opcode < 4 )
            {
              (*exc).GS.projVector.x = AA;
              (*exc).GS.projVector.y = BB;

              (*exc).GS.dualVector.x = AA;
              (*exc).GS.dualVector.y = BB;
            }
            else
            {
              if ( (*exc).face->unpatented_hinting ) { (*exc).GS.projVector.x = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0x4000 : 0 ); (*exc).GS.projVector.y = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0 : 0x4000 ); };
            }

            if ( ( opcode & 2 ) == 0 )
            {
              (*exc).GS.freeVector.x = AA;
              (*exc).GS.freeVector.y = BB;
            }
            else
            {
              if ( (*exc).face->unpatented_hinting ) { (*exc).GS.freeVector.x = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0x4000 : 0 ); (*exc).GS.freeVector.y = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0 : 0x4000 ); };
            }

            Compute_Funcs( exc );
          }
          break;

        case 0x06:
        case 0x07:
          if ( Ins_SxVTL( exc, (FT_UShort)args[1], (FT_UShort)args[0], (*exc).opcode, &(*exc).GS.projVector ) == 0 ) { (*exc).GS.dualVector = (*exc).GS.projVector; if ( (*exc).face->unpatented_hinting ) { (*exc).GS.freeVector.x = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0x4000 : 0 ); (*exc).GS.freeVector.y = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0 : 0x4000 ); }; Compute_Funcs( exc ); }
          break;

        case 0x08:
        case 0x09:
          if ( Ins_SxVTL( exc, (FT_UShort)args[1], (FT_UShort)args[0], (*exc).opcode, &(*exc).GS.freeVector ) == 0 ) { if ( (*exc).face->unpatented_hinting ) { (*exc).GS.projVector.x = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0x4000 : 0 ); (*exc).GS.projVector.y = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0 : 0x4000 ); }; Compute_Funcs( exc ); }
          break;

        case 0x0A:
          { FT_Short S; FT_Long X, Y; S = (FT_Short)args[1]; Y = (FT_Long)S; S = (FT_Short)args[0]; X = (FT_Long)S; Normalize( exc, X, Y, &(*exc).GS.projVector ); (*exc).GS.dualVector = (*exc).GS.projVector; if ( (*exc).face->unpatented_hinting ) { (*exc).GS.freeVector.x = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0x4000 : 0 ); (*exc).GS.freeVector.y = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0 : 0x4000 ); }; Compute_Funcs( exc ); }
          break;

        case 0x0B:
          { FT_Short S; FT_Long X, Y; S = (FT_Short)args[1]; Y = (FT_Long)S; S = (FT_Short)args[0]; X = S; Normalize( exc, X, Y, &(*exc).GS.freeVector ); if ( (*exc).face->unpatented_hinting ) { (*exc).GS.projVector.x = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0x4000 : 0 ); (*exc).GS.projVector.y = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0 : 0x4000 ); }; Compute_Funcs( exc ); }
          break;

        case 0x0C:
          if ( (*exc).face->unpatented_hinting ) { args[0] = (*exc).GS.both_x_axis ? 0x4000 : 0; args[1] = (*exc).GS.both_x_axis ? 0 : 0x4000; } else { args[0] = (*exc).GS.projVector.x; args[1] = (*exc).GS.projVector.y; }
          break;

        case 0x0D:
          if ( (*exc).face->unpatented_hinting ) { args[0] = (*exc).GS.both_x_axis ? 0x4000 : 0; args[1] = (*exc).GS.both_x_axis ? 0 : 0x4000; } else { args[0] = (*exc).GS.freeVector.x; args[1] = (*exc).GS.freeVector.y; }
          break;

        case 0x0E:
          if ( (*exc).face->unpatented_hinting ) { (*exc).GS.projVector.x = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0x4000 : 0 ); (*exc).GS.projVector.y = (FT_F2Dot14)( (*exc).GS.both_x_axis ? 0 : 0x4000 ); }; (*exc).GS.freeVector = (*exc).GS.projVector; Compute_Funcs( exc );
          break;

        case 0x0F:
          Ins_ISECT( exc, args );
          break;

        case 0x10:
          (*exc).GS.rp0 = (FT_UShort)args[0];
          break;

        case 0x11:
          (*exc).GS.rp1 = (FT_UShort)args[0];
          break;

        case 0x12:
          (*exc).GS.rp2 = (FT_UShort)args[0];
          break;

        case 0x13:
          Ins_SZP0( exc, args );
          break;

        case 0x14:
          Ins_SZP1( exc, args );
          break;

        case 0x15:
          Ins_SZP2( exc, args );
          break;

        case 0x16:
          Ins_SZPS( exc, args );
          break;

        case 0x17:
          if ( args[0] < 0 ) (*exc).error = TT_Err_Bad_Argument; else (*exc).GS.loop = args[0];
          break;

        case 0x18:
          (*exc).GS.round_state = 1; (*exc).func_round = (TT_Round_Func)Round_To_Grid;
          break;

        case 0x19:
          (*exc).GS.round_state = 0; (*exc).func_round = (TT_Round_Func)Round_To_Half_Grid;
          break;

        case 0x1A:
          (*exc).GS.minimum_distance = args[0];
          break;

        case 0x1B:
          Ins_ELSE( exc, args );
          break;

        case 0x1C:
          (*exc).IP += args[0]; (*exc).step_ins = 0;
          break;

        case 0x1D:
          (*exc).GS.control_value_cutin = (FT_F26Dot6)args[0];
          break;

        case 0x1E:
          (*exc).GS.single_width_cutin = (FT_F26Dot6)args[0];
          break;

        case 0x1F:
          (*exc).GS.single_width_value = (FT_F26Dot6)( args[0] >> 10 );
          break;

        case 0x20:
          args[1] = args[0];
          break;

        case 0x21:

          break;

        case 0x22:
          (*exc).new_top = 0;
          break;

        case 0x23:
          { FT_Long L; L = args[0]; args[0] = args[1]; args[1] = L; }
          break;

        case 0x24:
          args[0] = (*exc).top;
          break;

        case 0x25:
          { FT_Long L; L = args[0]; if ( L <= 0 || L > (*exc).args ) (*exc).error = TT_Err_Invalid_Reference; else args[0] = (*exc).stack[(*exc).args - L]; }
          break;

        case 0x26:
          Ins_MINDEX( exc, args );
          break;

        case 0x27:
          Ins_ALIGNPTS( exc, args );
          break;

        case 0x28:
          Ins_UNKNOWN( exc, args );
          break;

        case 0x29:
          Ins_UTP( exc, args );
          break;

        case 0x2A:
          Ins_LOOPCALL( exc, args );
          break;

        case 0x2B:
          Ins_CALL( exc, args );
          break;

        case 0x2C:
          Ins_FDEF( exc, args );
          break;

        case 0x2D:
          Ins_ENDF( exc, args );
          break;

        case 0x2E:
        case 0x2F:
          Ins_MDAP( exc, args );
          break;


        case 0x30:
        case 0x31:
          Ins_IUP( exc, args );
          break;

        case 0x32:
        case 0x33:
          Ins_SHP( exc, args );
          break;

        case 0x34:
        case 0x35:
          Ins_SHC( exc, args );
          break;

        case 0x36:
        case 0x37:
          Ins_SHZ( exc, args );
          break;

        case 0x38:
          Ins_SHPIX( exc, args );
          break;

        case 0x39:
          Ins_IP( exc, args );
          break;

        case 0x3A:
        case 0x3B:
          Ins_MSIRP( exc, args );
          break;

        case 0x3C:
          Ins_ALIGNRP( exc, args );
          break;

        case 0x3D:
          (*exc).GS.round_state = 2; (*exc).func_round = (TT_Round_Func)Round_To_Double_Grid;
          break;

        case 0x3E:
        case 0x3F:
          Ins_MIAP( exc, args );
          break;

        case 0x40:
          Ins_NPUSHB( exc, args );
          break;

        case 0x41:
          Ins_NPUSHW( exc, args );
          break;

        case 0x42:
          { FT_ULong I = (FT_ULong)args[0]; if ( ( (FT_UInt)(I) >= (FT_UInt)((*exc).storeSize) ) ) { if ( (*exc).pedantic_hinting ) { goto Set_Invalid_Ref; } } else (*exc).storage[I] = args[1]; }
          break;

      Set_Invalid_Ref:
            (*exc).error = TT_Err_Invalid_Reference;
          break;

        case 0x43:
          { FT_ULong I = (FT_ULong)args[0]; if ( ( (FT_UInt)(I) >= (FT_UInt)((*exc).storeSize) ) ) { if ( (*exc).pedantic_hinting ) { goto Set_Invalid_Ref; } else args[0] = 0; } else args[0] = (*exc).storage[I]; }
          break;

        case 0x44:
          { FT_ULong I = (FT_ULong)args[0]; if ( ( (FT_UInt)(I) >= (FT_UInt)((*exc).cvtSize) ) ) { if ( (*exc).pedantic_hinting ) { goto Set_Invalid_Ref; } } else (*exc).func_write_cvt( exc, I, args[1] ); }
          break;

        case 0x45:
          { FT_ULong I = (FT_ULong)args[0]; if ( ( (FT_UInt)(I) >= (FT_UInt)((*exc).cvtSize) ) ) { if ( (*exc).pedantic_hinting ) { goto Set_Invalid_Ref; } else args[0] = 0; } else args[0] = (*exc).func_read_cvt( exc, I ); }
          break;

        case 0x46:
        case 0x47:
          Ins_GC( exc, args );
          break;

        case 0x48:
          Ins_SCFS( exc, args );
          break;

        case 0x49:
        case 0x4A:
          Ins_MD( exc, args );
          break;

        case 0x4B:
          args[0] = Current_Ppem( exc );
          break;

        case 0x4C:
          args[0] = Current_Ppem( exc );
          break;

        case 0x4D:
          (*exc).GS.auto_flip = 1;
          break;

        case 0x4E:
          (*exc).GS.auto_flip = 0;
          break;

        case 0x4F:
          (*exc).error = TT_Err_Debug_OpCode;
          break;

        case 0x50:
          args[0] = ( args[0] < args[1] );
          break;

        case 0x51:
          args[0] = ( args[0] <= args[1] );
          break;

        case 0x52:
          args[0] = ( args[0] > args[1] );
          break;

        case 0x53:
          args[0] = ( args[0] >= args[1] );
          break;

        case 0x54:
          args[0] = ( args[0] == args[1] );
          break;

        case 0x55:
          args[0] = ( args[0] != args[1] );
          break;

        case 0x56:
          args[0] = ( ( (*exc).func_round( exc, args[0], 0 ) & 127 ) == 64 );
          break;

        case 0x57:
          args[0] = ( ( (*exc).func_round( exc, args[0], 0 ) & 127 ) == 0 );
          break;

        case 0x58:
          Ins_IF( exc, args );
          break;

        case 0x59:

          break;

        case 0x5A:
          args[0] = ( args[0] && args[1] );
          break;

        case 0x5B:
          args[0] = ( args[0] || args[1] );
          break;

        case 0x5C:
          args[0] = !args[0];
          break;

        case 0x5D:
          Ins_DELTAP( exc, args );
          break;

        case 0x5E:
          (*exc).GS.delta_base = (FT_Short)args[0];
          break;

        case 0x5F:
          (*exc).GS.delta_shift = (FT_Short)args[0];
          break;

        case 0x60:
          args[0] += args[1];
          break;

        case 0x61:
          args[0] -= args[1];
          break;

        case 0x62:
          if ( args[1] == 0 ) (*exc).error = TT_Err_Divide_By_Zero; else args[0] = FT_MulDiv_No_Round( args[0], 64L, args[1] );
          break;

        case 0x63:
          args[0] = FT_MulDiv( args[0], args[1], 64L );
          break;

        case 0x64:
          args[0] = ( (args[0]) < 0 ? -(args[0]) : (args[0]) );
          break;

        case 0x65:
          args[0] = -args[0];
          break;

        case 0x66:
          args[0] = ( (args[0]) & ~63 );
          break;

        case 0x67:
          args[0] = ( ((args[0]) + 63) & ~63 );
          break;

        case 0x68:
        case 0x69:
        case 0x6A:
        case 0x6B:
          args[0] = (*exc).func_round( exc, args[0], (*exc).tt_metrics.compensations[(*exc).opcode - 0x68] );
          break;

        case 0x6C:
        case 0x6D:
        case 0x6E:
        case 0x6F:
          args[0] = Round_None( exc, args[0], (*exc).tt_metrics.compensations[(*exc).opcode - 0x6C] );
          break;

        case 0x70:
          { FT_ULong I = (FT_ULong)args[0]; if ( ( (FT_UInt)(I) >= (FT_UInt)((*exc).cvtSize) ) ) { if ( (*exc).pedantic_hinting ) { goto Set_Invalid_Ref; } } else (*exc).cvt[I] = FT_MulFix( args[1], (*exc).tt_metrics.scale ); }
          break;

        case 0x71:
        case 0x72:
          Ins_DELTAP( exc, args );
          break;

        case 0x73:
        case 0x74:
        case 0x75:
          Ins_DELTAC( exc, args );
          break;

        case 0x76:
          SetSuperRound( exc, 0x4000, args[0] ); (*exc).GS.round_state = 6; (*exc).func_round = (TT_Round_Func)Round_Super;
          break;

        case 0x77:
          SetSuperRound( exc, 0x2D41, args[0] ); (*exc).GS.round_state = 7; (*exc).func_round = (TT_Round_Func)Round_Super_45;
          break;

        case 0x78:
          if ( args[1] != 0 ) { (*exc).IP += args[0]; (*exc).step_ins = 0; }
          break;

        case 0x79:
          if ( args[1] == 0 ) { (*exc).IP += args[0]; (*exc).step_ins = 0; }
          break;

        case 0x7A:
          (*exc).GS.round_state = 5; (*exc).func_round = (TT_Round_Func)Round_None;
          break;

        case 0x7B:
          Ins_UNKNOWN( exc, args );
          break;

        case 0x7C:
          (*exc).GS.round_state = 4; (*exc).func_round = (TT_Round_Func)Round_Up_To_Grid;
          break;

        case 0x7D:
          (*exc).GS.round_state = 3; (*exc).func_round = (TT_Round_Func)Round_Down_To_Grid;
          break;

        case 0x7E:
        case 0x7F:

          break;

        case 0x80:
          Ins_FLIPPT( exc, args );
          break;

        case 0x81:
          Ins_FLIPRGON( exc, args );
          break;

        case 0x82:
          Ins_FLIPRGOFF( exc, args );
          break;

        case 0x83:
        case 0x84:
          Ins_UNKNOWN( exc, args );
          break;

        case 0x85:
          Ins_SCANCTRL( exc, args );
          break;

        case 0x86:
        case 0x87:
          Ins_SDPVTL( exc, args );
          break;

        case 0x88:
          Ins_GETINFO( exc, args );
          break;

        case 0x89:
          Ins_IDEF( exc, args );
          break;

        case 0x8A:
          Ins_ROLL( exc, args );
          break;

        case 0x8B:
          if ( args[1] > args[0] ) args[0] = args[1];
          break;

        case 0x8C:
          if ( args[1] < args[0] ) args[0] = args[1];
          break;

        case 0x8D:
          Ins_SCANTYPE( exc, args );
          break;

        case 0x8E:
          Ins_INSTCTRL( exc, args );
          break;

        case 0x8F:
          Ins_UNKNOWN( exc, args );
          break;

        default:
          if ( opcode >= 0xE0 )
            Ins_MIRP( exc, args );
          else if ( opcode >= 0xC0 )
            Ins_MDRP( exc, args );
          else if ( opcode >= 0xB8 )
            Ins_PUSHW( exc, args );
          else if ( opcode >= 0xB0 )
            Ins_PUSHB( exc, args );
          else
            Ins_UNKNOWN( exc, args );
        }

      }







      if ( (*exc).error != TT_Err_Ok )
      {
        switch ( (*exc).error )
        {
        case TT_Err_Invalid_Opcode:
          {
            TT_DefRecord* def = (*exc).IDefs;
            TT_DefRecord* limit = def + (*exc).numIDefs;


            for ( ; def < limit; def++ )
            {
              if ( def->active && (*exc).opcode == (FT_Byte)def->opc )
              {
                TT_CallRec* callrec;


                if ( (*exc).callTop >= (*exc).callSize )
                {
                  (*exc).error = TT_Err_Invalid_Reference;
                  goto LErrorLabel_;
                }

                callrec = &(*exc).callStack[(*exc).callTop];

                callrec->Caller_Range = (*exc).curRange;
                callrec->Caller_IP = (*exc).IP + 1;
                callrec->Cur_Count = 1;
                callrec->Cur_Restart = def->start;

                if ( Ins_Goto_CodeRange( exc, def->range, def->start ) == 1 )
                  goto LErrorLabel_;

                goto LSuiteLabel_;
              }
            }
          }

          (*exc).error = TT_Err_Invalid_Opcode;
          goto LErrorLabel_;







        default:
          goto LErrorLabel_;




        }
      }

      (*exc).top = (*exc).new_top;

      if ( (*exc).step_ins )
        (*exc).IP += (*exc).length;



      if ( ++ins_counter > 1000000L )
        return TT_Err_Execution_Too_Long;

    LSuiteLabel_:
      if ( (*exc).IP >= (*exc).codeSize )
      {
        if ( (*exc).callTop > 0 )
        {
          (*exc).error = TT_Err_Code_Overflow;
          goto LErrorLabel_;
        }
        else
          goto LNo_Error_;
      }
    } while ( !(*exc).instruction_trap );

  LNo_Error_:





    return TT_Err_Ok;

  LErrorCodeOverflow_:
    (*exc).error = TT_Err_Code_Overflow;

  LErrorLabel_:





    return (*exc).error;
  }
# 29 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/truetype.c" 2



# 1 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c" 1
# 98 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  enum
  {
    GX_PT_POINTS_ARE_WORDS = 0x80,
    GX_PT_POINT_RUN_COUNT_MASK = 0x7F
  };
# 126 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  static FT_UShort*
  ft_var_readpackedpoints( FT_Stream stream,
                           FT_UInt *point_cnt )
  {
    FT_UShort *points;
    FT_Int n;
    FT_Int runcnt;
    FT_Int i;
    FT_Int j;
    FT_Int first;
    FT_Memory memory = stream->memory;
    FT_Error error = TT_Err_Ok;

    ( (error) = (error) );


    *point_cnt = n = ( (FT_Byte)FT_Stream_GetChar( stream ) );
    if ( n == 0 )
      return (FT_UShort*)( -1 );

    if ( n & GX_PT_POINTS_ARE_WORDS )
      n = ( (FT_Byte)FT_Stream_GetChar( stream ) ) | ( ( n & GX_PT_POINT_RUN_COUNT_MASK ) << 8 );

    if ( ( ((points) = (ft_mem_realloc( memory, sizeof ( *(points) ), 0, (n), ((void *)0), &error ))), error != 0 ) )
      return ((void *)0);

    i = 0;
    while ( i < n )
    {
      runcnt = ( (FT_Byte)FT_Stream_GetChar( stream ) );
      if ( runcnt & GX_PT_POINTS_ARE_WORDS )
      {
        runcnt = runcnt & GX_PT_POINT_RUN_COUNT_MASK;
        first = points[i++] = ( (FT_UShort)FT_Stream_GetShort( stream ) );


        for ( j = 0; j < runcnt; ++j )
          points[i++] = (FT_UShort)( first += ( (FT_UShort)FT_Stream_GetShort( stream ) ) );
      }
      else
      {
        first = points[i++] = ( (FT_Byte)FT_Stream_GetChar( stream ) );

        for ( j = 0; j < runcnt; ++j )
          points[i++] = (FT_UShort)( first += ( (FT_Byte)FT_Stream_GetChar( stream ) ) );
      }
    }

    return points;
  }


  enum
  {
    GX_DT_DELTAS_ARE_ZERO = 0x80,
    GX_DT_DELTAS_ARE_WORDS = 0x40,
    GX_DT_DELTA_RUN_COUNT_MASK = 0x3F
  };
# 206 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  static FT_Short*
  ft_var_readpackeddeltas( FT_Stream stream,
                           FT_Int delta_cnt )
  {
    FT_Short *deltas;
    FT_Int runcnt;
    FT_Int i;
    FT_Int j;
    FT_Memory memory = stream->memory;
    FT_Error error = TT_Err_Ok;

    ( (error) = (error) );


    if ( ( ((deltas) = (ft_mem_realloc( memory, sizeof ( *(deltas) ), 0, (delta_cnt), ((void *)0), &error ))), error != 0 ) )
      return ((void *)0);

    i = 0;
    while ( i < delta_cnt )
    {
      runcnt = ( (FT_Byte)FT_Stream_GetChar( stream ) );
      if ( runcnt & GX_DT_DELTAS_ARE_ZERO )
      {

        for ( j = 0;
              j <= ( runcnt & GX_DT_DELTA_RUN_COUNT_MASK ) && i < delta_cnt;
              ++j )
          deltas[i++] = 0;
      }
      else if ( runcnt & GX_DT_DELTAS_ARE_WORDS )
      {

        for ( j = 0;
              j <= ( runcnt & GX_DT_DELTA_RUN_COUNT_MASK ) && i < delta_cnt;
              ++j )
          deltas[i++] = ( (FT_Short)FT_Stream_GetShort( stream ) );
      }
      else
      {

        for ( j = 0;
              j <= ( runcnt & GX_DT_DELTA_RUN_COUNT_MASK ) && i < delta_cnt;
              ++j )
          deltas[i++] = ( (FT_Char)FT_Stream_GetChar( stream ) );
      }

      if ( j <= ( runcnt & GX_DT_DELTA_RUN_COUNT_MASK ) )
      {

        do { ft_mem_free( memory, (deltas) ); (deltas) = ((void *)0); } while ( 0 );
        return ((void *)0);
      }
    }

    return deltas;
  }
# 276 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  static void
  ft_var_load_avar( TT_Face face )
  {
    FT_Stream stream = ((FT_Face)(face))->stream;
    FT_Memory memory = stream->memory;
    GX_Blend blend = face->blend;
    GX_AVarSegment segment;
    FT_Error error = TT_Err_Ok;
    FT_ULong version;
    FT_Long axisCount;
    FT_Int i, j;
    FT_ULong table_len;

    ( (error) = (error) );


    blend->avar_checked = 1;
    if ( (error = face->goto_table( face, ( ( (FT_ULong)'a' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'a' << 8 ) | (FT_ULong)'r' ), stream, &table_len )) != 0 )
      return;

    if ( ( ( error = ((FT_Stream_EnterFrame( stream, table_len ))) ) != 0 ) )
      return;

    version = ( (FT_Long)FT_Stream_GetLong( stream ) );
    axisCount = ( (FT_Long)FT_Stream_GetLong( stream ) );

    if ( version != 0x00010000L ||
         axisCount != (FT_Long)blend->mmvar->num_axis )
      goto Exit;

    if ( ( ((blend->avar_segment) = (ft_mem_realloc( memory, sizeof ( *(blend->avar_segment) ), 0, (axisCount), ((void *)0), &error ))), error != 0 ) )
      goto Exit;

    segment = &blend->avar_segment[0];
    for ( i = 0; i < axisCount; ++i, ++segment )
    {
      segment->pairCount = ( (FT_UShort)FT_Stream_GetShort( stream ) );
      if ( ( ((segment->correspondence) = (ft_mem_realloc( memory, sizeof ( *(segment->correspondence) ), 0, (segment->pairCount), ((void *)0), &error ))), error != 0 ) )
      {



        for ( j = i - 1; j >= 0; --j )
          do { ft_mem_free( memory, (blend->avar_segment[j].correspondence) ); (blend->avar_segment[j].correspondence) = ((void *)0); } while ( 0 );

        do { ft_mem_free( memory, (blend->avar_segment) ); (blend->avar_segment) = ((void *)0); } while ( 0 );
        blend->avar_segment = ((void *)0);
        goto Exit;
      }

      for ( j = 0; j < segment->pairCount; ++j )
      {
        segment->correspondence[j].fromCoord =
          ( (FT_Short)FT_Stream_GetShort( stream ) ) << 2;
        segment->correspondence[j].toCoord =
          ( (FT_Short)FT_Stream_GetShort( stream ) )<<2;
      }
    }

  Exit:
    (FT_Stream_ExitFrame( stream ));
  }


  typedef struct GX_GVar_Head_
  {
    FT_Long version;
    FT_UShort axisCount;
    FT_UShort globalCoordCount;
    FT_ULong offsetToCoord;
    FT_UShort glyphCount;
    FT_UShort flags;
    FT_ULong offsetToData;

  } GX_GVar_Head;
# 368 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  static FT_Error
  ft_var_load_gvar( TT_Face face )
  {
    FT_Stream stream = ((FT_Face)(face))->stream;
    FT_Memory memory = stream->memory;
    GX_Blend blend = face->blend;
    FT_Error error;
    FT_UInt i, j;
    FT_ULong table_len;
    FT_ULong gvar_start;
    FT_ULong offsetToData;
    GX_GVar_Head gvar_head;

    static const FT_Frame_Field gvar_fields[] =
    {




      { ft_frame_start, 0, 20 },
        { ft_frame_long_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->version ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, version) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->axisCount ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, axisCount) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->globalCoordCount ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, globalCoordCount) ) },
        { ft_frame_ulong_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->offsetToCoord ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, offsetToCoord) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->glyphCount ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, glyphCount) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->flags ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, flags) ) },
        { ft_frame_ulong_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->offsetToData ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, offsetToData) ) },
      { ft_frame_end, 0, 0 }
    };

    if ( (error = face->goto_table( face, ( ( (FT_ULong)'g' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'a' << 8 ) | (FT_ULong)'r' ), stream, &table_len )) != 0 )
      goto Exit;

    gvar_start = FT_Stream_Pos( stream );
    if ( ( ( error = (FT_Stream_ReadFields( stream, gvar_fields, &gvar_head )) ) != 0 ) )
      goto Exit;

    blend->tuplecount = gvar_head.globalCoordCount;
    blend->gv_glyphcnt = gvar_head.glyphCount;
    offsetToData = gvar_start + gvar_head.offsetToData;

    if ( gvar_head.version != (FT_Long)0x00010000L ||
         gvar_head.axisCount != (FT_UShort)blend->mmvar->num_axis )
    {
      error = TT_Err_Invalid_Table;
      goto Exit;
    }

    if ( ( ((blend->glyphoffsets) = (ft_mem_realloc( memory, sizeof ( *(blend->glyphoffsets) ), 0, (blend->gv_glyphcnt + 1), ((void *)0), &error ))), error != 0 ) )
      goto Exit;

    if ( gvar_head.flags & 1 )
    {

      if ( ( ( error = ((FT_Stream_EnterFrame( stream, ( blend->gv_glyphcnt + 1 ) * 4L ))) ) != 0 ) )
        goto Exit;

      for ( i = 0; i <= blend->gv_glyphcnt; ++i )
        blend->glyphoffsets[i] = offsetToData + ( (FT_Long)FT_Stream_GetLong( stream ) );

      (FT_Stream_ExitFrame( stream ));
    }
    else
    {

      if ( ( ( error = ((FT_Stream_EnterFrame( stream, ( blend->gv_glyphcnt + 1 ) * 2L ))) ) != 0 ) )
        goto Exit;

      for ( i = 0; i <= blend->gv_glyphcnt; ++i )
        blend->glyphoffsets[i] = offsetToData + ( (FT_UShort)FT_Stream_GetShort( stream ) ) * 2;


      (FT_Stream_ExitFrame( stream ));
    }

    if ( blend->tuplecount != 0 )
    {
      if ( ( ((blend->tuplecoords) = (ft_mem_realloc( memory, sizeof ( *(blend->tuplecoords) ), 0, (gvar_head.axisCount * blend->tuplecount), ((void *)0), &error ))), error != 0 )
                                                                   )
        goto Exit;

      if ( ( ( error = (FT_Stream_Seek( stream, gvar_start + gvar_head.offsetToCoord )) ) != 0 ) ||
           ( ( error = ((FT_Stream_EnterFrame( stream, blend->tuplecount * gvar_head.axisCount * 2L ))) ) != 0 ) )
        goto Exit;

      for ( i = 0; i < blend->tuplecount; ++i )
        for ( j = 0 ; j < (FT_UInt)gvar_head.axisCount; ++j )
          blend->tuplecoords[i * gvar_head.axisCount + j] =
            ( (FT_Short)FT_Stream_GetShort( stream ) ) << 2;

      (FT_Stream_ExitFrame( stream ));
    }

  Exit:
    return error;
  }
# 493 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  static FT_Fixed
  ft_var_apply_tuple( GX_Blend blend,
                      FT_UShort tupleIndex,
                      FT_Fixed* tuple_coords,
                      FT_Fixed* im_start_coords,
                      FT_Fixed* im_end_coords )
  {
    FT_UInt i;
    FT_Fixed apply;
    FT_Fixed temp;


    apply = 0x10000L;
    for ( i = 0; i < blend->num_axis; ++i )
    {
      if ( tuple_coords[i] == 0 )




        continue;

      else if ( blend->normalizedcoords[i] == 0 ||
                ( blend->normalizedcoords[i] < 0 && tuple_coords[i] > 0 ) ||
                ( blend->normalizedcoords[i] > 0 && tuple_coords[i] < 0 ) )
      {
        apply = 0;
        break;
      }

      else if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )

        apply = FT_MulDiv( apply,
                           blend->normalizedcoords[i] > 0
                             ? blend->normalizedcoords[i]
                             : -blend->normalizedcoords[i],
                           0x10000L );

      else if ( blend->normalizedcoords[i] <= im_start_coords[i] ||
                blend->normalizedcoords[i] >= im_end_coords[i] )
      {
        apply = 0;
        break;
      }

      else if ( blend->normalizedcoords[i] < tuple_coords[i] )
      {
        temp = FT_MulDiv( blend->normalizedcoords[i] - im_start_coords[i],
                          0x10000L,
                          tuple_coords[i] - im_start_coords[i]);
        apply = FT_MulDiv( apply, temp, 0x10000L );
      }

      else
      {
        temp = FT_MulDiv( im_end_coords[i] - blend->normalizedcoords[i],
                          0x10000L,
                          im_end_coords[i] - tuple_coords[i] );
        apply = FT_MulDiv( apply, temp, 0x10000L );
      }
    }

    return apply;
  }
# 568 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  typedef struct GX_FVar_Head_
  {
    FT_Long version;
    FT_UShort offsetToData;
    FT_UShort countSizePairs;
    FT_UShort axisCount;
    FT_UShort axisSize;
    FT_UShort instanceCount;
    FT_UShort instanceSize;

  } GX_FVar_Head;


  typedef struct fvar_axis_
  {
    FT_ULong axisTag;
    FT_ULong minValue;
    FT_ULong defaultValue;
    FT_ULong maxValue;
    FT_UShort flags;
    FT_UShort nameID;

  } GX_FVar_Axis;
# 612 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  static FT_Error
  TT_Get_MM_Var( TT_Face face,
                 FT_MM_Var* *master )
  {
    FT_Stream stream = face->root.stream;
    FT_Memory memory = face->root.memory;
    FT_ULong table_len;
    FT_Error error = TT_Err_Ok;
    FT_ULong fvar_start;
    FT_Int i, j;
    FT_MM_Var* mmvar;
    FT_Fixed* next_coords;
    FT_String* next_name;
    FT_Var_Axis* a;
    FT_Var_Named_Style* ns;
    GX_FVar_Head fvar_head;

    static const FT_Frame_Field fvar_fields[] =
    {




      { ft_frame_start, 0, 16 },
        { ft_frame_long_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->version ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, version) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->offsetToData ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, offsetToData) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->countSizePairs ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, countSizePairs) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->axisCount ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, axisCount) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->axisSize ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, axisSize) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->instanceCount ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, instanceCount) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->instanceSize ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, instanceSize) ) },
      { ft_frame_end, 0, 0 }
    };

    static const FT_Frame_Field fvaraxis_fields[] =
    {




      { ft_frame_start, 0, 20 },
        { ft_frame_ulong_be, (FT_Byte)sizeof ( ((GX_FVar_Axis*)0)->axisTag ), (FT_UShort)( __builtin_offsetof (GX_FVar_Axis, axisTag) ) },
        { ft_frame_ulong_be, (FT_Byte)sizeof ( ((GX_FVar_Axis*)0)->minValue ), (FT_UShort)( __builtin_offsetof (GX_FVar_Axis, minValue) ) },
        { ft_frame_ulong_be, (FT_Byte)sizeof ( ((GX_FVar_Axis*)0)->defaultValue ), (FT_UShort)( __builtin_offsetof (GX_FVar_Axis, defaultValue) ) },
        { ft_frame_ulong_be, (FT_Byte)sizeof ( ((GX_FVar_Axis*)0)->maxValue ), (FT_UShort)( __builtin_offsetof (GX_FVar_Axis, maxValue) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Axis*)0)->flags ), (FT_UShort)( __builtin_offsetof (GX_FVar_Axis, flags) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Axis*)0)->nameID ), (FT_UShort)( __builtin_offsetof (GX_FVar_Axis, nameID) ) },
      { ft_frame_end, 0, 0 }
    };


    if ( face->blend == ((void *)0) )
    {

      if ( (error = face->goto_table( face, ( ( (FT_ULong)'g' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'a' << 8 ) | (FT_ULong)'r' ),
                                      stream, &table_len )) != 0 )
        goto Exit;

      if ( (error = face->goto_table( face, ( ( (FT_ULong)'f' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'a' << 8 ) | (FT_ULong)'r' ),
                                      stream, &table_len )) != 0 )
        goto Exit;

      fvar_start = FT_Stream_Pos( stream );

      if ( ( ( error = (FT_Stream_ReadFields( stream, fvar_fields, &fvar_head )) ) != 0 ) )
        goto Exit;

      if ( fvar_head.version != (FT_Long)0x00010000L ||
           fvar_head.countSizePairs != 2 ||
           fvar_head.axisSize != 20 ||
           fvar_head.instanceSize != 4 + 4 * fvar_head.axisCount ||
           fvar_head.offsetToData + fvar_head.axisCount * 20U +
             fvar_head.instanceCount * fvar_head.instanceSize > table_len )
      {
        error = TT_Err_Invalid_Table;
        goto Exit;
      }

      if ( ( ((face->blend) = (ft_mem_alloc( memory, (sizeof ( *(face->blend) )), &error ))), error != 0 ) )
        goto Exit;


      face->blend->mmvar_len =
        sizeof ( FT_MM_Var ) +
        fvar_head.axisCount * sizeof ( FT_Var_Axis ) +
        fvar_head.instanceCount * sizeof ( FT_Var_Named_Style ) +
        fvar_head.instanceCount * fvar_head.axisCount * sizeof ( FT_Fixed ) +
        5 * fvar_head.axisCount;

      if ( ( ((mmvar) = (ft_mem_alloc( memory, (face->blend->mmvar_len), &error ))), error != 0 ) )
        goto Exit;
      face->blend->mmvar = mmvar;

      mmvar->num_axis =
        fvar_head.axisCount;
      mmvar->num_designs =
        (FT_UInt)-1;


      mmvar->num_namedstyles =
        fvar_head.instanceCount;
      mmvar->axis =
        (FT_Var_Axis*)&(mmvar[1]);
      mmvar->namedstyle =
        (FT_Var_Named_Style*)&(mmvar->axis[fvar_head.axisCount]);

      next_coords =
        (FT_Fixed*)&(mmvar->namedstyle[fvar_head.instanceCount]);
      for ( i = 0; i < fvar_head.instanceCount; ++i )
      {
        mmvar->namedstyle[i].coords = next_coords;
        next_coords += fvar_head.axisCount;
      }

      next_name = (FT_String*)next_coords;
      for ( i = 0; i < fvar_head.axisCount; ++i )
      {
        mmvar->axis[i].name = next_name;
        next_name += 5;
      }

      if ( ( ( error = (FT_Stream_Seek( stream, fvar_start + fvar_head.offsetToData )) ) != 0 ) )
        goto Exit;

      a = mmvar->axis;
      for ( i = 0; i < fvar_head.axisCount; ++i )
      {
        GX_FVar_Axis axis_rec;


        if ( ( ( error = (FT_Stream_ReadFields( stream, fvaraxis_fields, &axis_rec )) ) != 0 ) )
          goto Exit;
        a->tag = axis_rec.axisTag;
        a->minimum = axis_rec.minValue;
        a->def = axis_rec.defaultValue;
        a->maximum = axis_rec.maxValue;
        a->strid = axis_rec.nameID;

        a->name[0] = (FT_String)( a->tag >> 24 );
        a->name[1] = (FT_String)( ( a->tag >> 16 ) & 0xFF );
        a->name[2] = (FT_String)( ( a->tag >> 8 ) & 0xFF );
        a->name[3] = (FT_String)( ( a->tag ) & 0xFF );
        a->name[4] = 0;

        ++a;
      }

      ns = mmvar->namedstyle;
      for ( i = 0; i < fvar_head.instanceCount; ++i, ++ns )
      {
        if ( ( ( error = ((FT_Stream_EnterFrame( stream, 4L + 4L * fvar_head.axisCount ))) ) != 0 ) )
          goto Exit;

        ns->strid = ( (FT_UShort)FT_Stream_GetShort( stream ) );
        (void) ( (FT_UShort)FT_Stream_GetShort( stream ) );

        for ( j = 0; j < fvar_head.axisCount; ++j )
          ns->coords[j] = ( (FT_ULong)FT_Stream_GetLong( stream ) );

        (FT_Stream_ExitFrame( stream ));
      }
    }

    if ( master != ((void *)0) )
    {
      FT_UInt n;


      if ( ( ((mmvar) = (ft_mem_alloc( memory, (face->blend->mmvar_len), &error ))), error != 0 ) )
        goto Exit;
      memcpy( mmvar, face->blend->mmvar, face->blend->mmvar_len );

      mmvar->axis =
        (FT_Var_Axis*)&(mmvar[1]);
      mmvar->namedstyle =
        (FT_Var_Named_Style*)&(mmvar->axis[mmvar->num_axis]);
      next_coords =
        (FT_Fixed*)&(mmvar->namedstyle[mmvar->num_namedstyles]);

      for ( n = 0; n < mmvar->num_namedstyles; ++n )
      {
        mmvar->namedstyle[n].coords = next_coords;
        next_coords += mmvar->num_axis;
      }

      a = mmvar->axis;
      next_name = (FT_String*)next_coords;
      for ( n = 0; n < mmvar->num_axis; ++n )
      {
        a->name = next_name;


        if ( a->tag == ( ( (FT_ULong)'w' << 24 ) | ( (FT_ULong)'g' << 16 ) | ( (FT_ULong)'h' << 8 ) | (FT_ULong)'t' ) )
          a->name = (char *)"Weight";
        else if ( a->tag == ( ( (FT_ULong)'w' << 24 ) | ( (FT_ULong)'d' << 16 ) | ( (FT_ULong)'t' << 8 ) | (FT_ULong)'h' ) )
          a->name = (char *)"Width";
        else if ( a->tag == ( ( (FT_ULong)'o' << 24 ) | ( (FT_ULong)'p' << 16 ) | ( (FT_ULong)'s' << 8 ) | (FT_ULong)'z' ) )
          a->name = (char *)"OpticalSize";
        else if ( a->tag == ( ( (FT_ULong)'s' << 24 ) | ( (FT_ULong)'l' << 16 ) | ( (FT_ULong)'n' << 8 ) | (FT_ULong)'t' ) )
          a->name = (char *)"Slant";

        next_name += 5;
        ++a;
      }

      *master = mmvar;
    }

  Exit:
    return error;
  }
# 847 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  static FT_Error
  TT_Set_MM_Blend( TT_Face face,
                   FT_UInt num_coords,
                   FT_Fixed* coords )
  {
    FT_Error error = TT_Err_Ok;
    GX_Blend blend;
    FT_MM_Var* mmvar;
    FT_UInt i;
    FT_Memory memory = face->root.memory;

    enum
    {
      mcvt_retain,
      mcvt_modify,
      mcvt_load

    } manageCvt;


    face->doblend = 0;

    if ( face->blend == ((void *)0) )
    {
      if ( (error = TT_Get_MM_Var( face, ((void *)0))) != 0 )
        goto Exit;
    }

    blend = face->blend;
    mmvar = blend->mmvar;

    if ( num_coords != mmvar->num_axis )
    {
      error = TT_Err_Invalid_Argument;
      goto Exit;
    }

    for ( i = 0; i < num_coords; ++i )
      if ( coords[i] < -0x00010000L || coords[i] > 0x00010000L )
      {
        error = TT_Err_Invalid_Argument;
        goto Exit;
      }

    if ( blend->glyphoffsets == ((void *)0) )
      if ( (error = ft_var_load_gvar( face )) != 0 )
        goto Exit;

    if ( blend->normalizedcoords == ((void *)0) )
    {
      if ( ( ((blend->normalizedcoords) = (ft_mem_realloc( memory, sizeof ( *(blend->normalizedcoords) ), 0, (num_coords), ((void *)0), &error ))), error != 0 ) )
        goto Exit;

      manageCvt = mcvt_modify;




    }
    else
    {
      for ( i = 0;
            i < num_coords && blend->normalizedcoords[i] == coords[i];
            ++i );
        if ( i == num_coords )
          manageCvt = mcvt_retain;
        else
          manageCvt = mcvt_load;





    }

    blend->num_axis = num_coords;
    memcpy( blend->normalizedcoords, coords, num_coords * sizeof ( FT_Fixed ) )

                                                   ;

    face->doblend = 1;

    if ( face->cvt != ((void *)0) )
    {
      switch ( manageCvt )
      {
      case mcvt_load:


        do { ft_mem_free( memory, (face->cvt) ); (face->cvt) = ((void *)0); } while ( 0 );
        face->cvt = ((void *)0);

        tt_face_load_cvt( face, face->root.stream );
        break;

      case mcvt_modify:


        tt_face_vary_cvt( face, face->root.stream );
        break;

      case mcvt_retain:

        break;
      }
    }

  Exit:
    return error;
  }
# 981 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  static FT_Error
  TT_Set_Var_Design( TT_Face face,
                     FT_UInt num_coords,
                     FT_Fixed* coords )
  {
    FT_Error error = TT_Err_Ok;
    FT_Fixed* normalized = ((void *)0);
    GX_Blend blend;
    FT_MM_Var* mmvar;
    FT_UInt i, j;
    FT_Var_Axis* a;
    GX_AVarSegment av;
    FT_Memory memory = face->root.memory;


    if ( face->blend == ((void *)0) )
    {
      if ( (error = TT_Get_MM_Var( face, ((void *)0) )) != 0 )
        goto Exit;
    }

    blend = face->blend;
    mmvar = blend->mmvar;

    if ( num_coords != mmvar->num_axis )
    {
      error = TT_Err_Invalid_Argument;
      goto Exit;
    }





    if ( ( ((normalized) = (ft_mem_realloc( memory, sizeof ( *(normalized) ), 0, (mmvar->num_axis), ((void *)0), &error ))), error != 0 ) )
      goto Exit;

    a = mmvar->axis;
    for ( i = 0; i < mmvar->num_axis; ++i, ++a )
    {
      if ( coords[i] > a->maximum || coords[i] < a->minimum )
      {
        error = TT_Err_Invalid_Argument;
        goto Exit;
      }

      if ( coords[i] < a->def )
      {
        normalized[i] = -FT_MulDiv( coords[i] - a->def,
                                    0x10000L,
                                    a->minimum - a->def );
      }
      else if ( a->maximum == a->def )
        normalized[i] = 0;
      else
      {
        normalized[i] = FT_MulDiv( coords[i] - a->def,
                                   0x10000L,
                                   a->maximum - a->def );
      }
    }

    if ( !blend->avar_checked )
      ft_var_load_avar( face );

    if ( blend->avar_segment != ((void *)0) )
    {
      av = blend->avar_segment;
      for ( i = 0; i < mmvar->num_axis; ++i, ++av )
      {
        for ( j = 1; j < (FT_UInt)av->pairCount; ++j )
          if ( normalized[i] < av->correspondence[j].fromCoord )
          {
            normalized[i] =
              FT_MulDiv(
                FT_MulDiv(
                  normalized[i] - av->correspondence[j - 1].fromCoord,
                  0x10000L,
                  av->correspondence[j].fromCoord -
                    av->correspondence[j - 1].fromCoord ),
                av->correspondence[j].toCoord -
                  av->correspondence[j - 1].toCoord,
                0x10000L ) +
              av->correspondence[j - 1].toCoord;
            break;
          }
      }
    }

    error = TT_Set_MM_Blend( face, num_coords, normalized );

  Exit:
    do { ft_mem_free( memory, (normalized) ); (normalized) = ((void *)0); } while ( 0 );
    return error;
  }
# 1108 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  static FT_Error
  tt_face_vary_cvt( TT_Face face,
                    FT_Stream stream )
  {
    FT_Error error;
    FT_Memory memory = stream->memory;
    FT_ULong table_start;
    FT_ULong table_len;
    FT_UInt tupleCount;
    FT_ULong offsetToData;
    FT_ULong here;
    FT_UInt i, j;
    FT_Fixed* tuple_coords = ((void *)0);
    FT_Fixed* im_start_coords = ((void *)0);
    FT_Fixed* im_end_coords = ((void *)0);
    GX_Blend blend = face->blend;
    FT_UInt point_count;
    FT_UShort* localpoints;
    FT_Short* deltas;


    do {} while ( 0 );

    if ( blend == ((void *)0) )
    {
      do {} while ( 0 );

      error = TT_Err_Ok;
      goto Exit;
    }

    if ( face->cvt == ((void *)0) )
    {
      do {} while ( 0 );

      error = TT_Err_Ok;
      goto Exit;
    }

    error = face->goto_table( face, ( ( (FT_ULong)'c' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'a' << 8 ) | (FT_ULong)'r' ), stream, &table_len );
    if ( error )
    {
      do {} while ( 0 );

      error = TT_Err_Ok;
      goto Exit;
    }

    if ( ( ( error = ((FT_Stream_EnterFrame( stream, table_len ))) ) != 0 ) )
    {
      error = TT_Err_Ok;
      goto Exit;
    }

    table_start = ( (stream)->cursor - (stream)->base );
    if ( ( (FT_Long)FT_Stream_GetLong( stream ) ) != 0x00010000L )
    {
      do {} while ( 0 );

      error = TT_Err_Ok;
      goto FExit;
    }

    if ( ( ((tuple_coords) = (ft_mem_realloc( memory, sizeof ( *(tuple_coords) ), 0, (blend->num_axis), ((void *)0), &error ))), error != 0 ) ||
         ( ((im_start_coords) = (ft_mem_realloc( memory, sizeof ( *(im_start_coords) ), 0, (blend->num_axis), ((void *)0), &error ))), error != 0 ) ||
         ( ((im_end_coords) = (ft_mem_realloc( memory, sizeof ( *(im_end_coords) ), 0, (blend->num_axis), ((void *)0), &error ))), error != 0 ) )
      goto FExit;

    tupleCount = ( (FT_UShort)FT_Stream_GetShort( stream ) );
    offsetToData = table_start + ( (FT_UShort)FT_Stream_GetShort( stream ) );





    for ( i = 0; i < ( tupleCount & 0xFFF ); ++i )
    {
      FT_UInt tupleDataSize;
      FT_UInt tupleIndex;
      FT_Fixed apply;


      tupleDataSize = ( (FT_UShort)FT_Stream_GetShort( stream ) );
      tupleIndex = ( (FT_UShort)FT_Stream_GetShort( stream ) );




      if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
      {
        for ( j = 0; j < blend->num_axis; ++j )
          tuple_coords[j] = ( (FT_Short)FT_Stream_GetShort( stream ) ) << 2;

      }
      else
      {


        if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
          for ( j = 0; j < 2 * blend->num_axis; ++j )
            (void)( (FT_Short)FT_Stream_GetShort( stream ) );

        offsetToData += tupleDataSize;
        continue;
      }

      if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
      {
        for ( j = 0; j < blend->num_axis; ++j )
          im_start_coords[j] = ( (FT_Short)FT_Stream_GetShort( stream ) ) << 2;
        for ( j = 0; j < blend->num_axis; ++j )
          im_end_coords[j] = ( (FT_Short)FT_Stream_GetShort( stream ) ) << 2;
      }

      apply = ft_var_apply_tuple( blend,
                                  (FT_UShort)tupleIndex,
                                  tuple_coords,
                                  im_start_coords,
                                  im_end_coords );
      if (
           apply == 0 ||


           !( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS ) )
      {
        offsetToData += tupleDataSize;
        continue;
      }

      here = ( (stream)->cursor - (stream)->base );

      ( (stream)->cursor = (stream)->base+(offsetToData) );

      localpoints = ft_var_readpackedpoints( stream, &point_count );
      deltas = ft_var_readpackeddeltas( stream,
                                             point_count == 0 ? face->cvt_size
                                                              : point_count );
      if ( localpoints == ((void *)0) || deltas == ((void *)0) )
                                ;

      else if ( localpoints == (FT_UShort*)( -1 ) )
      {

        for ( j = 0; j < face->cvt_size; ++j )
          face->cvt[j] = (FT_Short)( face->cvt[j] +
                                     FT_MulFix( deltas[j], apply ) );
      }

      else
      {
        for ( j = 0; j < point_count; ++j )
        {
          int pindex = localpoints[j];

          face->cvt[pindex] = (FT_Short)( face->cvt[pindex] +
                                          FT_MulFix( deltas[j], apply ) );
        }
      }

      if ( localpoints != (FT_UShort*)( -1 ) )
        do { ft_mem_free( memory, (localpoints) ); (localpoints) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (deltas) ); (deltas) = ((void *)0); } while ( 0 );

      offsetToData += tupleDataSize;

      ( (stream)->cursor = (stream)->base+(here) );
    }

  FExit:
    (FT_Stream_ExitFrame( stream ));

  Exit:
    do { ft_mem_free( memory, (tuple_coords) ); (tuple_coords) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (im_start_coords) ); (im_start_coords) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (im_end_coords) ); (im_end_coords) = ((void *)0); } while ( 0 );

    return error;
  }
# 1310 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  static FT_Error
  TT_Vary_Get_Glyph_Deltas( TT_Face face,
                            FT_UInt glyph_index,
                            FT_Vector* *deltas,
                            FT_UInt n_points )
  {
    FT_Stream stream = face->root.stream;
    FT_Memory memory = stream->memory;
    GX_Blend blend = face->blend;
    FT_Vector* delta_xy;

    FT_Error error;
    FT_ULong glyph_start;
    FT_UInt tupleCount;
    FT_ULong offsetToData;
    FT_ULong here;
    FT_UInt i, j;
    FT_Fixed* tuple_coords = ((void *)0);
    FT_Fixed* im_start_coords = ((void *)0);
    FT_Fixed* im_end_coords = ((void *)0);
    FT_UInt point_count, spoint_count = 0;
    FT_UShort* sharedpoints = ((void *)0);
    FT_UShort* localpoints = ((void *)0);
    FT_UShort* points;
    FT_Short *deltas_x, *deltas_y;


    if ( !face->doblend || blend == ((void *)0) )
      return TT_Err_Invalid_Argument;


    if ( ( ((delta_xy) = (ft_mem_realloc( memory, sizeof ( *(delta_xy) ), 0, (n_points), ((void *)0), &error ))), error != 0 ) )
      goto Exit;
    *deltas = delta_xy;

    if ( glyph_index >= blend->gv_glyphcnt ||
         blend->glyphoffsets[glyph_index] ==
           blend->glyphoffsets[glyph_index + 1] )
      return TT_Err_Ok;

    if ( ( ( error = (FT_Stream_Seek( stream, blend->glyphoffsets[glyph_index] )) ) != 0 ) ||
         ( ( error = ((FT_Stream_EnterFrame( stream, blend->glyphoffsets[glyph_index + 1] - blend->glyphoffsets[glyph_index] ))) ) != 0 )
                                                              )
      goto Fail1;

    glyph_start = ( (stream)->cursor - (stream)->base );




    if ( ( ((tuple_coords) = (ft_mem_realloc( memory, sizeof ( *(tuple_coords) ), 0, (blend->num_axis), ((void *)0), &error ))), error != 0 ) ||
         ( ((im_start_coords) = (ft_mem_realloc( memory, sizeof ( *(im_start_coords) ), 0, (blend->num_axis), ((void *)0), &error ))), error != 0 ) ||
         ( ((im_end_coords) = (ft_mem_realloc( memory, sizeof ( *(im_end_coords) ), 0, (blend->num_axis), ((void *)0), &error ))), error != 0 ) )
      goto Fail2;

    tupleCount = ( (FT_UShort)FT_Stream_GetShort( stream ) );
    offsetToData = glyph_start + ( (FT_UShort)FT_Stream_GetShort( stream ) );

    if ( tupleCount & GX_TC_TUPLES_SHARE_POINT_NUMBERS )
    {
      here = ( (stream)->cursor - (stream)->base );

      ( (stream)->cursor = (stream)->base+(offsetToData) );

      sharedpoints = ft_var_readpackedpoints( stream, &spoint_count );
      offsetToData = ( (stream)->cursor - (stream)->base );

      ( (stream)->cursor = (stream)->base+(here) );
    }

    for ( i = 0; i < ( tupleCount & GX_TC_TUPLE_COUNT_MASK ); ++i )
    {
      FT_UInt tupleDataSize;
      FT_UInt tupleIndex;
      FT_Fixed apply;


      tupleDataSize = ( (FT_UShort)FT_Stream_GetShort( stream ) );
      tupleIndex = ( (FT_UShort)FT_Stream_GetShort( stream ) );

      if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
      {
        for ( j = 0; j < blend->num_axis; ++j )
          tuple_coords[j] = ( (FT_Short)FT_Stream_GetShort( stream ) ) << 2;

      }
      else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )
      {
        error = TT_Err_Invalid_Table;
        goto Fail3;
      }
      else
      {
        memcpy( tuple_coords, &blend->tuplecoords[(tupleIndex & 0xFFF) * blend->num_axis], blend->num_axis * sizeof ( FT_Fixed ) )


                                                 ;
      }

      if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
      {
        for ( j = 0; j < blend->num_axis; ++j )
          im_start_coords[j] = ( (FT_Short)FT_Stream_GetShort( stream ) ) << 2;
        for ( j = 0; j < blend->num_axis; ++j )
          im_end_coords[j] = ( (FT_Short)FT_Stream_GetShort( stream ) ) << 2;
      }

      apply = ft_var_apply_tuple( blend,
                                  (FT_UShort)tupleIndex,
                                  tuple_coords,
                                  im_start_coords,
                                  im_end_coords );

      if ( apply == 0 )
      {
        offsetToData += tupleDataSize;
        continue;
      }

      here = ( (stream)->cursor - (stream)->base );

      if ( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS )
      {
        ( (stream)->cursor = (stream)->base+(offsetToData) );

        localpoints = ft_var_readpackedpoints( stream, &point_count );
        points = localpoints;
      }
      else
      {
        points = sharedpoints;
        point_count = spoint_count;
      }

      deltas_x = ft_var_readpackeddeltas( stream,
                                          point_count == 0 ? n_points
                                                           : point_count );
      deltas_y = ft_var_readpackeddeltas( stream,
                                          point_count == 0 ? n_points
                                                           : point_count );

      if ( points == ((void *)0) || deltas_y == ((void *)0) || deltas_x == ((void *)0) )
        ;

      else if ( points == (FT_UShort*)( -1 ) )
      {

        for ( j = 0; j < n_points; ++j )
        {
          delta_xy[j].x += FT_MulFix( deltas_x[j], apply );
          delta_xy[j].y += FT_MulFix( deltas_y[j], apply );
        }
      }

      else
      {
        for ( j = 0; j < point_count; ++j )
        {
          delta_xy[localpoints[j]].x += FT_MulFix( deltas_x[j], apply );
          delta_xy[localpoints[j]].y += FT_MulFix( deltas_y[j], apply );
        }
      }

      if ( localpoints != (FT_UShort*)( -1 ) )
        do { ft_mem_free( memory, (localpoints) ); (localpoints) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (deltas_x) ); (deltas_x) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (deltas_y) ); (deltas_y) = ((void *)0); } while ( 0 );

      offsetToData += tupleDataSize;

      ( (stream)->cursor = (stream)->base+(here) );
    }

  Fail3:
    do { ft_mem_free( memory, (tuple_coords) ); (tuple_coords) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (im_start_coords) ); (im_start_coords) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (im_end_coords) ); (im_end_coords) = ((void *)0); } while ( 0 );

  Fail2:
    (FT_Stream_ExitFrame( stream ));

  Fail1:
    if ( error )
    {
      do { ft_mem_free( memory, (delta_xy) ); (delta_xy) = ((void *)0); } while ( 0 );
      *deltas = ((void *)0);
    }

  Exit:
    return error;
  }
# 1511 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/ttgxvar.c"
  static void
  tt_done_blend( FT_Memory memory,
                 GX_Blend blend )
  {
    if ( blend != ((void *)0) )
    {
      FT_UInt i;


      do { ft_mem_free( memory, (blend->normalizedcoords) ); (blend->normalizedcoords) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (blend->mmvar) ); (blend->mmvar) = ((void *)0); } while ( 0 );

      if ( blend->avar_segment != ((void *)0) )
      {
        for ( i = 0; i < blend->num_axis; ++i )
          do { ft_mem_free( memory, (blend->avar_segment[i].correspondence) ); (blend->avar_segment[i].correspondence) = ((void *)0); } while ( 0 );
        do { ft_mem_free( memory, (blend->avar_segment) ); (blend->avar_segment) = ((void *)0); } while ( 0 );
      }

      do { ft_mem_free( memory, (blend->tuplecoords) ); (blend->tuplecoords) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (blend->glyphoffsets) ); (blend->glyphoffsets) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (blend) ); (blend) = ((void *)0); } while ( 0 );
    }
  }
# 33 "C:/Documents and Settings/stasiek.TC12/My Documents/My Projects/X86_LIBRARIES/freetype/src/truetype/truetype.c" 2
